<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android资源采集</title>
    <url>/posts/0/</url>
    <content><![CDATA[<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><span id="more"></span>

<h3 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb -s 042461198L000964 shell dumpsys cpuinfo</span><br></pre></td></tr></table></figure>

<h3 id="结果解析："><a href="#结果解析：" class="headerlink" title="结果解析："></a>结果解析：</h3><p><img src="/text_image/cpu.png" alt="alt text"></p>
<h5 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">其中第一行：Load: 10.1 / 2.49 / 0.83</span><br><span class="line">表示系统1min/5min/10min cpu负载平均值</span><br><span class="line">标准说明：1/0.7---理论上单核满载是1，但是在真实情况下，满载会存在性能问题，一般不超过70%；四核满载则是4.</span><br></pre></td></tr></table></figure>
<h5 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">75% 593/system_server: 58% user + 16% kernel / faults: 33566 minor 473 major</span><br><span class="line">该行表示资源消耗情况；</span><br><span class="line">593/75%/58%/16%：pid/cpu负载/用户空间负载/内核空间负载</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="命令扩展"><a href="#命令扩展" class="headerlink" title="命令扩展"></a>命令扩展</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb -s 042461198L000964 shell dumpsys cpuinfo | grep -w com.afmobi.boomplayer:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/lipanpan1030/article/details/108118685">dumpsys工具cpu采集说明</a></p>
<h2 id="MEN"><a href="#MEN" class="headerlink" title="MEN"></a>MEN</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb -s 042461198L000964 shell  dumpsys  meminfo com.afmobi.boomplayer</span><br></pre></td></tr></table></figure>

<h3 id="结果解析：-1"><a href="#结果解析：-1" class="headerlink" title="结果解析："></a>结果解析：</h3><p><img src="/text_image/men.png" alt="alt text"><br><strong>由图可知：</strong> 需要解析获取TOTAL之后的值，单位kb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#脚本如下</span></span><br><span class="line"><span class="comment"># 得到men的使用情况</span></span><br><span class="line">def get_men(devices, pkg_name):</span><br><span class="line">    cmd = <span class="string">&quot;adb -s &quot;</span>+devices+<span class="string">&quot; shell  dumpsys  meminfo %s&quot;</span>  %(pkg_name)</span><br><span class="line">    total = <span class="string">&quot;TOTAL&quot;</span></span><br><span class="line">    get_cmd = os.popen(cmd).readlines()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;men:&#x27;</span>,get_cmd)</span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> get_cmd:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;men_info:&#x27;</span>,info)</span><br><span class="line">        info_sp = info.strip().split()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;info_sp:&quot;</span>,info_sp)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(len(info_sp)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;item:&quot;</span>,item)</span><br><span class="line">            <span class="keyword">if</span> info_sp[item] == total:</span><br><span class="line">                <span class="built_in">return</span> int(info_sp[item+1])</span><br><span class="line">    <span class="built_in">return</span> 0</span><br></pre></td></tr></table></figure>
<h2 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h2><p><strong>fps为帧率，表示单位时间1s内屏幕刷新的次数，Android6之前存在一个相对标准，帧率不能低于60，即单帧耗时不能大于16.67ms,否则会存在丢帧</strong></p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb -s 042461198L000964 shell dumpsys gfxinfo com.afmobi.boomplayer | grep -A 128 Execute | grep -v <span class="string">&#x27;[a-z]&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="结果解析：-2"><a href="#结果解析：-2" class="headerlink" title="结果解析："></a>结果解析：</h3><p><img src="/text_image/fps.png" alt="alt text"><br><strong>如上图 Draw/Prepare/Process/Execute表示一帧被绘制的四个阶段，四个值相加即为一帧的耗时(无数据则很可能是手机的“GPU呈现模式分析”未打开)</strong></p>
<p><a href="https://blog.csdn.net/weixin_43291944/article/details/98497689">fps说明</a></p>
<h2 id="FLOW"><a href="#FLOW" class="headerlink" title="FLOW"></a>FLOW</h2><p><strong>流量获取有多个路径，比如通过在tcp_snd文件获取tcp发送流量，在tcp_rcv文件中获取tcp接受流量，在/net/dev中获取总的发送/接受流量，同时也可以通过代理获取流量值</strong></p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp_send_cmd=adb shell cat /proc/uid_stat/uid_cmd/tcp_snd</span><br><span class="line"></span><br><span class="line">tcp_recv_cmd=adb shell cat /proc/uid_stat/uid_cmd/tcp_rcv</span><br><span class="line"></span><br><span class="line">sum_send_cmd=adb shell cat /proc/pid_cmd/net/dev|grep <span class="string">&quot;wlan0&quot;</span>|awk <span class="string">&quot;&#123;print <span class="variable">$10</span>&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">sum_recv_cmd=adb shell cat /proc/pid_cmd/net/dev|grep <span class="string">&quot;wlan0&quot;</span>|awk <span class="string">&quot;&#123;print <span class="variable">$2</span>&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://testerhome.com/topics/14310">流量命令</a></p>
<h2 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h2><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys batterystats --charged com.afmobi.boomplayer</span><br></pre></td></tr></table></figure>
<p><strong>预计的电量值如下</strong><br><img src="/text_image/dian.png" alt="alt text"></p>
<p><a href="https://source.android.com/devices/tech/power/batterystats?hl=zh-cn">电量/流量说明</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>稳定性--ANR治理</title>
    <url>/posts/1ee32bf1/</url>
    <content><![CDATA[<h1 id="ANR治理"><a href="#ANR治理" class="headerlink" title="ANR治理"></a>ANR治理</h1><ul>
<li><em><strong>大纲</strong></em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anr是什么？</span><br><span class="line">为什么会产生anr?</span><br><span class="line">anr是怎样产生的，哪些场景下会产生？</span><br><span class="line">anr如何治理？</span><br><span class="line">解决anr问题的价值？</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ul>
<li><strong>anr是什么？</strong><br>  <code>anr(Applicatipon No Response),即应用无响应；本质是一个性能问题；在用户和app进行交互时，常会遇到长时间无响应/卡顿的场景；为了改善性能，Android设计了anr的机制，即保证交互能在一定时间内完成，如果未完成，就抛出异常，也就是ANR;   </code></li>
<li><strong>anr设计机制：</strong><br>  <code>是系统通过与之交互的组件(Activity，Service，Receiver，Provider)以及用户交互(InputEvent)进行超时监控，以判断应用进程(主线程)是否存在卡死或响应过慢的问题，通俗来说就是很多系统中看门狗(watchdog)的设计思想。   </code><ul>
<li><strong>不同的组件，系统设置的超时时间是不同的，这个时间不同手机厂商的os可能也会做调整：</strong><br><img src="/text_image/anr_%E7%BB%84%E4%BB%B6_%E8%B6%85%E6%97%B6.png" alt="alt text"></li>
<li><strong>系统抛出anr的机制：</strong><br><code>在进行相关的操作前，系统会基于当前的时间戳和这个类型组件的超时时间设置，计算出超时时间戳；并将超时时间戳传递给anr触发函数，组件若未超时启动，则会在启动成功后，在传递一个参数给anr函数来阻止触发anr;若到超时时间，anr函数还未收到阻止信号，就会触发ANR(类似构建了个定时触发的任务)； </code></li>
<li><strong>超时触发流程如下：</strong><br><img src="/text_image/anr_%E7%BB%84%E4%BB%B6_%E8%B6%85%E6%97%B6.png" alt="alt text"></li>
</ul>
</li>
</ul>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1MzYzMjE0MQ==&action=getalbum&album_id=1780091311874686979&scene=173&from_msgid=2247488558&from_itemidx=1&count=3&nolastread=1&uin=&key=&devicetype=Windows+10+x64&version=63030532&lang=zh_CN&ascene=0&fontgear=2">头条anr治理系列</a></p>
<p><a href="https://mp.weixin.qq.com/s/L30s7rOyn6NcPC2y9XNZIQ">百度anr治理</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>anr</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLOPI使用教程</title>
    <url>/posts/49e140/</url>
    <content><![CDATA[<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">介绍</span><br><span class="line">使用指南</span><br><span class="line">和业务结合</span><br><span class="line">下一步</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><p><em><strong>介绍</strong></em></p>
<p>  <code>solopi是支付宝团队研发的ui自动化工具;支持UI录制回放，录制脚本的编辑/扩展/转换成appium脚本/录制脚本支持分发到其他的设备执行；同时还支持性能测试和一机多控，执行采集各种性能数据，同时支持通过一台设备控制多台设备的行为；</code></p>
</li>
<li><p><em><strong>使用指南</strong></em></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境准备</span><br><span class="line">app配置</span><br><span class="line">录制</span><br><span class="line">回放</span><br><span class="line">性能测试</span><br><span class="line">一机多控</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>环境准备</strong></p>
<ul>
<li><p><em>下载配置Androidsdk</em></p>
<ul>
<li>地址:<a href="https://developer.android.com/studio/releases/platform-tools#downloads">https://developer.android.com/studio/releases/platform-tools#downloads</a></li>
<li>操作：下载安装完Android调试工具后，在下载对应系统版本的 SDK Platform Tools，配置好环境变量，注意win10以上系统环境变量配置即生效，低版本需要重启pc才能生效；</li>
</ul>
</li>
<li><p><em>给手机授权</em></p>
<ul>
<li>操作：进入开发者模式，并授权usb调试权限；</li>
</ul>
</li>
<li><p><em>检测环境并连接wifi</em></p>
<ul>
<li>操作：通过adb devices命令检测，同时要连接wifi;</li>
</ul>
</li>
<li><p><em>建立连接</em></p>
<ul>
<li>操作：通过pc的cmd启动服务,输入（adb tcpip 5555）</li>
</ul>
</li>
<li><p><em>下载solopi的apk</em></p>
<ul>
<li>地址：<a href="https://github.com/alipay/SoloPi/releases/download/v0.11.2/SoloPi_0.11.2.apk">apk点击下载</a></li>
<li>操作：下载安装后，通过配置授权</li>
<li>环境配置：<a href="https://github.com/alipay/SoloPi/wiki/FirstUse">地址跳转参考内容</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>app配置</strong></p>
<p>  <code>按需配置，一般不需要进行配置；可参考上方的环境配置</code></p>
</li>
<li><p><strong>录制/回放</strong></p>
<ul>
<li><a href="https://github.com/alipay/SoloPi/wiki/RecordCase"><em>官方教程</em></a></li>
<li>录制：录制支持直接对收到操作进行录制，且录制的脚本支持编辑/扩展/保存/导入等操作，支持各类操作和断言，支持图像识别，简单方便；</li>
<li>回放：回放支持单脚本回放，支持批量回放，支持重复播放；</li>
<li>优点：操作简单，可扩展编辑定制策略，可同步到其他设备，可重复回放支持暴力遍历；</li>
<li>缺点：不支持持续集成，需要手动触发；</li>
</ul>
</li>
<li><p><strong>性能测试</strong></p>
<ul>
<li><a href="https://github.com/alipay/SoloPi/wiki/Performance"><em>官方教程</em></a></li>
<li>操作：性能测试时，直接勾选需要监控的性能指标，不进行录制则可以实时查看；进行录制时，点击录制按钮开始录制，录制结束后点击录制结束按钮，录制的性能数据会存储下来，支持图表分析，可同时存储多份性能数据；</li>
<li>优点：支持实时查看场景的性能，可和业务测试结合方便简单；支持性能录制，可和UI自动化结合，查看各场景的性能变化和差异；</li>
<li>缺点：不支持续集成，利用脚本进行回放时不支持性能监控；</li>
</ul>
</li>
<li><p><strong>一机多控</strong></p>
<ul>
<li>[<em>官方教程</em>]</li>
<li>操作：多台设备上同时安装solopi和待测APP；做好配置和授权操作，同时主机（控制机）选中一机多控，选中为主机；其他设备点击一机多控，选中为从机；然后用主机扫码录入从机，然后在主机点击建立主从机的连接，然后主机点击录屏按钮，开始进行一机多控操作；原理是利用solopi的录屏回放功能，主机录屏，从机回放；</li>
<li>优点：可以用一台机器，控制多台设备操作，能有效的覆盖兼容性测试；</li>
<li>缺点：不支持ios系统；由于是先录制，在回放，因此所有设备都需要有网络，且必须是同一局域网，且存在延时；不支持批量操作时，同时监控性能数据；</li>
</ul>
</li>
</ul>
<ul>
<li><p><em><strong>和业务结合</strong></em></p>
<p>  <code>和业务结合使用前，需要先梳理清楚solopi的优缺点：</code></p>
<p>  优点：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">支持录制UI自动化，且录制的脚本支持编辑自定义，且无环境依赖；</span><br><span class="line">录制的脚本可以导出在任意设备上回放，或者转换成appium脚本；</span><br><span class="line">支持回放管理，支持批量回放和重复回放；</span><br><span class="line">支持性能测试，实时监控APP性能和录制APP的性能；</span><br><span class="line">支持一机多控，可同时控制多台设备；</span><br></pre></td></tr></table></figure>

<p>  缺点：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不支持iOS设备，仅支持Android设备；</span><br><span class="line">工具是一款纯功能测试辅助软件，不支持持续集成；</span><br><span class="line">功能过于离散，几个功能不能结合在一起使用；</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>和业务结合：</strong></p>
<ul>
<li><p><em>rc验收阶段：</em><br><code>建议功能测试完毕且无误后，最后在rc验收一遍，主流程，验收时进行功能&quot;录制&quot;,录制的脚本可定期回放/开发了相关功能时进行回放/也可以通过Jenkins触发回放;</code></p>
</li>
<li><p><em>灰度/线上验收阶段：</em><br><code>建议测试进行线上验收时，进行录制，录制的脚本，可通过扩展进行定期回放；</code></p>
</li>
<li><p><em>冒烟/功能测试/rc验收阶段：</em><br><code>建议以上阶段，进行测试验收时，打开性能测试监控，观察功能场景有没用性能问题；</code></p>
</li>
<li><p><em>冒烟/兼容性测试阶段：</em><br><code>可以使用一机多控功能，进行兼容性测试；但此功能对控制的终端有要求，最好有固定的兼容环境；</code></p>
</li>
<li><p><em>稳定性治理/预装版本暴力回放：</em><br><code>使用重复回放功能进行暴力回放；</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>下一步：</strong></em></p>
</li>
</ul>
<p><a href="https://github.com/alipay/SoloPi"><em>Solopi github</em>_</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ui自动化</tag>
        <tag>稳定性</tag>
        <tag>前端性能</tag>
        <tag>solopi</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化元素定位</title>
    <url>/posts/2e4c0062/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">APPIUM元素定位原理</span><br><span class="line">常见的元素定位方式</span><br><span class="line">元素定位技巧/辅助工具</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="APPIUM元素定位原理"><a href="#APPIUM元素定位原理" class="headerlink" title="APPIUM元素定位原理"></a>APPIUM元素定位原理</h2><p><code>目前的UI自动化测试，使用Appium进行页面元素的定位和操作。如下图所示，AppiumServer和UiAutomator2的手机端进行通信后完成元素的操作。</code></p>
<p><img src="/text_image/appium%E6%B5%81%E7%A8%8B.png" alt="alt text"></p>
<p><code>底层实现过程</code><br><img src="/text_image/appium%E5%BA%95%E5%B1%82.png" alt="alt text"></p>
<ul>
<li>首先，Appium通过调用findElement的方式进行元素定位。</li>
<li>然后，调用Android提供UIDevice对象的findObject方法。</li>
<li>最终，通过PartialMatch.accept完成元素的查找。</li>
</ul>
<p>接下来我们看一下，这个PartialMatch.accept到底是如何完成元素定位的。通过对于<a href="https://android.googlesource.com/platform/frameworks/uiautomator/+/android-support-test/src/main/java/android/support/test/uiautomator/ByMatcher.java">源码</a>的研究，我们发现元素的信息都是存储在一个叫做AccessibilityNodeInfo的对象里面。源码中使用大量node.getXXX方法中的信息，大家是否眼熟呢？这些信息其实就是我们日常自动化测试中可以获取UI元素的属性。从这我们知道了appium元素定位的工作过程；<br><img src="/text_image/meitun%E5%85%83%E7%B4%A0.png" alt="alt_text"></p>
<h2 id="常见元素定位方式"><a href="#常见元素定位方式" class="headerlink" title="常见元素定位方式"></a>常见元素定位方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id定位</span><br><span class="line">xpath定位</span><br><span class="line">classname定位</span><br><span class="line">text定位</span><br><span class="line">坐标定位</span><br><span class="line">accessibility_id定位</span><br></pre></td></tr></table></figure>

<p><em><strong>1、id定位</strong></em></p>
<p><code>id定位是最常用的定位方式，在选择ID时需要验证ID唯一，此方法仅可用于Android，ios不可用</code></p>
<p><code>id定位示例：driver.find_element_by_id(&quot;id属性值&quot;)</code></p>
<ul>
<li>查找ID方式：①为使用uiautomatorviewer②为使用Appium Inspector</li>
</ul>
<p><img src="/text_image/id.png" alt="alt_text"><br><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>ID查找性能</li>
</ul>
<p><code>由上方的appium定位原理可知，查找页面元素位置，是在AccessibilityNodeInfo对象里查找的，这个对象维护的各属性值是字典，因此通过ID查询的性能是较快的</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/b_id.png" alt="alt_text"></li>
</ul>
<p><em><strong>2、xpath定位</strong></em></p>
<p><code>xpath定位也是最常用的定位方式之一，xpath是根据页面层级来定位元素位置，此方法仅可用于Android和iOS</code></p>
<p><code>xpath定位示例：driver.find_element_by_xpath(&quot;xpath表达式&quot;)</code></p>
<ul>
<li>查找xpath方式：①为使用uiautomatorviewer②为使用Appium Inspector</li>
</ul>
<p><img src="/text_image/id.png" alt="alt_text"><br><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>xpath查找性能</li>
</ul>
<p><code>由于xpath是根据元素位置来查找的，从头开始查找，因此xpath查找的性能一般较差，且不同写法查找范围不同，性能差异很大，一般通过id/name属性值来定位；参考</code><a href="https://www.runoob.com/xpath/xpath-syntax.html">xpath语法</a></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/b_id.png" alt="alt_text"></li>
</ul>
<p><em><strong>3、classname定位</strong></em></p>
<p><code>classname是基于classname值来定位元素，由于classname一般不唯一，一般不使用此值定位，使用的话也是结合xpath来使用,ios和Android均支持</code></p>
<p><code>class_name定位示例：driver.find_element_by_class_name(&quot;class_name属性值&quot;)</code></p>
<ul>
<li>查找classname方式：①为使用uiautomatorviewer②为使用Appium Inspector</li>
</ul>
<p><img src="/text_image/id.png" alt="alt_text"><br><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>classname查找性能</li>
</ul>
<p><code>classname是页面的classname属性值，用它来定位元素时，由于classname值一般不唯一，因此一般不直接用其定位，一般和xpath一起使用，将classname作为xpath的属性值，性能由于xpath和ID定位性能接近</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/b_id.png" alt="alt_text"></li>
</ul>
<p><em><strong>4、name定位</strong></em></p>
<p><code>name定位是使用页面text值来进行定位的，Android从5.5开始不支持name定位，iOS支持name定位</code></p>
<p><code>name定位示例：driver.find_element_by_name(&quot;text值&quot;)</code></p>
<ul>
<li>查找name方式：ios使用Appium Inspector</li>
</ul>
<p><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>name查找性能</li>
</ul>
<p><code>name查找性能较快，和id查找接近</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br>不支持</li>
</ul>
<p><em><strong>5、accessibility_id定位</strong></em></p>
<p><code>accessibility_id定位是使用页面content-desc属性值来进行定位的，android和ios均支持</code></p>
<p><code>accessibility_id定位示例：driver.find_element_by_accessibility_id(&quot;content-desc值&quot;)</code></p>
<ul>
<li>查找content-desc方式：①为使用uiautomatorviewer②为使用Appium Inspector</li>
</ul>
<p><img src="/text_image/id.png" alt="alt_text"><br><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>accessibility_id查找性能</li>
</ul>
<p><code>accessibility_id查找性能较快，和id查找接近</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/b_id.png" alt="alt_text"></li>
</ul>
<p><em><strong>6、指定uiautomator工具定位</strong></em></p>
<p><code>uiautomator定位方式是直接指定uiautomator工具来进行定位，可利用工具对象的属性来进行定位（支持ID/xpath/class_name等属性值来进行定位），仅支持Android，在Android环境下和driver.find_element_by_是完全一样的</code></p>
<p><code>accessibility_id定位示例：driver.find_element_by_android_uiautomator(&quot;UiSelector工具属性值来进行定位&quot;)</code></p>
<ul>
<li>查找属性值方式：①为使用uiautomatorviewer②为使用Appium Inspector</li>
</ul>
<p><img src="/text_image/id.png" alt="alt_text"><br><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>uiautomator工具查找性能</li>
</ul>
<p><code>Android环境下根据定位的属性值来区分，性能和driver.find_element_by_是完全一样的</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br>不支持，可扩展</li>
</ul>
<p><em><strong>7、css_selector定位</strong></em></p>
<p><code>css属性定位，支持通过页面的各类css属性来进行定位元素，支持单个属性和多个属性值组合定位，仅支持web</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1.用 标签名 定位查找</span><br><span class="line">driver.find_element_by_css_selector(&quot;input&quot;)</span><br><span class="line"></span><br><span class="line"># 2.用 id 属性定位查找 </span><br><span class="line">driver.find_element_by_css_selector(&quot;kw&quot;)</span><br><span class="line"></span><br><span class="line"># 3.用 class 属性定位查找</span><br><span class="line">driver.find_element_by_css_selector(&quot;s_ipt&quot;)</span><br><span class="line"></span><br><span class="line"># 4.其他属性定位</span><br><span class="line">driver.find_element_by_css_selector(&quot;[name&#x3D;&quot;wd&quot;]&quot;)</span><br><span class="line"></span><br><span class="line"># 5.标签名及id属性值组合定位</span><br><span class="line">driver.find_element_by_css_selector(&quot;input#kw&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>查找属性值方式：①为使用uiautomatorviewer②为使用Appium Inspector</li>
</ul>
<p><img src="/text_image/id.png" alt="alt_text"><br><img src="/text_image/appium_id.png" alt="alt_text"></p>
<ul>
<li>uiautomator工具查找性能</li>
</ul>
<p><code>性能根据定位的属性值来区分，性能和driver.find_element_by_是完全一样的</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/b_id.png" alt="alt_text"></li>
</ul>
<p><em><strong>8、单数定位和复数定位</strong></em></p>
<p><code>单数定位示例：driver.find_element_by_(&quot;值&quot;)</code></p>
<p><code>复数定位示例：driver.find_elements_by_(&quot;值&quot;).get(6)</code></p>
<p><strong>单数定位时定位到第一个元素即返回，返回单个对象；复数定位会定位到页面的所有对象，返回一个数组;现在支持id和xpath的单复数定位；复数定位主要用于某些位置无唯一元素的场景，可通过第几个来进行定位</strong><br><img src="/text_image/%E5%8D%95%E5%A4%8D.png" alt="alt_text"></p>
<p><em><strong>9、坐标定位</strong></em></p>
<p><code>APPIUM提供tap方法支持通过元素坐标进行点击，提供了一个adb_tap方法给大家获取元素坐标</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/%E5%9D%90%E6%A0%87.png" alt="alt_text"></li>
</ul>
<p><em><strong>10、图像识别</strong></em></p>
<p><code>APPIUM从1.9.0版本开始支持识别图像来进行查找对象，暂未调研。后续补充</code></p>
<ul>
<li>boomplay UI自动化框架的使用<br><img src="/text_image/%E5%9D%90%E6%A0%87.png" alt="alt_text"></li>
</ul>
<h2 id="元素定位工具和技巧"><a href="#元素定位工具和技巧" class="headerlink" title="元素定位工具和技巧"></a>元素定位工具和技巧</h2><ul>
<li>辅助工具<ul>
<li>Android：uiautomatorviewer/Appium Inspector</li>
<li>iOS：Appium Inspector</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ui元素定位</tag>
        <tag>UI自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化基础--微软</title>
    <url>/posts/d1646a55/</url>
    <content><![CDATA[<p><a href="https://docs.microsoft.com/en-us/dotnet/framework/ui-automation/">微软ui自动化基础</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化框架说明</title>
    <url>/posts/411091fa/</url>
    <content><![CDATA[<h1 id="UI自动化框架说明"><a href="#UI自动化框架说明" class="headerlink" title="UI自动化框架说明"></a>UI自动化框架说明</h1><pre><code>`本帖的ui自动化框架，取材于github上某个湖南老乡的框架；结构清晰，遵循PO模式，通过逻辑层-处理层-用例配置整个结构结构清晰明了；实现了处理逻辑和数据分离；有利于平台化`
</code></pre>
<p>___ 大纲 ___</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">框架的整体结构</span><br><span class="line">代码模块的结构，文件说明</span><br><span class="line">框架的执行过程</span><br><span class="line">框架优化&#x2F;改动以适应我们产品</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>___ 框架整体结构 ___<br><img src="/text_image/ui%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="alt_text"></p>
<p><code>框架整体构成由五部分构成；分别是runner(入口)/TestCase(控制层)/PageObject(逻辑层)/日志文件/yaml配置模块/报告模块 </code></p>
<p>___ runner(入口) ___</p>
<p><code>android入口程序文件：Runner/runner.py ios入口程序文件：Runner/runner.py </code><br>__ 入口程序代码review __</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#ios环境需要手动杀掉adb，杀掉win和mac上的adb</span></span><br><span class="line">    kill_adb()</span><br><span class="line">    <span class="comment">#获取imei</span></span><br><span class="line">    devicess = AndroidDebugBridge().attached_devices()</span><br><span class="line">    <span class="keyword">if</span> len(devicess) &gt; 0:</span><br><span class="line">        <span class="comment">#创建log里面的文件，先删旧文件，然后将数据写入新文件</span></span><br><span class="line">        mk_file()</span><br><span class="line">        <span class="comment">#存多设备数据，每个设备为一个字典</span></span><br><span class="line">        l_devices = []</span><br><span class="line">        <span class="keyword">for</span> dev <span class="keyword">in</span> devicess:</span><br><span class="line">            <span class="comment">#设备数据，含imei,包名，端口，备用端口，系统端口</span></span><br><span class="line">            app = &#123;&#125;</span><br><span class="line">            app[<span class="string">&quot;devices&quot;</span>] = dev</span><br><span class="line">            <span class="comment">#初始化安装应用</span></span><br><span class="line">            init(dev)</span><br><span class="line">            app[<span class="string">&quot;port&quot;</span>] = str(random.randint(4700, 4900))</span><br><span class="line">            app[<span class="string">&quot;bport&quot;</span>] = str(random.randint(4700, 4900))</span><br><span class="line">            app[<span class="string">&quot;systemPort&quot;</span>] = str(random.randint(4700, 4900))</span><br><span class="line">            app[<span class="string">&quot;app&quot;</span>] = PATH(<span class="string">&quot;../app/com.ximalaya.ting.android.apk&quot;</span>) <span class="comment"># 测试的app路径,喜马拉雅app</span></span><br><span class="line">            <span class="comment">#构造数据</span></span><br><span class="line">            l_devices.append(app)</span><br><span class="line">        <span class="comment">#启动appium服务</span></span><br><span class="line">        appium_server = AppiumServer(l_devices)</span><br><span class="line">        appium_server.start_server()</span><br><span class="line">        <span class="comment">#执行操作</span></span><br><span class="line">        runnerPool(l_devices)</span><br><span class="line">        <span class="comment">#结果怎么单独写入excel</span></span><br><span class="line">        writeExcel()</span><br><span class="line">        appium_server.stop_server(l_devices)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;没有可用的安卓设备&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>HEXO 官方使用指南</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><span id="more"></span>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>


<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>#开启动画<br>canvas_nest: true </p>
]]></content>
  </entry>
  <entry>
    <title>Python语法-unittest</title>
    <url>/posts/5b3a24b8/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unittest介绍</span><br><span class="line">unittest使用教程</span><br><span class="line">unittest中的方法说明</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h4 id="unittest介绍"><a href="#unittest介绍" class="headerlink" title="unittest介绍"></a>unittest介绍</h4><p><code>unnittest是Python中使用的单测模块，能实现对模块，类，方法的自动调用执行，断言测试，环境管理，结果输出的功能</code></p>
<p><strong>原理:</strong></p>
<p>unittest构成要素，主要由以下几部分组成:</p>
<ul>
<li>testcase:待测对象，待测对象必须要以test，类方法必须含test开头命名;</li>
<li>TestLoader类：unittest中的类，用来获取模块中的待测对象；返回待测对象的列表；</li>
<li>TestSuit：测试套件，将测试case加到套件，套件会根据加入的顺序来确认执行顺序；<ul>
<li>该类的addTest方法，可将测试对象加到套件中，但对结构有要求，必须保持addTest(测试类(具体测试方法))，这种实现方案能保证最先加入套件的最先被执行；</li>
<li>该类的另一个方法addTests,也可将测试对象加到套件中，但其对结构也有要求，必须保持addTests([测试类1(测试方法1)，测试类1（测试方法2）])</li>
<li>这种方法能保证直接将获取的对象加入测试套件，执行顺序按加入套件的顺序，一般是按test的命名顺序：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	testloader &#x3D; unittest.TestLoader()</span><br><span class="line">	# 获取测试类里面case名，以固定顺序数组返回</span><br><span class="line">	testnames &#x3D; testloader.loadTestsFromTestCase(t)</span><br><span class="line">	print(testnames)</span><br><span class="line">	suite &#x3D; unittest.TestSuite()</span><br><span class="line">	suite.addTest&#x2F;addTests(testnames)  </span><br><span class="line">	runn &#x3D; unittest.TextTestRunner(verbosity&#x3D;2)</span><br><span class="line">	runn.run(suite)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">   suite &#x3D; unittest.TestSuite()</span><br><span class="line">   suite.addTest(sui.pa(Test_ap))	#支持加入对象是一个套件，以实现二次封装</span><br><span class="line">   runn &#x3D; unittest.TextTestRunner(verbosity&#x3D;2)</span><br><span class="line">   runn.run(suite)</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>TextTestRunner()类：unittest中的类；用来执行suit，控制测试case的执行，执行生成的是text的报告；如果是需要生成htmlt报告，则使用htmltestrunner;</li>
<li>执行顺序：默认按case名称顺序来确认执行顺序，也可手动定制顺序，各suit来确定执行顺序；</li>
<li>环境/前置/后置处理：使用unittest自带的方法，setUp/setDown,setUpClass setDownClass,其中前两个每个case执行前后都会分别执行前置后置处理；后两个在套件执行前后，分别执行签字和后置处理，且仅执行一次；</li>
<li>断言：unittest提供了个钟断言方法，如下图:<br> <img src="/text_image/unitest%E6%96%AD%E8%A8%80.png" alt="alt_text"></li>
<li>跳过某些测试case：可以使用unittest的skip装饰器，其中skip装饰器主要有3种;(@unittest.skip(reason)/@unittest.skipIf(condition,reason)/@unittest.skipUnless(condition,reason)/即在满足condition条件下跳过该用例，reason用于描述跳过的原因)</li>
</ul>
<p><a href="https://blog.51cto.com/u_2681882/2123613"><strong>参考：unitest使用详解</strong></a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>unittest</tag>
        <tag>参数化</tag>
      </tags>
  </entry>
  <entry>
    <title>python-多线程</title>
    <url>/posts/b7270d4a/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">多线程是什么？</span><br><span class="line">为什么需要使用多线程，多线程的作用？</span><br><span class="line">怎么使用多线程，join方法的作用？</span><br><span class="line">python多线程弊端？</span><br><span class="line">python多线程其他机制？</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><strong>多线程是什么？</strong></li>
</ul>
<p><code>线程是程序的最小单元，程序运行时，实际是线程在解释器中执行工作；</code></p>
<ul>
<li><strong>为什么需要使用多线程，多线程的作用？</strong></li>
</ul>
<p><code>python的多线程是假的多线程，在进程中同时最多只能有一个线程在解释器中运行，这是由python的全局解释器（GIL）来控制的，具体过程为“生成gil-线程运行-线程休眠（gil上锁）-运行其他线程-再次运行此线程时（需要将上一个线程上锁，并解锁此线程）”，这种虽然是假的多线程，但是可以在一个线程等待时，运行另一个线程，使单核得到充分利用；</code></p>
<ul>
<li><strong>怎么使用多线程，join方法的作用？</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">#fun是函数，arg是参数</span><br><span class="line">t1&#x3D;threading.Thread(fun,arg)</span><br><span class="line">t1.start()</span><br><span class="line">t1.join() </span><br><span class="line">print(&quot;主线程执行&quot;)</span><br></pre></td></tr></table></figure>
<p>join方法的作用是子线程劫持主线程，仅当子线程执行完之后，才能执行主线程，常用于爬虫，如爬取多个资源时，使用多线程，每个子线程添加join等待，仅当爬虫子线程爬取完资源后，才能进行下一步操作（运行主线程）</p>
<ul>
<li><strong>python 多线程的弊端</strong></li>
</ul>
<p><code>python多线程的GIL机制，导致python同时只能执行一个线程，只能使用单核，在多核机器上会存在巨大的资源浪费；因此多线程多用于高IO操作，尽量避免在多cpu计算场景下使用，该场景下应使用多进程；</code></p>
<ul>
<li><strong>python多线程其他机制？</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python守护线程？</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>python的守护线程？</strong><br>  <code>python主线程运行时，默认会等待子线程运行结束后主线程才能结束，但我们可以在子线程启动前，将子线程添加到守护线程里，这样的话哪怕该守护子线程未结束，只要主线程结束了，守护线程也会跟着结束；   </code>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">#fun是函数，arg是参数</span><br><span class="line">t1&#x3D;threading.Thread(fun,arg)</span><br><span class="line">t1.setDaemon(True)#设置守护线程必须在该子线程执行前</span><br><span class="line">t1.start()</span><br><span class="line">t1.join() </span><br><span class="line">print(&quot;主线程执行&quot;)	#主线程结束后，子线程会跟着结束，不会执行</span><br><span class="line"></span><br><span class="line">线程的其他常用方法：</span><br><span class="line"></span><br><span class="line">run():  线程被cpu调度后自动执行线程对象的run方法</span><br><span class="line">start():启动线程活动。</span><br><span class="line">isAlive(): 返回线程是否活动的。</span><br><span class="line">getName(): 返回线程名。</span><br><span class="line">setName(): 设置线程名。</span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">threading.currentThread(): 返回当前的线程变量。</span><br><span class="line">threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span><br><span class="line">threading.activeCount():返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结：python的多线程支持多任务，但多任务并不支持并行运行（同时运行），只是利用了cpu的多道技术，支持任务的切换；</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>python-多进程</title>
    <url>/posts/a1c10886/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python多进程简述</span><br><span class="line">python多进程模块方法介绍</span><br><span class="line">python多进程使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ul>
<li><p><em><strong>python多进程模块简述：</strong></em></p>
<p>  <code>python由于GIL机制，多线程，实际仅消耗一个内核资源；因此效率较低，python要实现并发，提高性能，只能使用多进程模块，python的多进程模块为multiprocessing，通过使用Pool类实现多进程；   </code></p>
</li>
<li><p><em><strong>python多进程模块方法介绍：</strong></em></p>
<p>  <code>   python多进程模块为multiprocessing，为python的内置模块；通过该模块封装的Pool()对象实现多进程，Pool类的属性介绍如下：</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">run&#x3D;run()	#需要被执行的方法&#x2F;任务</span><br><span class="line">iter&#x3D;iter	#迭代对象，list&#x2F;变量值</span><br><span class="line"></span><br><span class="line">pool&#x3D;Pool(3)	#创建一个仅容纳3个进程的进程池，一旦工作任务超出进程的数量，则需等待，进程池中的进程被释放，任务才能进入进程池；</span><br><span class="line">__init__(self, group&#x3D;None, target&#x3D;None, name&#x3D;None, args&#x3D;(), kwargs&#x3D;&#123;&#125;)	#进程池的构造方法</span><br><span class="line">group：进程池所属的进程组，一旦不需要给值；</span><br><span class="line">target：待处理的任务或方法；</span><br><span class="line">name：进程池的别名，默认不给值；</span><br><span class="line">args：调用对象的位置参数，可给值元组&#x2F;列表等可迭代对象或者参数值；</span><br><span class="line">kwargs：调用对象的字典参数；</span><br><span class="line"></span><br><span class="line">使用：在win环境下，进程池必须在当前模块下执行，即必须在 if __name__&#x3D;&#x3D;main:下执行；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Pool()类中拥有的属性方法如下：</strong></li>
</ul>
<ul>
<li>pool.map()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数原型：map(func, iterable[, chunksize&#x3D;None])</span><br><span class="line">pool.map(run,iter)		#使用进程池中的进程来同步构造任务为run,参数为iter的对象，具体效果等同于map()方法；</span><br><span class="line">pool.close()	#通过主进程，关闭进程池，子进程任务未完成时，进程池不能接受新的子进程；</span><br><span class="line">pool.join()		$通过执行子进程，并等待所有子进程执行完，才进行下一步操作；</span><br></pre></td></tr></table></figure></li>
<li>pool.map_async(run,iter)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数原型：map_async(func, iterable[, chunksize&#x3D;None])</span><br><span class="line">pool.map_async(run,iter)		#使用进程池中的进程来同步构造任务为run,参数为iter的对象，具体效果等同于map()方法；</span><br><span class="line">pool.close()	#通过主进程，关闭进程池，子进程任务未完成时，进程池不能接受新的子进程；</span><br><span class="line">pool.join()		$通过执行子进程，并等待所有子进程执行完，才进行下一步操作；</span><br><span class="line">---效果和pool.map()不相同，mapasyc效率更高；mapasyc主进程未阻塞进程池，不需要等该批次的进程全执行完，新的任务就能进入进程池执行；常用pool.map()</span><br></pre></td></tr></table></figure></li>
<li>pool.apply()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数原型：apply(func[, args&#x3D;()[, kwds&#x3D;&#123;&#125;]])</span><br><span class="line">apply,参数需要为具体的变量值，且仅在python2支持；</span><br><span class="line">apply方法的原理是，阻塞进程池，一次仅让一个任务进入进程池，该任务完成后，才能执行下一个任务，实际是串行；</span><br></pre></td></tr></table></figure></li>
<li>pool.applyasyc()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   函数原型：apply(func[, args&#x3D;()[, kwds&#x3D;&#123;&#125;]],[, callback&#x3D;None]]])</span><br><span class="line">   applyasyc,参数需要为具体的变量值，在python3上支持；</span><br><span class="line">   applyasyc方法的原理是，进程池非阻塞，一次可以让多个任务进入进程池，且未对该批次任务进行阻塞，只要其中一个进程执行完后，就能释放资源，让新的任务进入进程池，实际是并行的,效率等同于mapasyc()；</span><br><span class="line">回调使用：pool.applyasyc(run,kwargs,callback&#x3D;func2)，run的返回作为func2的参数，执行完返回func2的值；</span><br><span class="line">   ---applyasyc效果等同于mapasyc()，只是他具有回调功能，且入参的变量不能是可迭代对象，必须为具体的变量值；</span><br></pre></td></tr></table></figure></li>
<li>pool.terminal()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：结束工作进程，不在处理未完成的任务</span><br><span class="line">pool.map(run,iter)</span><br><span class="line">pool.close()</span><br><span class="line">pool.run()</span><br><span class="line">sleep(2)</span><br><span class="line">pool.terminal()		#执行两秒后，哪怕进程未执行完，也结束该主进程</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><em><strong>python多进程使用：</strong></em></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">run&#x3D;run()</span><br><span class="line">iter&#x3D;iter</span><br><span class="line"></span><br><span class="line">pool&#x3D;Pool(multiprocessing.cpu_count())</span><br><span class="line">pool.map(run(),iter)</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>python-协程</title>
    <url>/posts/62a5b225/</url>
    <content><![CDATA[<p><code>python的协程，是一种协作（异步）工作方式；类似于多线程，但不是多线程，实际是在一个线程中工作；工作过程实际是利用协程模块（标准库asyncio），构建协程对象；当协程对象执行时，其中可以构造专属的等待方法，处于等待时，会调度其他的协程对象执行，当等待时间过后，又会恢复到原来的协程对象上来工作，类似于多线程的上下文切换，可以在使用维度上理解成微线程，特性如下：</code></p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">协程是单线程异步的工作方式；能避免无意义的多线程切换；没有多线程的开销，因此能提升性能；</span><br><span class="line">协程，没有多线程的锁机制，在一个线程中切换，因此效率会更高（性能）；</span><br><span class="line">协程不是多线程，不能利用cpu多核能力，不能实现并行，能实现并发；</span><br><span class="line">必须自己来承担调度的责任（控制调度）；</span><br></pre></td></tr></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def say_hello():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    await asyncio.gather(say_hello(),say_hello(),say_hello())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line">:&gt;Hello</span><br><span class="line">:&gt;Hello</span><br><span class="line">:&gt;Hello</span><br><span class="line">//休眠1s</span><br><span class="line">:&gt;World</span><br><span class="line">:&gt;World</span><br><span class="line">:&gt;World</span><br></pre></td></tr></table></figure>
<p><strong>第三方协程框架gevent</strong><br><code>它封装了libevent事件循环的API，因此能自动切换io操作；但是语法上好像不够清晰，写起来像是同步操作</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def say_hello():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="comment">#如需阻断，可使用gevent.sleep()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line">g1=gevent.spawn(say_hello)</span><br><span class="line">g2=gevent.spawn(say_hello)</span><br><span class="line">g3=gevent.spawn(say_hello)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br><span class="line"></span><br><span class="line">:&gt;Hello</span><br><span class="line">:&gt;World</span><br><span class="line">:&gt;Hello</span><br><span class="line">:&gt;World</span><br><span class="line">:&gt;Hello</span><br><span class="line">:&gt;World</span><br><span class="line"></span><br><span class="line">如需阻断，请查看备注代码</span><br></pre></td></tr></table></figure>
<p><strong>使用场景：</strong><br><code>协程主要是为了允许在单线程中对 IO 密集的过程进行调度，它允许我们显式指定一个位置，程序可以从此处被挂起，转而执行其他任务，当 IO 结束时被调度，从当前位置返回然后处理结果。</code></p>
<p><strong>总结：协程相对于多线程有明显的性能优势，因此在处理IO密集型操作时，一般使用协程而非多线程；但由于不能利用cpu多核，因此在处理计算密集型场景时，还是要优先考虑多进程/多进程+协程</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>python文档管理</title>
    <url>/posts/2020cd00/</url>
    <content><![CDATA[<h1 id="python文档说明"><a href="#python文档说明" class="headerlink" title="python文档说明"></a>python文档说明</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文档管理的作用</span><br><span class="line">文档管理模块pydoc介绍</span><br><span class="line">怎么使用文档管理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ul>
<li><p><strong>文档管理的作用</strong></p>
<p>  <code>  通过在模块/类/函数中进行规范化注释，可以有效的说明模块/类/函数的功能；清晰的体现程序的结构；  </code></p>
</li>
<li><p><strong>文档管理模块pydoc.py</strong>  </p>
<p>  <code>  文档管理模块pydoc，是python内置的一个文档管理模块。它可以实现在线实时/离线查看。模块/类/函数（内置/第三方/自有均支持）中的注释信息，同时可以将规范的注释信息生成html文件进行查看；  </code></p>
</li>
<li><p><strong>怎么实现</strong> </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模块中注释的规范</span><br><span class="line">文档管理模块实时查看</span><br><span class="line">文档管理模块生成html文件查看</span><br></pre></td></tr></table></figure>

<ul>
<li><em>模块中注释的规范</em></li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   e.g</span><br><span class="line">   # -*- coding: utf-8 -*-</span><br><span class="line">   </span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">   @author jw</span><br><span class="line">   @desc 本模块是一个测试文件，用来说明pydoc的读取内容</span><br><span class="line">   @date 2017&#x2F;4&#x2F;13</span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">   </span><br><span class="line">   #测试变量</span><br><span class="line">   data&#x3D;1</span><br><span class="line">   </span><br><span class="line">   class Test():</span><br><span class="line">       &quot;&quot;&quot;</span><br><span class="line">       测试类</span><br><span class="line">       &quot;&quot;&quot;</span><br><span class="line">   </span><br><span class="line">       def test_c(s):</span><br><span class="line">           &quot;&quot;&quot;</span><br><span class="line">           测试函数</span><br><span class="line">           &quot;&quot;&quot;</span><br><span class="line">           pass</span><br><span class="line">   </span><br><span class="line">   def test():</span><br><span class="line">       &quot;&quot;&quot;</span><br><span class="line">       测试函数</span><br><span class="line">       &quot;&quot;&quot;</span><br><span class="line">       pass</span><br><span class="line">       </span><br><span class="line">以上就是相对标准的注释规范，注释一般由三部分构成模块的注释，类的注释，函数的注释；以上注释在编译后，可使用pydoc进行查看，如下图，第一个区域是顶部注释；第二个区域是类注释，其中会包含类函数，第三个区域是模块函数注释；最后为模块定义的变量；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>_查看效果如下_：</li>
</ul>
<p>  <img src="/text_image/pydoc.jpg" alt="alt_text"></p>
<ul>
<li><em>实时查看模块说明文档</em></li>
</ul>
<p>  实时查看可使用pydoc的help方法，注意非内置模块，使用前，需要先导入模块</p>
<p>  <img src="/text_image/help.png" alt="alt_text"></p>
<ul>
<li><em>离线生成html查看模块文档</em></li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生成全局html文档命令：python  -m pydoc -p *** #在通过loaclhost:****的方式访问查看</span><br><span class="line">查看特定的对象 python -m pydoc -w test&#x2F;test.Test #生成特定对象的html文件</span><br><span class="line">查找特定对象的文档 python -m pydoc -k test</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>PS:    上方的&quot;&quot;&quot;注释&quot;&quot;&quot;称为文档字符串，可通过对象的__doc__方法来进行查看，如Test.__doc__;</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>说明文档</tag>
      </tags>
  </entry>
  <entry>
    <title>python语法-super方法</title>
    <url>/posts/7b2ded6/</url>
    <content><![CDATA[<p><code>super方法用来，继承父类，或祖父类；常用的结构为super(C,self)/python3括号内的可缩写（super()）;super方法本身是一个类，和当前所在的类（父类）无关，该类使用了mro的算法（方法查找顺序）来决定继承类的顺序</code></p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class A():</span><br><span class="line"></span><br><span class="line">	def __init__(self):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;---A---&quot;</span>)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---B---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(super.__mro__)</span><br><span class="line">        super(B,self).__init__()</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---C---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(super.__mro__)</span><br><span class="line">        super(C,self).__init__()</span><br><span class="line"></span><br><span class="line">class D(B,C):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---D---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(super.__mro__)</span><br><span class="line">        super().__init__()</span><br><span class="line">D()</span><br></pre></td></tr></table></figure>
<p><strong>方法查找顺序说明:</strong></p>
<pre><code>super.mro策略；采用的是查找继承类的上一个节点的方式来实现继承，如super(D,self).__init__();实际上继承的是上一个节点类B；Python2和Python3使用super来继承时，使用上存在差异，Python必须使用super(C,self)方式继承，python3则可同时使用super()和super(C,self)来进行继承；同时Python2存在class A:/class A(object):这两种经典类和新式类；Python3只有新式类；经典类和新式类的mro策略不一样，虽然两者都是使用从左到右的广度遍历，经典类在某类已继承时，后续在查找到这个类，也不在继承；新式类，在某类已经继承时，后续在查找到改类，会继承最新查找到的；
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>python语法特性</title>
    <url>/posts/d641bafc/</url>
    <content><![CDATA[<h1 id="python语法特性"><a href="#python语法特性" class="headerlink" title="python语法特性"></a>python语法特性</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">return</span> a or b:遇到为<span class="literal">true</span>的值即返回该值，如果均为<span class="literal">false</span>,即返回最后一个</span><br><span class="line"><span class="built_in">return</span> a and b:遇到为<span class="literal">false</span>的值，即返回该值，如果均为<span class="literal">true</span>就返回最后一个</span><br><span class="line">如果函数无<span class="built_in">return</span>,则该函数返回None对象</span><br><span class="line">生成器比用迭代器实现块的多，因为生成器底层是通过c编写的</span><br><span class="line">[line.upper() <span class="keyword">for</span> line <span class="keyword">in</span> open(text.txt) <span class="keyword">if</span> line[0]==1]</span><br><span class="line">[filter(f(i),list)]	<span class="comment">#生成器，返回由list中元素在f(i)中执行满足条件的元素构成的list</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ui自动化分布式并行运算</title>
    <url>/posts/2be91958/</url>
    <content><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1974105">Gird</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>gird</tag>
      </tags>
  </entry>
  <entry>
    <title>uwnc</title>
    <url>/posts/3de87ac/</url>
    <content><![CDATA[<p><a href="https://test.boomplay.com/TestUWNC/?bp_wvt=1&amp;bp_noc=1#/test-uwnc">https://test.boomplay.com/TestUWNC/?bp_wvt=1&amp;bp_noc=1#/test-uwnc</a></p>
]]></content>
  </entry>
  <entry>
    <title>专项--音视频质量评测</title>
    <url>/posts/907af9b9/</url>
    <content><![CDATA[<p><code>音视频评测，主要涉及到编解码，网络传输，原生资源的前后置处理；传输流程如下：</code><br><img src="/text_image/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B.png" alt="alt text"></p>
<span id="more"></span>

<h1 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h1><ul>
<li>先确定音频的质量评测维度（由于是流媒体，网络是决定因素，因此需要覆盖不同网络下的这些指标）：<ul>
<li>性能、码率、抗性、时延、音质、响度、连麦通话、音效：（由 SDK 服务保障并提供技术指标）</li>
<li>卡顿（流畅度）：手机终端测试，通过卡顿率来评估，为卡顿率 = sum (&gt;200ms 卡顿时间) / 通话时间；<ul>
<li>流畅度评估原理（安卓）：通过获取 gfxinfo 中的帧信息，统计帧耗时和卡顿率</li>
</ul>
</li>
<li>除以上的常规维度外，还有音频专属的：绝对等级评分(MOS)、失真等级评分(DCR)、相对等级评分（CCR）等维度;通过以下算法评估：<ul>
<li>python-pesq（PESQ）</li>
<li>分段信噪比（SegSNR）</li>
<li>对数似然比测度（LLR）</li>
<li>对数谱距离（LSD）</li>
<li>可短时客观可懂（STOI）</li>
<li>加权谱倾斜测度（WSS）</li>
<li>感知客观语音质量评估（POLQA）</li>
</ul>
</li>
</ul>
</li>
<li>然后确定合规的质量标准</li>
<li>分析评测数据，对比质量标准，得出评测结果<br><code>ps:音频的格式分为有损格式、无损格式、私有格式，部分有损格式如下：wav、MP3、oog、aac、ac3；原始文件格式为pcm</code></li>
</ul>
<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><ul>
<li><p>先确定音频的质量评测维度（由于是流媒体，网络是决定因素，因此需要覆盖不同网络下的这些指标:）</p>
<ul>
<li>性能、码率、抗性、时延、音画同步：（由 SDK 服务保障并提供技术指标）</li>
<li>卡顿（流畅度）：手机终端测试，通过卡顿率来评估，为卡顿率 = sum (&gt;200ms 卡顿时间) / 通话时间；<ul>
<li>流畅度评估原理（安卓）：通过获取 gfxinfo 中的帧信息，统计帧耗时和卡顿率</li>
</ul>
</li>
<li>视频质量：分为主观评测(人工)和客观评测,通过开源算法进行评估；<ul>
<li>主观评测：依赖人眼观看并打分</li>
<li>客观评测：客观评测算法，主要分为全参考、无参考、部分参考算法，参考的是源资源，算法如下<ul>
<li>PLCC指标：Pearson 线性相关系数，代表模型的线性相关性。</li>
<li>SROCC指标：Spearman 秩序相关系数，用来衡量秩序的相关性的，代表模型的非线性相关性。假设有两组序列 X 和 Y，其秩序为 R(X)和 R(Y)，则 SROCC(X, Y) = PLCC(R(X), R(Y))。</li>
<li>全参考算法：netflix VMAF、腾讯的DVQA</li>
<li>netflix VMAF测试的指标：视觉信息逼真度(VIF)+视觉信息逼真度(VIF)+Motion</li>
<li>DVQA:<a href="https://github.com/Tencent/DVQA">https://github.com/Tencent/DVQA</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>然后确定合规的质量标准</p>
</li>
<li><p>分析评测数据，对比质量标准，得出评测结果<br><code>MP4、FLV（在线视频格式）、AVI、MOV、ASF、WMV、RM、RMVB等</code></p>
</li>
<li><p><strong>音视频评测辅助评测和定位问题使用的工具:</strong></p>
<ul>
<li>弱网测试工具：QNET</li>
<li>弱网测试工具：network emulator，微软开源，可实现带宽、丢包、延时、抖动、综合网络等弱网参数的限制。</li>
<li>音视频处理工具 FFmpeg：统计码率、</li>
</ul>
</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/KNJF2562R4cLCaMSxfsRLg">参考文章</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>专项</tag>
        <tag>音视频专项</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生-K8S</title>
    <url>/posts/b6242283/</url>
    <content><![CDATA[<p><code>k8s是指kubernetes；是一种容器编排系统；其中最核心的组件是docker（就是自动运维管理docker的集群），整个系统都是围绕容器，对其进行管理，扩展，部署；有以下特性：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">容器编排，实现容器的自动部署，调度和协调。</span><br><span class="line">弹性伸缩，根据负载和资源动态调整容器的数量和位置。</span><br><span class="line">服务发现，提供服务注册和发现机制，实现容器间的通信和负载均衡。</span><br><span class="line">部署管理，支持多种部署策略，如滚动更新，回滚等。</span><br><span class="line">开源和易于拓展，支持多种云平台和操作系统，具有丰富的生态系统和社区。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>由两部分组成，master和node,架构如下：</strong><br><img src="/text_image/k8s.jpg" alt="alt text"></p>
<p><strong>工作原理</strong><br><img src="/text_image/k8s%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="alt text"></p>
<p><strong>注意点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主节点和从节点，一般分别独立部署在不同服务器上，共同构成了k8s集群，集群可以有多个主从节点；</span><br><span class="line">主节点部署master组件，从节点部署node组件；</span><br><span class="line">K8S 的 Master Node 具备：请求入口管理（API Server），Worker Node 调度（Scheduler），监控和自动调节（Controller Manager），以及存储功能（etcd）；而 K8S 的 Worker Node 具备：状态和监控收集（Kubelet），网络和负载均衡（Kube-Proxy）、保障容器化运行环境（Container Runtime）、以及定制化功能（Add-Ons）；</span><br></pre></td></tr></table></figure>
<p><strong>K8S 的重要概念有 Deployment、Pod、Replica Set、Service 等</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod(仓)是服务的闭包&#x2F;集合，可以被理解成一群可以共享网络、存储和计算资源的容器化服务的集合；一个里面可以有多个docker服务；</span><br><span class="line">Deployment调度这些副本来替换 的作用是管理和控制 Pod 和 ReplicaSet，管控它们运行在用户期望的状态中。提供更新能力；</span><br><span class="line">ReplicaSet 的作用就是管理和控制 Pod，维护了pod的很多副本，当pod不可用的时候，就Deployment调度这些副本来替换；</span><br><span class="line">用户会直接操作 Deployment 部署服务，而当 Deployment 被部署的时候，K8S 会自动生成要求的 ReplicaSet 和 Pod。</span><br><span class="line">Service 就是微服务，有备份机制的，可以做流量负载均衡</span><br><span class="line">Ingress 用来在集群外部访问集群内部服务；提供负载均衡、SSL 终结和基于名称的虚拟托管；</span><br><span class="line">Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群。这些虚拟集群被称为名字空间。</span><br></pre></td></tr></table></figure>
<p><strong>k8s要素关系</strong><br><img src="/text_image/k8s%E8%A6%81%E7%B4%A0.png" alt="alt text"><br><strong>ingress集群内外通信拓扑图</strong><br><img src="/text_image/ingress%E9%9B%86%E7%BE%A4%E5%86%85%E5%A4%96%E9%80%9A%E4%BF%A1%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="alt text"></p>
<h1 id="k8s使用："><a href="#k8s使用：" class="headerlink" title="k8s使用："></a>k8s使用：</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>命令结构：kubectl [command] [TYPE] [NAME] [flags]</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl:k8s命令行工具；</span><br><span class="line">command：对指定对象要执行的操作；</span><br><span class="line">TYPE：对操作对象&#x2F;资源类型</span><br><span class="line">NAME：资源&#x2F;对象的名称，可省略；</span><br><span class="line">- &#96;flags&#96;: 指定可选的参数;如-s&#x2F;-server，指定服务；</span><br><span class="line">实例：</span><br><span class="line">&#96;kubectl get pods&#96;		&#x2F;&#x2F;查看所有的pods</span><br></pre></td></tr></table></figure>

<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><ul>
<li><strong>如何部署pod</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">准备 Pod 的 yaml 配置文件；</span><br><span class="line">执行 kubectl 命令部署：kubectl create -f <span class="variable">$&#123;POD_YAML文件&#125;</span>；</span><br></pre></td></tr></table></figure></li>
<li><strong>如何部署Deployment</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">准备 Deployment 的 yaml 配置文件；</span><br><span class="line">执行 kubectl 命令部署：kubectl create -f <span class="variable">$&#123;DEPLOYMENT_YAML文件&#125;</span>；</span><br><span class="line">部署完以上两个对象后，就会自动的创建ReplicaSet 和pod,查看其的命令：get rs、get pod</span><br></pre></td></tr></table></figure></li>
<li><strong>如何对服务操作</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">删</span><br><span class="line">删除资源：kubectl delete <span class="variable">$&#123;RESOURCE&#125;</span> <span class="variable">$&#123;NAME&#125;</span>		//<span class="variable">$&#123;RESOURCE&#125;</span>资源类型如pod/rs <span class="variable">$&#123;NAME&#125;</span>资源名</span><br><span class="line">删除pod：kubectl delete pod memory-demo</span><br><span class="line">删除deployment：kubectl delete deployment <span class="variable">$&#123;DEPLOYMENT_NAME&#125;</span>	//通过删除deployment来删除服务时，需要先删除deployment，然后还要在删除pod；见上方的调度结构；</span><br><span class="line">强制删除：kubectl delete pod --force --grace-period=0 <span class="variable">$&#123;POD_NAME&#125;</span></span><br><span class="line"></span><br><span class="line">改：两种方式</span><br><span class="line">改配置文件，然后重新创建：kubectl create -f <span class="variable">$&#123;YAML文件&#125;</span></span><br><span class="line">直接改：kubectl edit <span class="variable">$&#123;RESOURCE&#125;</span> <span class="variable">$&#123;NAME&#125;</span>如kubectl edit pod memory-demo</span><br><span class="line"></span><br><span class="line">查</span><br><span class="line">查看服务：$ kubectl get|describe <span class="variable">$&#123;RESOURCE&#125;</span> [-o <span class="variable">$&#123;FORMAT&#125;</span>] -n=<span class="variable">$&#123;NAMESPACE&#125;</span>		//<span class="comment"># $&#123;RESOURCE&#125;有: pod、deployment、replicaset(rs)</span></span><br><span class="line">查看服务前，必须要知道命名空间，查看命令空间：kubectl get ns；</span><br><span class="line">查看特定命令空间的deployment:kubectl get deployment -n=oona-test；</span><br><span class="line">查看特定命令空间的pod:kubectl get pod -n=oona-test；</span><br><span class="line">查看特定命令空间的rs:kubectl get rs -n=oona-test；</span><br><span class="line">获取所有命令空间的资源：kubectl get deployment/replicaset/pod --all-namespaces</span><br><span class="line">命令加[-o wide]，显示新学期更全，建议加：kubectl get deployment/replicaset/pod [-o wide] --all-namespaces</span><br><span class="line"></span><br><span class="line">查看资源信息（部署是否成功等）：kubectl describe <span class="variable">$&#123;RESOURCE&#125;</span> <span class="variable">$&#123;NAME&#125;</span></span><br><span class="line">查看舱内的服务日志：kubectl <span class="built_in">log</span> <span class="variable">$&#123;POD_NAME&#125;</span> -c <span class="variable">$&#123;CONTAINER_NAME&#125;</span>。</span><br><span class="line">进入 Pod 内部某个 container：kubectl <span class="built_in">exec</span> -it [options] <span class="variable">$&#123;POD_NAME&#125;</span> -c <span class="variable">$&#123;CONTAINER_NAME&#125;</span> [args]		//实际调用了docker容器的docker <span class="built_in">exec</span> xx进入容器内部</span><br></pre></td></tr></table></figure></li>
<li><strong>docker常用命令：分为镜像管理/容器管理</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">容器运行命令参数</span><br><span class="line"></span><br><span class="line">1. --name 指定容器名称</span><br><span class="line">2. -d 后台运行</span><br><span class="line">3. -port 指定端口映射规则</span><br><span class="line">4. --network 指定容器运行的网路模式</span><br><span class="line">5. -v 指定需要挂载的数据卷</span><br><span class="line">6. -env  指定需要传递给容器的环境变量</span><br><span class="line"></span><br><span class="line">增</span><br><span class="line">下载镜像：docker pull busybox</span><br><span class="line">导出镜像：docker save busybox &gt; busybox.tar</span><br><span class="line">导入镜像：docker load &lt; busybox.tar</span><br><span class="line">push镜像到镜像仓库：docker push</span><br><span class="line"></span><br><span class="line">删</span><br><span class="line">删除镜像：docker rmi busybox:版本</span><br><span class="line"></span><br><span class="line">改</span><br><span class="line">改镜像名：docker tag busybox:latest busybox:<span class="built_in">test</span></span><br><span class="line">给镜像加tag:docker tag jenkins:latest jenkins:3.6.0</span><br><span class="line"></span><br><span class="line">查</span><br><span class="line">查看docker版本：docker version</span><br><span class="line">查看镜像：docker images</span><br><span class="line"></span><br><span class="line">容器：</span><br><span class="line">运行容器：docker run（运行） -d（后台方式） --name=busybox busybox:latest ping 114.114.114.114</span><br><span class="line">查看运行容器：docker ps</span><br><span class="line">查看所有容器：docker ps -a</span><br><span class="line">重新启动容器：docker restart busybox</span><br><span class="line">停止容器：docker stop busybox</span><br><span class="line">杀死容器：docker <span class="built_in">kill</span> busybox</span><br><span class="line">删除运行容器：docker rm -f busybox</span><br><span class="line">进入容器内：docker <span class="built_in">exec</span> -it busybox</span><br><span class="line">复制容器内文件：docker cp busybox:/etc/hosts hosts</span><br><span class="line">查看容器日志：docker logs -f busybox</span><br></pre></td></tr></table></figure></li>
<li><strong>服务部署失败了怎么办？</strong><br>见k8s入门-简单好理解版本</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/4l0g2VI_18EuOjaYQuHYHw">k8s入门-思路清晰</a><br><a href="https://mp.weixin.qq.com/s/mUF0AEncu3T2yDqKyt-0Ow">k8s入门-简单好理解版本</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>K8S</tag>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀博客</title>
    <url>/posts/bb158cde/</url>
    <content><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1974105">自动化专家</a></li>
<li><a href="https://cloud.tencent.com/developer/user/3335805/activities">性能</a></li>
<li><a href="https://cloud.tencent.com/developer/user/1011618/activities">腾讯性能优化</a></li>
<li><a href="https://cloud.tencent.com/developer/user/1016462">腾讯测开</a></li>
<li><a href="https://cloud.tencent.com/developer/user/2059614">测开</a></li>
</ul>
<span id="more"></span>

<h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><ul>
<li><a href="https://cloud.tencent.com/developer/user/2398817/inventories">python</a></li>
<li><a href="https://www.cnblogs.com/vamei/tag/Python/">行业大佬python教程</a></li>
</ul>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li><a href="https://cloud.tencent.com/developer/user/1642192">K8S腾讯专家</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>职业--传易工作总结</title>
    <url>/posts/c184c696/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>2020/9月入职传易，2023/6月离职，近三年的工作回顾；含工作内容，职场</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工作</span><br><span class="line">职场</span><br><span class="line">总结&#x2F;反思</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><strong>前后工作内容经历了，音乐服务端测试/大数据侧功能测试/广告业务测试/自动化体系建设</strong></p>
<h3 id="测试能力建设"><a href="#测试能力建设" class="headerlink" title="测试能力建设"></a>测试能力建设</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">测试自动化</span><br><span class="line">服务性能测试</span><br><span class="line">客户端性能测试</span><br><span class="line">客户端稳定性</span><br><span class="line">CD能力建设</span><br></pre></td></tr></table></figure>
<h4 id="测试自动化"><a href="#测试自动化" class="headerlink" title="测试自动化"></a>测试自动化</h4><p><code>自动化能力，按我的理解应该属于研发CD体系中的重要一环，核心是提效/保障质量；但实现目标不仅仅需要自动化能力，云，研发体系，产品交互体系，线上质量保障体系，都是为了最终目标服务的</code></p>
<h5 id="单元自动化–代码审查"><a href="#单元自动化–代码审查" class="headerlink" title="单元自动化–代码审查"></a>单元自动化–代码审查</h5><p><code>代码质量保障，主要由开发负责，主要是引入代码检查框架，在编码/合并时暴露问题，以及在代码进行部署时，通过Jenkins调度审查策略实现代码覆盖</code><br><strong>实现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开发团队通过Junit各自负责单测代码</span><br><span class="line">开发团队，针对新/大模块，核心代码，邀请运维，技术负责人，相关测试进行代码审查</span><br><span class="line">针对，代码合并，发布有严格的审核机制，和自审查机制</span><br></pre></td></tr></table></figure>
<h5 id="集成自动化–接口测试"><a href="#集成自动化–接口测试" class="headerlink" title="集成自动化–接口测试"></a>集成自动化–接口测试</h5><p><img src="/text_image/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96.png" alt="alt text"><br><strong>优缺点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">实现/维护成本低</span><br><span class="line">定制化程度低</span><br><span class="line">无法对问题溯源，无法定位问题</span><br><span class="line">总结：在运维有使用普罗米修斯对接口做监控的情况下，仅对回归测试有效果，意义不大</span><br></pre></td></tr></table></figure>
<h5 id="系统自动化–UI自动化"><a href="#系统自动化–UI自动化" class="headerlink" title="系统自动化–UI自动化"></a>系统自动化–UI自动化</h5><p><code>UI层级的自动化，是典型的功能自动化；核心点在于页面操作，页面元素的检查；难点在于稳定性和灵活性；常见的应用场景有功能回归，ui遍历，暴力操作</code></p>
<h6 id="ui自动化"><a href="#ui自动化" class="headerlink" title="ui自动化"></a>ui自动化</h6><p><img src="/text_image/ui%E6%9E%B6%E6%9E%84.png" alt="alt text"><br><img src="/text_image/UI%E8%87%AA%E5%8A%A8%E5%8C%96.png" alt="alt text"></p>
<h6 id="ui录制回放"><a href="#ui录制回放" class="headerlink" title="ui录制回放"></a>ui录制回放</h6><p><code>录制回放的核心点，在于怎么将录制信息转换成用例，已及回放时的用例反序列化操作</code><br><strong>优缺点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">优点是，可维护，可定制化</span><br><span class="line">现行脚本缺点是，稳定性较差；维护成本高，实用性差，代码耦合度高，可扩展性差</span><br></pre></td></tr></table></figure>

<h4 id="服务性能测试"><a href="#服务性能测试" class="headerlink" title="服务性能测试"></a>服务性能测试</h4><p><code>压测的依据是模拟线上的（极端）环境施压，以求将问题暴露出来；操作上基于对业务和架构的了解，试探性加压，到达瓶颈点之后，结合资源消耗，压力变化，处理能力等分析瓶颈点，并针对瓶颈进行验证，对优化后结果进行校验</code><br><strong><a href="https://docs.qq.com/s/EV0o-FmljRU-VIBxtTWYCW">压测报告合集</a></strong><br><strong>优缺点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通过Jenkins调度jmeter加压，可对每次的结果进行维护/推送，灵活方便，也可以进行持续集成</span><br><span class="line">缺点也很多，首先需要结合其他的监控，比如skywalking/普罗米修斯，查看结果及维护不方便</span><br><span class="line">其次需要专门的性能环境，成本极高</span><br><span class="line">由于事先不清楚瓶颈点，需要一点点加压，试探性的去找瓶颈，效率较低</span><br></pre></td></tr></table></figure>
<h4 id="客户端性能测试"><a href="#客户端性能测试" class="headerlink" title="客户端性能测试"></a>客户端性能测试</h4><p><code>客户端性能测试，和服务端理念上是相同的，都是模拟线上操作来进行施压，以求问题前置暴露；区别在，施压方式，监控指标上</code><br><strong>难点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">模拟线上操作较难，我前期是通过性能狗实现的，性能狗收费后，通过solopi来操作</span><br><span class="line">监控数据采集难度不小，由于客户端不像服务端，存在skywalking，这类注入式全生命周期的监控工具，在监控数据采集上，仅能基于adb命令或者开源工具提供的能力，采集的成本较高，尤其是像耗时</span><br><span class="line">分析/定位问题的成本较高，内存、cpu问题，需要查看堆栈，且都需要dump数据，dump数据分析的难度也较大，尤其是在无应用错误抛出时，分析定位问题，极其的依赖经验，成本很高</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><a href="https://www.bujiaban.xyz/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/">客户端性能合集</a></strong></li>
</ul>
<h4 id="客户端稳定性"><a href="#客户端稳定性" class="headerlink" title="客户端稳定性"></a>客户端稳定性</h4><p><code>稳定性，是性能的子类；因为一般在极端场景下，稳定性问题才能暴露，稳定性问题常见的有crash/anr/内存泄露/oom等</code><br><strong>核心</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">异常场景的挖掘是核心，这块需要在整个产品的生命周期入手；我现在的思路，主要是依赖传音的成熟能力（标准）设计覆盖场景，同时基于功能体验，项目组同事反馈，线上反馈，分析可能存在问题的点，来设计覆盖场景</span><br><span class="line">操作上，主要通过定制monkey,ui遍历，暴力回放等实现覆盖</span><br><span class="line">实施工具，主要是monkey,solopi,字节的fastbot,各有利弊，总的来说，monkey是最灵活，且成本最低</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><a href="https://www.bujiaban.xyz/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/">客户端性能合集</a></strong></li>
</ul>
<h4 id="CI-CD能力建设"><a href="#CI-CD能力建设" class="headerlink" title="CI/CD能力建设"></a>CI/CD能力建设</h4><p><code>持续集成/持续交互/持续部署；一体化的研发体系需要依赖众多的外部能力，这快主要由研发和运维实现；核心组件有，Jenkins，服务中间件，云原生及K8S，gitlab，监控能力（skywalking/普罗米修斯/zabbix）</code></p>
<h4 id="质量体系建设"><a href="#质量体系建设" class="headerlink" title="质量体系建设"></a>质量体系建设</h4><p><code>高效的质量体系，必然是高产出，能全面覆盖产品生命周期的，且有效率的；这不是一个平台或者一个脚本就能实现的；需要深入研发体系中，结合公司情况，输出符合实际的测试能力</code><br><strong>核心</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">需要有话语权，有能力推动体系前进；能获取资源，能取得其他部门的信任和合作</span><br><span class="line">自动化能力是有效的，有产出，有回报的，这要求这块的建设是要符合项目需求，可持续迭代的</span><br><span class="line">针对核心问题需要有回溯机制，针对问题或者能力需要能深化总结成组内标准，如果不能形成标准，就不可复用和推广，则意义不大</span><br><span class="line">测试能力需要能集成进研发体系中，因为测试本质还是为研发体系服务的，如果不能集成，则产出有限</span><br></pre></td></tr></table></figure>

<h3 id="广告业务测试"><a href="#广告业务测试" class="headerlink" title="广告业务测试"></a>广告业务测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">boomplay客户端广告</span><br><span class="line">boomplay web广告</span><br><span class="line">sdk广告</span><br><span class="line">web js广告</span><br><span class="line">自营广告</span><br><span class="line">聚合广告</span><br><span class="line">谷歌定制广告</span><br><span class="line">程序化广告</span><br><span class="line">广告归因</span><br></pre></td></tr></table></figure>
<p><strong><a href="https://www.processon.com/view/link/645a0dddfb0ea17d3a90b724">广告业务架构</a></strong><br><strong>广告推荐架构</strong><br><img src="/text_image/ad%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.png" alt="alt text"></p>
<h3 id="音乐大数据能力测试"><a href="#音乐大数据能力测试" class="headerlink" title="音乐大数据能力测试"></a>音乐大数据能力测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">版权音乐资源同步</span><br><span class="line">埋点数据ETL（kafka/flink）</span><br><span class="line">数据报表</span><br><span class="line">音乐推荐</span><br><span class="line">广告推荐</span><br><span class="line">标签系统</span><br></pre></td></tr></table></figure>
<h4 id="音乐资源同步"><a href="#音乐资源同步" class="headerlink" title="音乐资源同步"></a>音乐资源同步</h4><h4 id="埋点数据ETL"><a href="#埋点数据ETL" class="headerlink" title="埋点数据ETL"></a>埋点数据ETL</h4><h4 id="数据报表"><a href="#数据报表" class="headerlink" title="数据报表"></a>数据报表</h4><h4 id="音乐推荐"><a href="#音乐推荐" class="headerlink" title="音乐推荐"></a>音乐推荐</h4><h4 id="广告推荐"><a href="#广告推荐" class="headerlink" title="广告推荐"></a>广告推荐</h4><h4 id="标签系统"><a href="#标签系统" class="headerlink" title="标签系统"></a>标签系统</h4><p><strong>大数据架构</strong><br><img src="/text_image/biddate.png" alt="alt text"><br><strong>数仓架构</strong><br><img src="/text_image/bigdate_%E6%95%B0%E4%BB%93%E6%9E%B6%E6%9E%84.png" alt="alt text"><br><strong>数据架构</strong><br><img src="/text_image/bigdata_%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84.png" alt="alt text"></p>
<ul>
<li><strong>横向数据分层</strong><br><img src="/text_image/%E6%A8%AA%E5%90%91%E6%95%B0%E6%8D%AE%E5%88%86%E5%B1%82.png" alt="alt text"></li>
<li><strong>纵向数据分层</strong><br><img src="/text_image/%E7%BA%B5%E5%90%91%E6%95%B0%E6%8D%AE%E5%88%86%E5%B1%82.png" alt="alt text"><br><strong>推荐系统</strong><br><img src="/text_image/boomplay_biddate%E6%8E%A8%E8%8D%90.png" alt="alt text"></li>
</ul>
<h3 id="音乐服务端功能测试"><a href="#音乐服务端功能测试" class="headerlink" title="音乐服务端功能测试"></a>音乐服务端功能测试</h3><p><strong>C端服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1️⃣网关服务</span><br><span class="line">2️⃣首页内容服务</span><br><span class="line">3️⃣推荐服务</span><br><span class="line">4️⃣内容基础服务</span><br><span class="line">5️⃣计数服务</span><br><span class="line">6️⃣埋点服务（通用异步）</span><br><span class="line">⑦播客服务</span><br><span class="line">8️⃣账户服务</span><br><span class="line">9️⃣订阅服务</span><br><span class="line">1️⃣0️⃣分布式ID获取服务（资源）</span><br><span class="line">1️⃣1️⃣FCM消息推送服务</span><br><span class="line">1️⃣2️⃣BUZZ服务</span><br><span class="line">1️⃣3️⃣活动服务</span><br><span class="line">1️⃣4️⃣内部消息服务</span><br><span class="line">1️⃣5️⃣电商服务</span><br><span class="line">1️⃣6️⃣游戏服务</span><br><span class="line">1️⃣⑦广告服务</span><br></pre></td></tr></table></figure>
<p><strong>服务架构</strong><br><img src="/text_image/boomplay_server.png" alt="alt text"><br><img src="/text_image/boomplay_server2.png" alt="alt text"><br><strong>服务db模型</strong><br><img src="/text_image/boomplay_server_db.png" alt="alt text"><br><strong>B端服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">oms</span><br><span class="line">cms</span><br><span class="line">ams</span><br><span class="line">ads</span><br><span class="line">ssp</span><br><span class="line">adx</span><br></pre></td></tr></table></figure>

<h2 id="职场"><a href="#职场" class="headerlink" title="职场"></a>职场</h2><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><p><code>在魅族工作一年左右离职，离职的原因是疫情期间，魅族现金流出现了严重问题，周围同事纷纷离职，于是离职，另某出路；</code><br><code>在期间遇到过一些问题：领导批判，主动性不够，不能及时的暴露问题；实际情况是，项目线上遇到的问题，如产品需求设计有误，项目上线代码合并有误，或者带bug上线（bug已暴露），等会归咎于测试；</code><br><code>结合其他同事的工作情况反思，主要是由于；自己本身有一些瑕疵（如自己偶尔会迟到，且有一些摸鱼行为），同时本身和小组长关系不太好，由于这些瑕疵，导致领导不太信任自己；同时自己在项目中存在感太低，没有话语权，导致一些本身和测试无关的问题，也会压在测试身上，从而将问题带给组长，形成了负面循环；</code></p>
<h3 id="传易"><a href="#传易" class="headerlink" title="传易"></a>传易</h3><p><code>传易工作三年左右，职场也不太顺利；研发部老大对我意见很大，期间直属上级提了两次升职，都被他给打回去了；</code><br><code>导致上述状况的原因有几点，我工作状态比较懒散（说是我因为经常躺在椅子上工作），经常迟到，经常到花园摸鱼，工作产出不够，出了一些事；</code><br><code>总的来说，还是因为我个人的风格，陆总不太喜欢，然后把压力传导给了我的直属上级，然后工作中得不到支持，处处碰壁，且自己产出也不够；</code></p>
<h2 id="总结-反思"><a href="#总结-反思" class="headerlink" title="总结/反思"></a>总结/反思</h2><h3 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">职业规划，未来还是要走专业路线，期望的发展方向还是devops和性能岗；但这类岗位较少，因此我在求职时，在核心突出的前提下，测开的各细分方向，我都需要有了解；</span><br><span class="line">职业技能方面，尤其是编码能力，算法能力，大数据架构能力，是我后续前进的方向；</span><br><span class="line">基础是基石，基础不牢固；很多想法就无法落地；</span><br></pre></td></tr></table></figure>

<h3 id="职场-1"><a href="#职场-1" class="headerlink" title="职场"></a>职场</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">过去两份工作，由于自己在工作中有明显的瑕疵，导致容易授人以柄，因此对于后续的工作，一定要严抓职场纪律，不能迟到，最好在领导到之前到达公司，且不能有明显的问题被人拿捏；</span><br><span class="line">工作中，不受领导青睐，对于测开/架构类工作，工作是无法开展的；因此后续工作还是要和领导走近一点，要会来事，捧人，同时入职时，也要考虑下上级的为人，有些领导我是注定无法在他们手底下工作的；</span><br><span class="line">工作中，产出是核心，如果没有产出，专业素养不过关，注定得不到重视，获取不到话语权和资源；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>传易</tag>
      </tags>
  </entry>
  <entry>
    <title>传音刷机</title>
    <url>/posts/a1b2e86a/</url>
    <content><![CDATA[<ol>
<li>设置 -&gt; 开发者模式打开 oem unlock<br>输入 adb reboot bootloader</li>
<li>进入fastboot模式输入 fastboot flashing unlock。按住音量上键确认unlock</li>
<li>fastboot reboot 重启</li>
<li>开机后,输入 adb root</li>
<li>执行 adb disable-verity</li>
<li>执行 adb reboot</li>
<li>重启后 执行 adb root</li>
<li>执行 adb remount</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>估值体系</title>
    <url>/posts/daef770e/</url>
    <content><![CDATA[<h1 id="估值体系"><a href="#估值体系" class="headerlink" title="估值体系"></a>估值体系</h1><p><code>基于唐朝的估值体系，以无风险收益率为锚，取企业近五年的扣非净利润的均值（删除最大最小值）；估算三年后的合理估值，作为买卖点的依据； </code></p>
<span id="more"></span>

<h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">高收益的前提是持续稳定的复利，即好企业是时间的朋友，坏企业是时间的敌人；</span><br><span class="line">30pe是合理估值的上限，这是由无风险收益率决定的，如果在高，买入收益就低于无风险收益率了；同理合理估值一般给到20-25，而我不买25倍以上的企业(这想法绝对是错的。只关乎个人的安全边际)；</span><br><span class="line">股权和债券的差异，主要体现在确定性和成长里；股市需要利用成长优势抵消不确定性；</span><br><span class="line">收益率=利润/本金（股价）=1/pe；合理估值的锚其实就是无风险收益率（1/无风险收益率）；</span><br><span class="line">无分红公司的净资产收益率=净利润增速（可能净利润要打折）；</span><br><span class="line">分红在投入公司的净资产真实收益率=roe(1/pb*分红金额比例+留存金额比例)；</span><br><span class="line">年化收益率=年份√总收益率；</span><br><span class="line">由收益率公式可知；收益率一般不会超过净利润增速（仅当市净率低于1时超过，但这种现金流会受负债等因素损耗）；且要提高投资收益率，只有提高净利润的增速、降低分红比例、在分红比例固定时则只有降低pb也就是估值才能有效提高收益率；</span><br></pre></td></tr></table></figure>

<h2 id="买卖"><a href="#买卖" class="headerlink" title="买卖"></a>买卖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">理想买点：三年后合理估值*0.5</span><br><span class="line">理想卖点：min(动态市盈率50,三年后合理估值150%)</span><br><span class="line"></span><br><span class="line">买操作：20-25倍区间都能买，仅茅台在25倍pe以上买入;到达理想买点时，分三批买完剩余资金（理想买点/理想买点-5%/理想买点-10%）</span><br><span class="line">卖操作：当年预计净利润的50/55/60三次清空；（买卖点是唐朝基于无风险收益率计算，正常超出合理估值都能卖，50%其实是预留的安全边际）</span><br><span class="line">三年后合理估值=三年后预估净利率*25（具体企业具体分析，也就是pe的中分位）</span><br><span class="line"></span><br><span class="line">全指数基金买/卖点：基于无风险收益率来，但是由于不确定性，要做净利润折算，需要进行等比例折算，折算区间在5-7折</span><br><span class="line">买点：12-15pe</span><br><span class="line">卖点：25-35pe</span><br><span class="line"></span><br><span class="line">♥卖出后买全指还是留现金取决于无风险收益率（一般2倍无风险收益率即可买pe=1/无风险收益率*2，全指唐朝仅关注沪深300/恒生指数/标普500/纳斯达克100）</span><br><span class="line">♥其他时间：企业逻辑未变时，低于买点买，高于卖点卖，其他时间坐等；但需要遵循单股不超40%原则，即三五个行业，七八家公司；</span><br><span class="line">♥不要严格按买卖价来，要接受错误和风险；确定性高的企业，越偏向合理估值之下就买，确定性低的企业越偏向理想买点才买，唐朝的理念是理想买点位置一定要买完资金；</span><br></pre></td></tr></table></figure>

<h2 id="持仓组合"><a href="#持仓组合" class="headerlink" title="持仓组合"></a>持仓组合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">♥腾讯+纳指50%：计划200k,余量133K</span><br><span class="line">已持仓67k,其中中概58k&#x2F;纳指9k</span><br><span class="line">腾讯计划以300均价，买入6手；高溢价时，优先使用中概换腾讯（中概大部分公司不盈利）</span><br><span class="line">1️⃣理想买点：328</span><br><span class="line">2️⃣理想卖点：1年内720</span><br><span class="line">3️⃣纳指买点：21pe</span><br><span class="line">4️⃣纳指卖点：35pe</span><br><span class="line"></span><br><span class="line">♥银行+家电25%：计划100k,余量16k</span><br><span class="line">已持仓84k,其中家电50k&#x2F;银行34k</span><br><span class="line">理想卖点&#x2F;买点：</span><br><span class="line">1️⃣招行卖点1.4-1.7pb即45.8-55.6，买点低于1.13即37左右，招商计划以28均价，买入5手</span><br><span class="line">2️⃣美的按15倍市盈率12%净利润增长，合理卖点是78(合理估值)-81.9，买点是40</span><br><span class="line">3️⃣格力按14倍市盈率7.7%净利润增长，合理卖点是58（合理估值）-71.81，买点是34</span><br><span class="line"></span><br><span class="line">♥消费15%：计划60k,余量40k</span><br><span class="line">已持仓20k,伊利20k</span><br><span class="line">理想卖点&#x2F;买点：</span><br><span class="line">1️⃣五粮液150快,理想买点150&#x2F;143&#x2F;135</span><br><span class="line">2️⃣伊利按25倍市盈率11.42%净利润增长，理想卖点60-68，理想买点21，可买点34以下；此刻的分红在投资收益率为9.56%；</span><br><span class="line"></span><br><span class="line">♥医药10%：计划40k,余量3k</span><br><span class="line">已持仓37k,其中恒瑞20k&#x2F;ETF17K</span><br><span class="line">理想卖点&#x2F;买点：</span><br><span class="line">1️⃣恒瑞按50倍市盈率20.07%净利润增长，卖点60（合理估值）-86.85（理想卖点），买点34.7,理想买点29</span><br><span class="line">2️⃣300医药ETF计划0.42，买入7000个，卖点为0.7以上，对应300医药指数50倍以上的估值</span><br><span class="line">医药需要恒瑞和etf实现高低互换，高换低；</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>做点事</title>
    <url>/posts/2837d102/</url>
    <content><![CDATA[<h1 id="广告也是内容"><a href="#广告也是内容" class="headerlink" title="广告也是内容"></a>广告也是内容</h1><p><em><strong>广告内容加工</strong></em></p>
<span id="more"></span>
<ul>
<li><strong>优点</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、内容生产投入大，因此质地优良；</span><br><span class="line">2、由于是免费传播，无版权问题；</span><br><span class="line">3、广告天然是变现产品，变现能力强；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>生产</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、youtube</span><br><span class="line">2、bilibili</span><br><span class="line">3、其他短视频</span><br><span class="line">4、电视节目</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>痛点</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">怎么使得内容有消费潜力</span><br></pre></td></tr></table></figure>


<p><em><strong>聚合站</strong></em></p>
<ul>
<li><strong>介绍</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">聚合站指视频/pron/小说/新闻聚合站</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、内容丰富，可消费性强</span><br><span class="line">2、可通过爬虫获取数据，成本较低</span><br><span class="line">3、变现方式多元，盈利能力强</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、从几大主站爬去内容</span><br><span class="line">2、从其他盗版站爬去内容</span><br><span class="line">3、从开源/商业的内容服务获取内容</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>痛点</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、政策/法律风险</span><br><span class="line">2、国外投放，由于文化差异，内容偏好不同</span><br><span class="line">3、国外封网站较严重，如果规避被封</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>全局函数局部函数</title>
    <url>/posts/ae3a85c8/</url>
    <content><![CDATA[<h1 id="全局局部函数"><a href="#全局局部函数" class="headerlink" title="全局局部函数"></a>全局局部函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">全局函数：global</span><br><span class="line">局部函数：nonlocal</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>global</strong></p>
<p><code>全局函数在模块py中生效；使用时需要先定义，在声明；一次声明，模块中全局使用，全局和局部不能是同一个变量； global a a=s</code></p>
<p><strong>nonlocal</strong></p>
<p><code>局部变量函数在模块中局部函数中生效；需要先声明，后定义成局部变量，一旦定义成局部变量就仅在该函数中生效，离开该函数就不生效，不能和全局变量为同一个变量 a=s nonlocal a</code></p>
<p><a href="https://www.cnblogs.com/liyang93/p/6669874.html">参考</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>可变对象合并方法</title>
    <url>/posts/def45bf2/</url>
    <content><![CDATA[<h1 id="可变对象合并的方法"><a href="#可变对象合并的方法" class="headerlink" title="可变对象合并的方法"></a>可变对象合并的方法</h1><p>eg:list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+:合并</span><br><span class="line">+=：增加赋值</span><br><span class="line">append()：添加</span><br><span class="line">extend()：插入</span><br><span class="line"></span><br><span class="line">list=[1,2,3]</span><br><span class="line">l=[4]</span><br><span class="line">s=list+l</span><br><span class="line">s=list.append(l)</span><br><span class="line">s=list.extend(l)</span><br><span class="line">list+=l</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list&#x27;</span>,list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;l&#x27;</span>,l)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s&#x27;</span>,s)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>+合并</strong></p>
<p><code> 合并方法，是影响最小，速度最慢的方法；因为他不会改变原序列，会复制后生成一个新的序列    </code></p>
<p><strong>append()</strong><br>    <code>    添加方法，会直接将对象添加到原序列末尾；会改变原序列    </code></p>
<p><strong>extend()</strong><br>    <code>    插入方法，会将对象的元素添加到序列末尾，而不是对象，会改变原序列    </code></p>
<p><strong>+=</strong><br>    <code>    增强赋值方法，类似于合并=；和extend()等效，效率比其低，会改变原序列    </code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>序列</tag>
      </tags>
  </entry>
  <entry>
    <title>各家模拟器对比分析</title>
    <url>/posts/83661fed/</url>
    <content><![CDATA[<h1 id="各家模拟器对比分析"><a href="#各家模拟器对比分析" class="headerlink" title="各家模拟器对比分析"></a>各家模拟器对比分析</h1><ul>
<li><em><strong>大纲</strong></em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对比产品</span><br><span class="line">包体大小</span><br><span class="line">安兔兔评分</span><br><span class="line">支持功能</span><br><span class="line">资源消耗/操作体验</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ul>
<li><p><strong>对比产品</strong></p>
<ul>
<li>网易Mumu模拟器</li>
<li>逍遥模拟器</li>
<li>腾讯手游模拟器</li>
<li>黑雷模拟器</li>
<li>水果模拟器</li>
</ul>
</li>
<li><p><strong>包体大小</strong></p>
<ul>
<li>网易Mumu模拟器</li>
</ul>
<ul>
<li>apk大小: 8.87M</li>
<li>安装消耗硬盘: 2.73G</li>
</ul>
<ul>
<li>逍遥模拟器<ul>
<li>apk大小: 351M </li>
</ul>
</li>
</ul>
<ul>
<li>安装消耗硬盘: 1.96G</li>
</ul>
<ul>
<li>腾讯手游模拟器<ul>
<li>apk大小: 3.49M </li>
</ul>
</li>
</ul>
<ul>
<li>安装消耗硬盘: 235M</li>
</ul>
<ul>
<li>黑雷模拟器</li>
</ul>
<ul>
<li>apk大小: 126M</li>
<li>安装消耗硬盘: 333M</li>
</ul>
<ul>
<li>水果模拟器</li>
</ul>
<ul>
<li>apk大小: 37.1M</li>
<li>安装消耗硬盘: 125M</li>
</ul>
</li>
<li><p><strong>安兔兔评分</strong></p>
<ul>
<li>网易Mumu模拟器</li>
</ul>
<ul>
<li>评分<br><img src="/text_image/%E7%BD%91%E6%98%93.png" alt="alt text"></li>
</ul>
<ul>
<li>逍遥模拟器<ul>
<li>评分<br><img src="/text_image/%E9%80%8D%E9%81%A5%E6%B8%B8.png" alt="alt text"></li>
</ul>
</li>
<li>腾讯手游模拟器</li>
</ul>
<ul>
<li>评分<br>无，不支持非分发应用</li>
</ul>
<ul>
<li>黑雷模拟器（付费）</li>
</ul>
<ul>
<li>评分</li>
</ul>
<ul>
<li>水果模拟器（付费）</li>
</ul>
<ul>
<li>评分</li>
</ul>
</li>
<li><p><strong>支持功能</strong></p>
<ul>
<li>网易Mumu模拟器<ul>
<li>支持功能<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">支持安装boomplay</span><br><span class="line">支持对boomplay进行的所有操作</span><br><span class="line">不支持手势操作</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>逍遥模拟器<pre><code>* 支持功能
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">支持安装boomplay</span><br><span class="line">支持对boomplay进行的所有操作</span><br><span class="line">不支持手势操作</span><br><span class="line">安兔兔跑分时崩溃</span><br><span class="line">打开app时崩溃</span><br></pre></td></tr></table></figure>
</li>
<li>腾讯手游模拟器<ul>
<li>支持功能<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不支持安装我们的apk,仅支持安装在腾讯手游助手分发的应用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>黑雷模拟器（付费）<ul>
<li>支持功能<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不支持安装非分发的应用</span><br><span class="line">含病毒组件，用来挖矿的</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>水果模拟器（付费）<ul>
<li>支持功能<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">云手机，非手机模拟器</span><br><span class="line">不支持安装boomplay</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>资源消耗/操作体验</strong> </p>
<ul>
<li><p>网易Mumu模拟器<br><img src="/text_image/%E7%BD%91%E6%98%93_cpu.jpg" alt="alt text"></p>
<ul>
<li>操作体验<br><code>覆盖从5.3.0到最新版本的所有大版本，功能均支持；稳定性也较好，无崩溃或anr现象；操作流畅，无卡顿；</code></li>
</ul>
</li>
<li><p>逍遥模拟器<br><img src="/text_image/%E9%80%8D%E9%81%A5%E6%B8%B8_cpu.png" alt="alt text"></p>
</li>
</ul>
</li>
<li><p><strong>结论</strong> </p>
<ul>
<li><em><strong>android</strong></em></li>
</ul>
<p><code>建议使用网易mumu模拟器，改模拟器支持我们app的所有版本，操作流程，资源消耗较少，稳定性较高；且一旦出现模拟器/app崩溃等异常现象时，只要电脑支持远程连接，恢复也较方便；</code></p>
<ul>
<li><em><strong>ios</strong></em></li>
</ul>
<p><code>国内付费的模拟器均不支持安装我们的app;</code></p>
</li>
</ul>
<p> 建议方案：ups+远控软件（tv）+网易模拟器（免费）<br> 成本：ups(200-300￥)+win自带的远程连接+mumu模拟器 </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据--测试</title>
    <url>/posts/ac354d65/</url>
    <content><![CDATA[<p><code>大数据测试，工作内容主要有：数据测试、模型测试；同时在不同的业务阶段，工作的重心不同，数据质量体系也会有不同的倾向，要全局的了解大数据测试，必须先明白大数据的架构，工作过程</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">大数据架构</span><br><span class="line">数据测试</span><br><span class="line">模型测试</span><br><span class="line">数据质量体系</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="大数据架构"><a href="#大数据架构" class="headerlink" title="大数据架构"></a>大数据架构</h2><p><code>常见的大数据架构主要有Hadoop（分布式文件存储、计算系统）；由分布式文件系统（HDFS）/集群资源管理器（YARN）分布式计算框架（MR/mapreduce）构成；其中HDFS负责管理存储数据，YARN负责管理集群中的计算资源，调度和执行工作任务；</code></p>
<p><strong>组件：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">核心组件：</span><br><span class="line">HDFS:分布式文件系统，存储数据；</span><br><span class="line">YARN：集群资源管理器，管理计算资源，进行调度；</span><br><span class="line">MR：计算框架，一般负责离线计算；</span><br><span class="line"></span><br><span class="line">生态组件：</span><br><span class="line">PIG：数据流处理（用于并行计算的高级数据流语言和执行框架）；</span><br><span class="line">HBASE：NSQL型的分布式数据库，本质是一个键值系统,底层数据存储在文件系统HDFS上；</span><br><span class="line">SPARK：分布式计算引擎，类似MR,但在内存中计算，提供各种库，可以使开发者用来实现ETL、机器学习、数据流处理、图像计算等场景；</span><br><span class="line">FLUME：数据采集</span><br><span class="line">FLINK：针对流数据（实时数据）和批数据（离线数据）的实时处理引擎，有着高吞吐、低延迟的特点；</span><br><span class="line">SQOOP：数据导入导出</span><br><span class="line">KAFKA：分布式消息引擎及流处理平台，用来存储/传递消息（如日志或埋点）；</span><br><span class="line">AWS S3 ：静态资源存储，可能是大型的日志文件吧；</span><br><span class="line">SOLR：用于搜索索引的全文检索服务器；</span><br><span class="line"></span><br><span class="line">数据查询引擎:</span><br><span class="line">HIVE S3：数据仓库基础架构，提供数据汇总和命令行即席查询功能；</span><br><span class="line">IMPALA：高效的基于MPP架构的快速查询引擎，基于Hive并使用内存进行计算，兼顾ETL功能，具有实时、批处理、多并发等优点；</span><br><span class="line">KYLIN：开源分布式分析型数据仓库，提供Hadoop/Spark之上的SQL查询接口及多维分析（OLAP）能力，支持超大规模数据的压秒级查询（和视图有点点类似）；</span><br><span class="line">PRESTO：开源的分布式查询引擎，支持多数据源，大量级数据的场景；</span><br><span class="line"></span><br><span class="line">ETL：数据处理的过程，指数据提取（extract）、转换（transform）、加载（load）的过程；</span><br><span class="line">组件众多。不同组件提供不同能力，Hadoop框架，很像Android系统，是一个底层的数据框架。</span><br></pre></td></tr></table></figure>
<p>参考架构：<br><img src="/text_image/Hadoop.png" alt="alt text"><br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6.png" alt="alt text"></p>
<h3 id="传易音乐大数据架构"><a href="#传易音乐大数据架构" class="headerlink" title="传易音乐大数据架构"></a>传易音乐大数据架构</h3><p><strong>传易hadoop</strong><br><img src="/text_image/biddate.png" alt="alt text"></p>
<p><strong>传易数仓架构</strong><br><img src="/text_image/bigdate_%E6%95%B0%E4%BB%93%E6%9E%B6%E6%9E%84.png" alt="alt text"></p>
<p><strong>数据架构（数仓）</strong><br><img src="/text_image/bigdata_%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84.png" alt="alt text"></p>
<p><strong>数据架构–横向数据分层</strong><br><img src="/text_image/%E6%A8%AA%E5%90%91%E6%95%B0%E6%8D%AE%E5%88%86%E5%B1%82.png" alt="alt text"></p>
<p><strong>数据架构–纵向数据分层</strong><br><img src="/text_image/%E7%BA%B5%E5%90%91%E6%95%B0%E6%8D%AE%E5%88%86%E5%B1%82.png" alt="alt text"></p>
<p><strong>传易大数据架构总述：</strong></p>
<p><code>传易架构的特点是处理的数据量大，数据来源复杂，人员多，业务应用广；存在无文档资料维护；测试介入低，质量不可度量；无测试环境，依赖线上数据开发测试，流程不规范，安全性差；缺乏标准和度量体系，投入产出比无法度量等问题；</code></p>
<h2 id="数据测试"><a href="#数据测试" class="headerlink" title="数据测试"></a>数据测试</h2><p><code>数据测试前，需要对数据质量形成共识；数据的价值是由需求方决定的，能满足需求方/使用方需求的数据才能称得上好数据</code></p>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><h4 id="数据质量评测方向"><a href="#数据质量评测方向" class="headerlink" title="数据质量评测方向"></a>数据质量评测方向</h4><p><code>数据质量我们一般从以下六个维度评判，同时我们往往还需求考虑数据的（+安全性），评价这些维度往往需要用到监控数据和历史数据：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">完整性：数据不多不少。数据条数完整，类型完整，参数完整；不重复，看是否有异常类型或者异常值（枚举外）；</span><br><span class="line">准确性：结果准确，抽样准；表内横向准确，表间/数据链路间的数据准备或一致，参数数据分布准确；</span><br><span class="line">及时性：实时数据性能满足需求，各组件性能满足要求；如用户余额，抽奖次数等，主要受任务调度、优先级、处理耗时影响，一般关注整体和局部的耗时情况；</span><br><span class="line">一致性：前后数据一致，参数和总体满足逻辑一致，如订阅总额=订阅单价*时长</span><br><span class="line">有效性：数据是有效的符合数据规范，如email数据、身份证数据规范</span><br><span class="line">唯一性：数据唯一，如每个用户的boom_id,每个音乐的music_id</span><br></pre></td></tr></table></figure>
<p><img src="/text_image/%E6%95%B0%E6%8D%AE%E5%8A%9F%E8%83%BD.png" alt="alt text"><br><strong>以上是测试时评判的方向，测试过程也需要有标准来评判有效性,如下：(理论不同对象/不同阶段都应该有标准)</strong></p>
<h4 id="测试活动度量标准"><a href="#测试活动度量标准" class="headerlink" title="测试活动度量标准"></a>测试活动度量标准</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">覆盖率</span><br><span class="line">测试效果-产出度量</span><br><span class="line">测试件的质量</span><br></pre></td></tr></table></figure>

<h4 id="数据质量度量标准"><a href="#数据质量度量标准" class="headerlink" title="数据质量度量标准"></a>数据质量度量标准</h4><p><code>除了测试时，需要考虑的场景外，还需要对整体的数据质量好坏进行评判，以下为数据质量的优劣评判标准</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">98%：全年可用天数达到98%以上，即服务不达标天数全年不超过7天。</span><br><span class="line">基线时间：核心 SLA 基线产出时间需满足业务要求。</span><br><span class="line">是否易于使用：及其他非质量熟悉标准（见MFQ）</span><br></pre></td></tr></table></figure>

<p><strong>以上指标为传易的定量的标准，以下为美团的定量的标准</strong><br><img src="/text_image/%E7%BE%8E%E5%9B%A2%E9%87%8F%E5%8C%96%E6%8C%87%E6%A0%87.png" alt="alt text"></p>
<h3 id="数据质量评测流程"><a href="#数据质量评测流程" class="headerlink" title="数据质量评测流程"></a>数据质量评测流程</h3><p><code>要想把控数据质量，往往需要介入数据的全生命周期；需要有标准可依，有规范进行约束，有监控数据可查，有工具可用来进行评测，流程结果可量化，并且可以持续运营迭代体系：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">业务分析--分析数据流（流程图）、数据特性（计算型/时效型）</span><br><span class="line">设计阶段--数据类型、数据处理逻辑、数据链路、数据服务</span><br><span class="line">数据标准--量化的数据标准，作为内外部的规范和约束</span><br><span class="line">数据监控--数据监控能力，是否有全链路监控能力</span><br><span class="line">数据卡点--针对不同阶段的数据（流程）是否有卡点，能进行评测和定位问题</span><br><span class="line">数据环境--如何低成本，高效的维护数据测试环境</span><br><span class="line">构造数据--如何快速有效的实现可复用数据构造能力</span><br><span class="line">数据评测--如何保障评测的有效性、覆盖率、标准化</span><br><span class="line">数据量化--如何实现数据流程、质量、评测的量化，让过程结果更公开透明</span><br><span class="line">迭代优化--如何管理问题，运营数据，归纳形成标准，持续的优化体系</span><br></pre></td></tr></table></figure>
<h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><p><strong>数据治理可参考的切入阶段</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E5%8F%AF%E5%88%87%E5%85%A5%E7%9A%84%E9%98%B6%E6%AE%B5.png" alt="alt text"><br><strong>数据质量三板斧</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E4%B8%89%E6%9D%BF%E6%96%A7.png" alt="alt text"></p>
<h4 id="数据功能测试"><a href="#数据功能测试" class="headerlink" title="数据功能测试"></a><strong>数据功能测试</strong></h4><p><strong>三板斧:数据分析技巧</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.png" alt="alt text"><br><strong>测试范围</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E5%8A%9F%E8%83%BD.jpg" alt="alt text"><br><strong>功能测试，很重要的一环是ETL:ETL测试维度</strong><br><img src="/text_image/ETL%E6%B5%8B%E8%AF%95.png" alt="alt text"><br><strong>离线ETL测试步骤：核心在数据</strong><br><img src="/text_image/ETL%E6%B5%8B%E8%AF%95_%E6%AD%A5%E9%AA%A4.png" alt="alt text"><br><strong>实时数据ETL：核心除了数据、还有性能</strong><br><img src="/text_image/%E5%AE%9E%E6%97%B6etl.png" alt="alt text"><br><strong>数据仓库分层测试</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%88%86%E5%B1%82%E6%B5%8B%E8%AF%95.png" alt="alt text"><br><strong>项目测试经验</strong><br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C.png" alt="alt text"></p>
<h4 id="数据性能测试"><a href="#数据性能测试" class="headerlink" title="数据性能测试"></a><strong>数据性能测试</strong></h4><p><img src="/text_image/%E6%95%B0%E6%8D%AE%E6%80%A7%E8%83%BD.png" alt="alt text"><br><strong>大数据性能工具：</strong><br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%80%A7%E8%83%BD.png" alt="alt text"></p>
<h4 id="数据安全测试"><a href="#数据安全测试" class="headerlink" title="数据安全测试"></a><strong>数据安全测试</strong></h4><p><code>以上的数据质量评测标准未说明安全情况，数据安全需要考虑数据本身的安全（隐私脱敏），流程安全，权限管控、安全监控，故在此处说明，安全需要覆盖的场景如下：</code><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8.png" alt="alt text"></p>
<p><strong>数据安全实施策略</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E6%96%BD.png" alt="alt text"></p>
<h4 id="数据质量问题处理链路"><a href="#数据质量问题处理链路" class="headerlink" title="数据质量问题处理链路"></a><strong>数据质量问题处理链路</strong></h4><p><img src="/text_image/%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98.png" alt="alt text"></p>
<h3 id="数据治理工具"><a href="#数据治理工具" class="headerlink" title="数据治理工具"></a><strong>数据治理工具</strong></h3><p><strong>开源框架</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6.png" alt="alt text"><br><strong>大数据测试工具</strong><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.png" alt="alt text"><br><strong>大数据测试平台架构</strong><br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E9%9C%80%E6%B1%82.png" alt="alt text"><br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84.png" alt="alt text"><br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="alt text"></p>
<ul>
<li>大数据测试平台-参考质量报告<br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0-%E8%B4%A8%E9%87%8F%E6%8A%A5%E5%91%8A.png" alt="alt text"></li>
<li>展望：看起来是朝线上监控化的方向走<br><img src="/text_image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%B1%95%E6%9C%9B.png" alt="alt text"></li>
</ul>
<h2 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h2><p><a href="https://www.bujiaban.xyz/posts/d775e226/">广告-模型测试</a></p>
<h2 id="大数据质量体系"><a href="#大数据质量体系" class="headerlink" title="大数据质量体系"></a>大数据质量体系</h2><p><strong>数据质量活动需要遵循：有标准、有数据（监控）、可量化（度量）、自动化的原则；质量体系总结如下：</strong><br><img src="/text_image/%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.jpg" alt="alt text"><br><img src="/text_image/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E4%BD%93%E7%B3%BB.png" alt="alt text"></p>
<ul>
<li><a href="%E7%BA%BF%E4%B8%8B%E6%96%87%E6%A1%A3">大数据治理规划</a></li>
<li><a href="%E7%BA%BF%E4%B8%8B%E6%96%87%E6%A1%A3">大数据产品质量体系建设</a></li>
<li><a href="https://mp.weixin.qq.com/s/AlxIMPnKcWSyhOSe8-OfTQ">美团–业务数据治理体系化思考与实践</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据测试</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据BI报表架构调整</title>
    <url>/posts/10f9513d/</url>
    <content><![CDATA[<h1 id="大数据BI报表架构调整"><a href="#大数据BI报表架构调整" class="headerlink" title="大数据BI报表架构调整"></a>大数据BI报表架构调整</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><span id="more"></span>

<h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="覆盖范围"><a href="#覆盖范围" class="headerlink" title="覆盖范围"></a>覆盖范围</h3><p><em><strong>oms Category Analysis模块</strong></em></p>
<ul>
<li>覆盖前端交互</li>
<li>覆盖报表的数据</li>
<li>覆盖接口性能</li>
</ul>
<p><em><strong>Traffic Analysis</strong></em></p>
<ul>
<li>覆盖前端交互</li>
<li>覆盖报表的数据</li>
<li>覆盖接口性能</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>工作梳理</title>
    <url>/posts/8c69a8ec/</url>
    <content><![CDATA[<h1 id="工作梳理"><a href="#工作梳理" class="headerlink" title="工作梳理"></a>工作梳理</h1><ul>
<li><em><strong>大纲</strong></em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">重点核心</span><br><span class="line">kpi导向</span><br><span class="line">日常工作</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><p><em><strong>重点核心</strong></em></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外部标准&#x2F;规范（预装&#x2F;上架）：稳定性&#x2F;anr&#x2F;clash&#x2F;内存曲线（P0）</span><br><span class="line">线上监控&#x2F;稳定性：监控体系（P1）</span><br><span class="line">服务性能提升：性能测试(P1)</span><br><span class="line">增效：环境治理，效率提升</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>外部标准</strong></li>
</ul>
<p> <code> 外部标准，指的是对接传音/其他外部时（谷歌），需要遵循对方的标准；因为不达标会影响上线，因此优先级最高为PO级； </code></p>
<ul>
<li>场景：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">稳定性测试：监控anr/clash/内存曲线是否达标</span><br><span class="line">核心：场景需要和标准同步</span><br><span class="line">实践：实用性强</span><br></pre></td></tr></table></figure></li>
<li>实现：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">待补</span><br></pre></td></tr></table></figure></li>
<li><strong>线上监控</strong></li>
</ul>
<p> <code> 线上监控是质量保障体系的重要一环；设定监控可以及时发现线上问题，及时处理；有效保障系统的质量； </code></p>
<ul>
<li>场景：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">系统监控：接口监控/服务器资源监控/数据的监控/基于埋点的功能监控</span><br></pre></td></tr></table></figure></li>
<li>实践：</li>
</ul>
<p>  <a href="https://testerhome.com/topics/19188">线上监控体系概述</a></p>
<ul>
<li><strong>服务性能提升</strong> </li>
</ul>
<p>  <code>  c端的系统，性能问题通常是困扰系统的常见问题；性能保障，也是对系统可用性的最大保障  </code></p>
<ul>
<li>场景：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">接口性能优化</span><br><span class="line">服务性能优化</span><br><span class="line">app性能优化</span><br></pre></td></tr></table></figure></li>
<li>实践：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">接口性能：接口性能其实是中后台性能，前后端分离的情况下，后端的性能瓶颈，往往是整个系统的性能瓶颈；</span><br><span class="line">服务性能：服务性能是后端的性能，粒度比接口更细，一般不用关注；</span><br><span class="line">客户端性能：客户端时和用户交互的，客户端性能直接影响到用户的体验；</span><br></pre></td></tr></table></figure></li>
<li><strong>增效/功能自动化</strong>  </li>
</ul>
<p>  <code>  功能自动化，一般用于回归测试，定期的巡检；起到增效的作用；  </code></p>
<ul>
<li>场景：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CI/CD持续迭代系统</span><br><span class="line">接口自动化</span><br><span class="line">ui自动化</span><br><span class="line">数据测试自动化</span><br><span class="line">常见的自动化脚本等</span><br></pre></td></tr></table></figure></li>
<li>实践：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">待补</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><em><strong>kpi导向</strong></em></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增效&#x2F;功能自动化：ui自动化&#x2F;接口自动化(P2)&#x2F;数据测试&#x2F;常见的自动化脚本</span><br></pre></td></tr></table></figure>

<ul>
<li><em><strong>日常工作</strong></em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">稳定性测试（monkey）</span><br><span class="line">接口自动化维护</span><br><span class="line">ui自动化维护</span><br><span class="line">数据测试脚本构建</span><br><span class="line">常见脚本开发</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>价值</tag>
      </tags>
  </entry>
  <entry>
    <title>常用app测试工具</title>
    <url>/posts/28eebda3/</url>
    <content><![CDATA[<h1 id="常用app测试工具"><a href="#常用app测试工具" class="headerlink" title="常用app测试工具"></a>常用app测试工具</h1><p>常用测试工具</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参考回答：</span><br><span class="line">功能测试自动化</span><br><span class="line">a) 轻量接口自动化测试</span><br><span class="line"></span><br><span class="line">jmeter，</span><br><span class="line"></span><br><span class="line">b) APP UI层面的自动化</span><br><span class="line"></span><br><span class="line">android：UI Automator Viewer，Android Junit，Instrumentation，UIAutomator，</span><br><span class="line"></span><br><span class="line">iOS:基于Instrument的iOS UI自动化，</span><br><span class="line"></span><br><span class="line">性能测试</span><br><span class="line"></span><br><span class="line">a) Web前端性能测试</span><br><span class="line"></span><br><span class="line">网络抓包工具：Wireshark</span><br><span class="line"></span><br><span class="line">网页文件大小</span><br><span class="line"></span><br><span class="line">webpagetest</span><br><span class="line"></span><br><span class="line">pagespeed insight</span><br><span class="line"></span><br><span class="line">chrome adb</span><br><span class="line"></span><br><span class="line">b) APP端性能测试</span><br><span class="line"></span><br><span class="line">Android内存占用分析：MAT</span><br><span class="line"></span><br><span class="line">iOS内存问题分析：ARC模式</span><br><span class="line"></span><br><span class="line">Android WebView性能分析：</span><br><span class="line"></span><br><span class="line">iOS WebView性能分析</span><br><span class="line"></span><br><span class="line">c) 后台服务性能测试</span><br><span class="line"></span><br><span class="line">负载，压力，耐久性</span><br><span class="line"></span><br><span class="line">可拓展性，基准</span><br><span class="line"></span><br><span class="line">工具：apacheAB，Jmeter，LoadRunner，</span><br><span class="line"></span><br><span class="line">专项测试</span><br><span class="line"></span><br><span class="line">a) 兼容性测试</span><br><span class="line"></span><br><span class="line">手工测试：操作系统，分辨率，rom，网络类型</span><br><span class="line"></span><br><span class="line">云平台：testin，脚本编写，Android。</span><br><span class="line"></span><br><span class="line">b) 流量测试</span><br><span class="line"></span><br><span class="line">Android自带的流量管理，</span><br><span class="line"></span><br><span class="line">iOS自带的Network</span><br><span class="line"></span><br><span class="line">tcpdump抓包</span><br><span class="line"></span><br><span class="line">WiFi代理抓包：Fiddler</span><br><span class="line"></span><br><span class="line">流量节省方法：压缩数据，json优于xml；WebP优于传统的JPG，PNG；控制访问的频次；只获取必要的数据；缓存；</span><br><span class="line"></span><br><span class="line">c) 电量测试</span><br><span class="line"></span><br><span class="line">基于测试设备的方法，购买电量表进行测试。</span><br><span class="line"></span><br><span class="line">GSam Battery Monitoe Pro</span><br><span class="line"></span><br><span class="line">iOS基于Instrument Energy工具</span><br><span class="line"></span><br><span class="line">d) 弱网络测试</span><br><span class="line"></span><br><span class="line">手机自带的网络状况模拟工具</span><br><span class="line"></span><br><span class="line">基于代理的弱网络的模拟:</span><br><span class="line"></span><br><span class="line">工具：windows：Network Delay Simulator</span><br><span class="line"></span><br><span class="line">Mac：Network Link Conditioner</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>app测试</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据--广告--模型测试</title>
    <url>/posts/d775e226/</url>
    <content><![CDATA[<p><code>模型是程序化广告的灵魂，决定着广告的点击和转化，直接影响收入；而模型由于复杂度高，标签/数据量大，是广告测试的难点，一般意义上，测试是不负责模型质量的，仅对模型中的一些定向/过滤逻辑做覆盖，模型有效性测试，模型工程师一般是通过灰度/ab测试来实现自测的，这种自我监督的实现方式有着明显缺陷，故本次对过往模型测试方面的记录，做下总结</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">常规测试方案</span><br><span class="line">调研测试方案</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="常规测试方案"><a href="#常规测试方案" class="headerlink" title="常规测试方案"></a>常规测试方案</h2><p><code>模型由于数据量大，且计算的复杂度极高，一般测试不参与测试；大数据研发测试模型质量的常用方式，主要有离线指标分析，灰度流量评估的方式；这两种方式的有效性都比较低。其中离线指标分析，一般是单条数据或者指标的分析，覆盖的场景较少；而灰度流量评估的方式也存在数据量小，场景单一，且不同场景无法横向对比的问题，且评估效果太主观，无法量化和追溯。</code></p>
<h2 id="调研测试方案"><a href="#调研测试方案" class="headerlink" title="调研测试方案"></a>调研测试方案</h2><p><code>本次调研了testerhome上面同业们的处理方式；思路，主要是对模型处理的各环节进行监控，然后对各环节的处理逻辑进行复盘，对中间数据进行分析，设置阈值，记录数据及异常值，同时通过流量回放的方式来横向评估效果；难点不少，首先模型的因子众多，需要监控的指标极多，同时模型训练时，样本数据极多，需要时间和机器成本，如果规模较小，收益会比较低。</code></p>
<h3 id="广告模型链路"><a href="#广告模型链路" class="headerlink" title="广告模型链路"></a>广告模型链路</h3><p><code>基于链路分析，设计监控指标，进行对比</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数据来源</span><br><span class="line">特征提取</span><br><span class="line">离线训练</span><br><span class="line">模型构建</span><br><span class="line">发布上线</span><br><span class="line">效果评估</span><br></pre></td></tr></table></figure>

<h3 id="参考监控指标"><a href="#参考监控指标" class="headerlink" title="参考监控指标"></a>参考监控指标</h3><p><code>监控指标需要根据具体情况实现</code><br><img src="/text_image/%E6%A8%A1%E5%9E%8B%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87.png" alt="alt text"></p>
<h3 id="效果横向对比"><a href="#效果横向对比" class="headerlink" title="效果横向对比"></a>效果横向对比</h3><p><code>模型的效果通过流量回放的方式来触发，通过横向多维度对比来评估效果，监控的效果类的指标如下</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">机器学习相关</span><br><span class="line">	AUC</span><br><span class="line">	COPC</span><br><span class="line">	LOGLOSS</span><br><span class="line">	PCTR</span><br><span class="line">	准确率</span><br><span class="line">	召回率</span><br><span class="line">	ROC 曲线</span><br><span class="line">业务相关</span><br><span class="line">	实时收入</span><br><span class="line">	CTR</span><br><span class="line">	CVR</span><br><span class="line">	CPM</span><br><span class="line">特征效果相关</span><br><span class="line">	IV</span><br><span class="line">	WOE</span><br><span class="line">	特征变现变化</span><br><span class="line"></span><br><span class="line">效果数据横向对比</span><br><span class="line">	不同阶段的对比</span><br><span class="line">	阶段一致性对比</span><br><span class="line">	时间维度</span><br><span class="line">	版本对比</span><br><span class="line">	分桶</span><br><span class="line">	分adx    </span><br></pre></td></tr></table></figure>

<h3 id="模型发布依赖监控"><a href="#模型发布依赖监控" class="headerlink" title="模型发布依赖监控"></a>模型发布依赖监控</h3><p><code>模型发布依赖环节的监控，是全流程监控的一部分</code><br><img src="/text_image/%E6%A8%A1%E5%9E%8B%E5%8F%91%E5%B8%83%E4%BE%9D%E8%B5%96.png" alt="alt text"></p>
<h3 id="360模型监控平台的其他功能"><a href="#360模型监控平台的其他功能" class="headerlink" title="360模型监控平台的其他功能"></a>360模型监控平台的其他功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查询</span><br><span class="line">	自定义场景查询</span><br><span class="line">	配套表格数据</span><br><span class="line">	线上部署记录查询</span><br><span class="line">对比</span><br><span class="line">	同环比数据</span><br><span class="line">	不同模型对比</span><br><span class="line">	不同版本对比</span><br><span class="line">在线配置</span><br><span class="line">	基础属性配置</span><br><span class="line">	特征项管理</span><br><span class="line">	报警阈值配置</span><br><span class="line">	监控信号阈值配置</span><br><span class="line">交互友好</span><br><span class="line">	更新记录可查</span><br><span class="line">	前端性能</span><br></pre></td></tr></table></figure>
<p><strong>示例页面</strong><br><img src="/text_image/%E5%8F%82%E8%80%83%E9%A1%B5%E9%9D%A2.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>广告</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化--索引</title>
    <url>/posts/939ecb54/</url>
    <content><![CDATA[<p><code>索引是一种优化db查询的技巧，一种将表数据排序的结构；通过将db的单列/多列值设定为索引，在查询时就能根据索引值，直接查询到索引所在行的内存地址，不用查询全表了，从而大幅提供查询的速度</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">索引的底层（原理）</span><br><span class="line">索引的类型</span><br><span class="line">索引的操作</span><br><span class="line">索引的使用</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="索引的底层"><a href="#索引的底层" class="headerlink" title="索引的底层"></a>索引的底层</h2><p><code>底层主要维护了一个排序的数组，其中含有索引值和所在行内存地址的一组数据；索引底层有两种数据结构，B+数索引、哈希索引</code></p>
<ul>
<li>B+树索引：是一个平衡树，下标是索引，值是内存地址；查询的时间复杂度为O(log（n）)；可以用于排序（索引表是数据有顺序），和范围查找</li>
<li>哈希索引：是哈希的键值对，键是索引值，值为内存地址；查询的时间复杂度为O(1)；只能用于等值比较（键值）</li>
</ul>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">普通索引：任何列都能做索引，索引无值要求，可重复或为空</span><br><span class="line">唯一索引：索引所在列的值必须唯一，但列值可为空</span><br><span class="line">主键索引：将列的主键作为索引，所在列，值唯一，且不能为空</span><br><span class="line">组合索引：将多个列组合视作索引；如果一个表中的数据在查询时有多个字段总是同时出现则这些字段就可以作为复合索引,形成索引覆盖可以提高查询的效率（实际提高的是<span class="built_in">where</span>过滤的效率）</span><br><span class="line">全文索引：只有用于Innodb、MyIsam 表格，并且只能对 CHAR、VARCHAR、TEXT 列建全文索引；用于当索引的字段值很长，且用like模糊匹配效率较低时；语法</span><br><span class="line">前缀索引：当索引列是字符串时，可以使用字符串前缀作为索引，减少索引长度</span><br></pre></td></tr></table></figure>
<h2 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建索引：create index index_name on table_name(列名)</span><br><span class="line">删除索引：drop index index_name on table_name</span><br><span class="line">修改索引：alter table </span><br><span class="line">  添加普通/组合索引：alter table table_name add INDEX index_name(列1，列2)</span><br><span class="line">  添加唯一索引：alter tablet table_name ADD UNIQUE index_name (列1)</span><br><span class="line">  添加主键索引：alter table table_name ADD PRIMARY KEY index_name(列1)</span><br><span class="line">  添加全表索引：alter table table_name ADD DULLTEXT index_name (列1)</span><br><span class="line">  添加前缀索引：alt table table_name add INDEX index_name(email(6))	//这里以email列的键值前6位作为索引</span><br><span class="line">  编辑索引：先删除--后添加</span><br><span class="line">查询索引：show index from table_name</span><br></pre></td></tr></table></figure>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用于大量数据、或大表查询的场景；</span><br><span class="line">将经常使用的列作为索引；</span><br><span class="line">尽量使用短索引；</span><br><span class="line">如果用字符串值的列，最好使用前缀索引，防止索引值过长，前缀索引可以用来实现短索引；</span><br></pre></td></tr></table></figure>
<p><strong>索引的优势是对索引列进行了排序，不用全表查询，有查询优势；但对数据量很小的表，还有写入时，由于要改所有的索引，其实会降低写入性能；因此应该用于大表查询场景，不能用于频繁写入场景</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>传易--性能测试</title>
    <url>/posts/56a1ed73/</url>
    <content><![CDATA[<p><a href="https://docs.qq.com/doc/DSWZnVGNka29qa1lJ">内部项目，需找我授权</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试--总述</title>
    <url>/posts/28d322d/</url>
    <content><![CDATA[<p><code>性能测试是一个很大的话题；包含客户端、服务端性能、各中间件的性能；一般来说只要有io操作，可能存在压力的场景都可能出现性能瓶颈；同时性能测试是整个质量体系最为重要的几个专项之一，性能会影响用户体验，服务的稳定性，好的性能架构能有效的节省成本（机器）；性能的原理，是通过模拟压力来对业务场景建模，然后监控性能指标，分析数据，得出性能结论，验证问题或结论，并总结成方法论；</code></p>
<h1 id="性能流程"><a href="#性能流程" class="headerlink" title="性能流程"></a>性能流程</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">需求分析</span><br><span class="line">设计方案</span><br><span class="line">准备环境</span><br><span class="line">构造数据</span><br><span class="line">业务建模</span><br><span class="line">执行监控</span><br><span class="line">分析优化</span><br><span class="line">结论并验证</span><br><span class="line">方法论落地</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><code>分析性能需求；基于需求做后续的性能工作；这里要明白，性能测试是基于目的+架构+风险的专项测试；常见的性能需求场景如下：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线上出现性能问题，需定位解决；</span><br><span class="line">大促活动等端时高性能需求，需评估性能；</span><br><span class="line">容量规划；</span><br></pre></td></tr></table></figure>

<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p><code>不同性能需求，出发点不一样，故着重点也不一样；设计方案要解决几个问题：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">是什么：测试对象分析（业务/设计/架构）；测试合规指标的制定（预期性能指标（TPS/TIME/性能指标））/性能方案（建模/覆盖/监控/卡点）；人员规划（参与人员/权责/容量成本/时间）；</span><br><span class="line">怎么样：先和业务方（发起方）沟通确定目标、预期这些；同步给相关角色，让他们了解并提前准备；开会同步，确认；</span><br></pre></td></tr></table></figure>
<p><strong>具体实施如下：</strong></p>
<h2 id="性能标准"><a href="#性能标准" class="headerlink" title="性能标准"></a>性能标准</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：可以基于单节点的性能数据和线上比对，判断性能环境的仿真度；卡点、性能指标，超出阈值，则触发异常分析流程；确定一个优化目标，决定什么时候结束；</span><br><span class="line">依据：当前压力，增长、预期情况（二八原则）；竞品的性能数据；线上的性能表现（最近一年峰值，最近三月&#x2F;半年的平均增长率，预估一个1.5年后的压力数据，作为tps预期值）；</span><br><span class="line">具体：QPS达到300&#x2F;top50响应时间不能超过500ms，最大响应时间不能超过2s,平均响应时间200ms以内；（不基于业务和线上数据设计的这个标准并无意义）</span><br></pre></td></tr></table></figure>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p><code>环境最重要的一点是有效性，需要兼顾效果和成本；设计原则如下：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">能用线上环境最优；能兼顾真实性和成本；但需要做好隔离、监控、卡点、恢复，这需要架构支持这种能力，会增加架构和代码设计成本；</span><br><span class="line">维护一个最小集群的云服务的性能镜像环境；优点是和线上隔离了，缺点需要定时同步服务数据，也需要做好隔离和拦截，需要确定有效性；</span><br><span class="line">测试环境做为性能环境；这种基本没有有效性，而且无法量化，只能单纯用来定位问题，但至少也要做到路由控制，持续集成和微服务；</span><br></pre></td></tr></table></figure>
<h2 id="构造数据"><a href="#构造数据" class="headerlink" title="构造数据"></a>构造数据</h2><p><code>造数，需要根据业务特征、设计、数据特点来，常见的造数的方式：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线上快照</span><br><span class="line">代码批量生成</span><br><span class="line">随机数据</span><br></pre></td></tr></table></figure>
<h2 id="业务建模"><a href="#业务建模" class="headerlink" title="业务建模"></a>业务建模</h2><p><code>有两块需要考虑；分析需要覆盖的施压对象，然后仿真施压，具体如下：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户仿真：通过jmeter来仿真施压；施压策略需要考虑（预热、思考时间、分布式施压、依赖数据io对性能影响）；施压方式有两种按固定压力（并发）；按定量的处理能力（TPS）</span><br><span class="line"></span><br><span class="line">IO施压：</span><br><span class="line">MYSQL施压：sysbench(覆盖只读模式/读写混合模式/走或不走索引的模式)</span><br><span class="line">监控：</span><br><span class="line">Redis施压：工具redis-benchmark</span><br></pre></td></tr></table></figure>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/9IEwcYKUy4DeDg6E2hVLTw">MySQL监控</a><ul>
<li><a href="https://mp.weixin.qq.com/s/TjF8stG8UhBm_TZAaChbTA">命令</a></li>
</ul>
</li>
<li>[redis监控]（监控平台）<ul>
<li>[监控命令]（哨兵模式/命令）</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/UHaCLhiIyLYVrba-nEUONA">pprof可视化工具+热力图</a></li>
</ul>
<h2 id="分析优化"><a href="#分析优化" class="headerlink" title="分析优化"></a>分析优化</h2><p><code>分压，动态均衡分配机制，时间换空间，常见的分析优化策略如下：</code></p>
<p><img src="/text_image/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" alt="alt text"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方向：架构、设计、容灾、代码、网络、存储、安全</span><br><span class="line">缓存策略</span><br></pre></td></tr></table></figure>
<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><p>1、广告请求接口耗时过长问题（原因。服务端和大数据过滤策略重叠,redis查询耗时问题）<br>2、网关接口压力太大太重，拆分<br>3、<br><a href="https://mp.weixin.qq.com/s/1Tu0jLK9GfPry_HxP079Lw">性能优化大纲</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建hexo博客</title>
    <url>/posts/8e88d59c/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><span id="more"></span>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、建立github代码库</span><br><span class="line">2、下载hexo文件</span><br><span class="line">3、下载主题，更改配置使主题生效</span><br><span class="line">4、部署配置git</span><br><span class="line">5、下载git同步工具</span><br><span class="line">6、清洗旧数据，生成新的静态文件，同步静态文件至代码库（需更改hexo部署配置）</span><br><span class="line">7、域名解析，并给github代码库配置域名</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://zhuanlan.zhihu.com/p/26625249">参考</a></p>
<ul>
<li>related_posts: true</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据库性能测试</title>
    <url>/posts/ab3091af/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/klb561/p/10513620.html">sysbench对mysql数据库的性能测试</a></p>
]]></content>
  </entry>
  <entry>
    <title>混沌工程</title>
    <url>/posts/7a6c2f74/</url>
    <content><![CDATA[<h1 id="混沌工程"><a href="#混沌工程" class="headerlink" title="混沌工程"></a>混沌工程</h1><ul>
<li><em><strong>介绍</strong></em></li>
</ul>
<p><code>混沌工程是提高分布式系统的稳定性，而进行的一种故障演练测试；具体的方式是向系统注入故障，对比系统稳定时和注入故障后的指标变化；进而评估系统的稳定性和容错能力；</code></p>
<ul>
<li><strong>目录</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">混沌工程是什么</span><br><span class="line">为什么要做混沌工程，应用场景	</span><br><span class="line">怎么样进行混沌工程</span><br><span class="line">长期规划</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<ul>
<li><p><strong>混沌工程是什么?</strong></p>
<p>  <code>混沌工程本质是一种故障演练，通过向系统注入故障的方式，来发现问题，从而提升系统的稳定性；  </code></p>
</li>
<li><p><strong>为什么要做混沌工程，混沌工程的价值？</strong></p>
<p>  <code>由于商业软件，基本都是分布式架构，随着用户的增加，架构的节点也越来越多，越来越复炸；复杂系统很容易由于系统中的一些故障，比如节点挂了，redis挂了，消息队列杜塞，硬盘满了，等问题导致系统能力下降；因此我们需要通过模拟故障的方式来碰撞系统，及早发现问题，减少线上风险；  </code></p>
</li>
<li><p><strong>怎么样进行混沌工程？</strong></p>
<ul>
<li><em><strong>分四步进行</strong></em></li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">先找到一个稳定状态，然后确定稳定态的指标	</span><br><span class="line">确定需覆盖的异常场景，构造异常去碰撞系统</span><br><span class="line">记录系统被碰撞后，相应的指标</span><br><span class="line">将异常态指标和稳定态指标进行对比，分析系统能力是否下降，若下降则代表这个故障未做兼容，需要进行处理</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如何确定稳定态，如何选取指标?</strong></p>
<p>  1、一般是参考线上的稳定状态，作为稳定态；稳定态时，需要选取业务指标和系统指标；具体指标的选取要    基于业务特征来进行，比如我们的产品是一款音乐app,用户使用最多的就是音乐播放，音乐下载；影响较大的      是新增用户量，用户活跃度；</p>
<p>  2、因此我们在选取业务指标时，考虑选取：故障态和稳定态下的，音乐播放数/音乐下载数/听歌人数/新增用      户数/用户留存率/用户的活跃度作为业务指标；</p>
<p>  3、在确定系统指标时，我们需要具体分析，碰撞的故障，可能影响系统的指标和相应的节点，来监控相应指    标的变化；同时需要分析这种变化对系统业务的影响；</p>
</li>
<li><p><strong>如何确定碰撞的异常场景，如何进行碰撞？</strong></p>
<ul>
<li><p>异常场景的确认一般是有两种途径；分析系统特征来提取可能的故障/利用线上历史的故障，常见故障有：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU 高负载</span><br><span class="line">磁盘高负载：频繁读写磁盘</span><br><span class="line">磁盘空间不足</span><br><span class="line">优雅的下线应用：使用应用的 stop 脚本平滑的停止应用</span><br><span class="line">通过 kill 进程直接停止应用，可能造成数据不一致</span><br><span class="line">网络恶化：随机改变一些包数据，使数据内容不正确</span><br><span class="line">网络延迟：将包延迟一个特定范围的时间</span><br><span class="line">网络丢包：构造一个 tcp 不会完全失败的丢包率</span><br><span class="line">网络黑洞：忽略来自某个 ip 的包</span><br><span class="line">外部服务不可达：将外部服务的域名指向本地环回地址或将访问外部服务的端口的 OUTPUT 数据包丢弃</span><br></pre></td></tr></table></figure></li>
<li><p>由于混沌工程是对系统健壮性进行的测试，因此需保证系统的真实性，最好利用线上的系统来进行</p>
<p>  <code>  1、利用线上系统进行混沌工程，需保证系统节点的容量可调度，可控；选取较小可控的节点来进行混沌            工程；   2、进行混沌工程需保证影响可控，可恢复；要保证对线上的业务无影响；  </code></p>
</li>
</ul>
</li>
<li><p><strong>进行混沌工程的主流工具</strong></p>
<p>  <code>     大厂基本都有自研的混沌工程的工具，现在国内开源的工具热度最高的是:  </code></p>
<p>  <a href="https://github.com/chaosblade-io/chaosblade/blob/master/README_CN.md">阿里的chaosblade</a></p>
<p>  <a href="https://github.com/chaos-mesh/chaos-mesh">云原生计算基金会托管的Chaos Mesh</a></p>
<p>  <a href="https://github.com/dastergon/awesome-chaos-engineering">混沌工程相关的资料–AWS</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>混沌工程</tag>
      </tags>
  </entry>
  <entry>
    <title>用例管理平台</title>
    <url>/posts/c48e9a83/</url>
    <content><![CDATA[<p><a href="https://github.com/didi/AgileTC/blob/master/README_zh-CN.md">用例管理平台agiletc</a></p>
]]></content>
  </entry>
  <entry>
    <title>百度质量体系建设</title>
    <url>/posts/bcd76c52/</url>
    <content><![CDATA[<h1 id="百度质量体系建设"><a href="#百度质量体系建设" class="headerlink" title="百度质量体系建设"></a>百度质量体系建设</h1><ul>
<li><em><strong>介绍</strong></em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本系列介绍百度质量体系建设的核心理念，体系建设过程，以及具体的实操方案</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>目录</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">质量的评判标准</span><br><span class="line">质量体系建设	</span><br><span class="line">质量贴合业务</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>稳定性治理--智能遍历</title>
    <url>/posts/e80d13a0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>智能遍历，即通智能化的规则来访问APP的UI页面；之所以要考虑这种方式，主要是monkey随机测试，随机性太强，覆盖率不好衡量；不方便进行版本之间的对比，因此考虑其他智能遍历方案，备选的有三种方案“UI自动化实现/appcrawler自动遍历/fastbot智能遍历”</code></p>
<span id="more"></span>
<h1 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h1><ul>
<li><p><strong>UI自动化实现</strong></p>
<ul>
<li><em>优点</em><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定制化程度高，可控</span><br><span class="line">可进行持续集成</span><br></pre></td></tr></table></figure></li>
<li><em>缺点</em><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工作量大，稳定性差，实现难度高</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>appcrawler自动遍历</strong></p>
<ul>
<li><em>优点</em><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">覆盖率高，利用类爬虫机制能进行深度遍历，基本覆盖所有的页面</span><br><span class="line">可进行策略定制，灵活性较高，使用成本较低</span><br><span class="line">执行有HTML结果，支持Android和iOS渠道</span><br><span class="line">支持持续集成；</span><br></pre></td></tr></table></figure></li>
<li><em>缺点</em><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行策略和版本数据相关性不大,无法利用历史策略数据</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>fastbot智能遍历</strong></p>
<ul>
<li><em>优点</em><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">覆盖率高，且有覆盖率指标，进行智能遍历，遍历策略较智能（每次遍历都会建模，利用深度学习会持续优化模型，作为驱动策略），现实意义较强；</span><br><span class="line">可进行定制，灵活度较高，使用成本较低；</span><br><span class="line">支持iOS和Android渠道；</span><br><span class="line">可利用数据驱动，方便进行版本间的迭代，方便优化驱动策略；</span><br><span class="line">支持持续集成；</span><br><span class="line">利用monkey来遍历，执行较快，效率高；</span><br><span class="line">支持非标准化控件，可以利用图像识别来进行断言；</span><br><span class="line">每次的模型可复用，模型文件会自动存储在 /sdcard/fastbot_[包名].fbm，换设备或者版本可复用原有模型，保证策略完全一致；只需要放在相同的位置即可；</span><br><span class="line">支持多设备</span><br></pre></td></tr></table></figure></li>
<li><em>缺点</em><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要第三方工具，进行性能监控，本身不支持；</span><br><span class="line">无结果报告，只有打印的覆盖率指标，同时只有异常日志；</span><br><span class="line">后期可能会收费，一旦收费，建议转solopi或者自研；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>综合考虑，最终决定采用fastbot，其中很大一个原因是其支持数据驱动，方便持续优化策略，同时据同事说shein也在使用；</p>
<h2 id="fastBOT使用"><a href="#fastBOT使用" class="headerlink" title="fastBOT使用"></a><em><strong>fastBOT使用</strong></em></h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装/部署</span><br><span class="line">使用指令</span><br><span class="line">定制策略</span><br><span class="line">优化策略</span><br><span class="line">结果分析</span><br><span class="line">性能采集</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>安装/部署</strong></p>
<ul>
<li><em>部署Java环境</em><ul>
<li><a href="https://www.oracle.com/java/technologies/downloads/#jdk18-windows">下载java jdk</a></li>
<li>配置Java环境变量：在系统变量中对JAVA_HOME、PATH、CLASSPATH进行配置：<ul>
<li>JAVA_HOME:C:\Program Files (x86)\Java\jdk1.8.0_91</li>
<li>PATH:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</li>
<li>CLASSPATH:.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</li>
</ul>
</li>
</ul>
</li>
<li><em>部署Android环境</em><ul>
<li>先部署Java环境</li>
<li><a href="https://developer.android.google.cn/studio">安装Android studio</a></li>
<li>通过Android studio 安装对应版本的Android sdk</li>
<li>添加Android环境变量：系统变量中添加ANDROID_HOME，PATH：<ul>
<li>ANDROID_HOME:C:\Users\gavin\AppData\Local\Android\Sdk</li>
<li>PATH:%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools;C:\Users\gavin\AppData\Local\Android\Sdk\build-tools\32.0.0（aapt命令的环境变量，其是apk解析程序）        </li>
</ul>
</li>
</ul>
</li>
<li><em>将jdk包，pull到手机</em><ul>
<li>adb push * .jar /sdcard</li>
<li>adb push libs/ * /data/local/tmp/</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用指令</strong></p>
<ul>
<li><em>举例：</em></li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOS:tidevice xctest -B bytedance.FastbotRunner112.xctrunner -e 	BUNDLEID:com.TranssnetMusic.Boomplay -e duration:120 -e throttle:300 --debug</span><br><span class="line"></span><br><span class="line">ANDROID:adb -s 037952588D000392 0442233974160287 shell CLASSPATH&#x3D;&#x2F;sdcard&#x2F;monkeyq.jar:&#x2F;sdcard&#x2F;framework.jar:&#x2F;sdcard&#x2F;fastbot-thirdpart.jar exec app_process &#x2F;system&#x2F;bin com.android.commands.monkey.Monkey -p com.afmobi.boomplayer --agent reuseq --running-minutes 240 --throttle 500 -v -v --output-directory &#x2F;sdcard&#x2F;fast_data</span><br></pre></td></tr></table></figure>

<ul>
<li><em>参数说明</em></li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">必填参数：</span><br><span class="line">-s imei imei2:支持多设备</span><br><span class="line">-p package_name:str；“adb shell pm list package”可获取APP包名</span><br><span class="line">--agent reuseq	：遍历模式，无需更改</span><br><span class="line">--running-minutes 120：遍历时长，单位是min</span><br><span class="line">--throttle 500：和monkey中的--throttle相同，为事件频率，建议500-800</span><br><span class="line">选填参数：</span><br><span class="line">--bugreport ：<span class="comment">#发生崩溃时打印的日志</span></span><br><span class="line">--output-directory ： /sdcard/xxx <span class="comment">#输出目录的文件夹</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定制策略</strong></p>
<ul>
<li><em>限定词</em><br><code>限定自动化定位到的文本只能是apk字符串池中出现的文本，否则抛出异常</code>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：</span><br><span class="line">aapt2 dump strings apk路径 &gt; max.valid.strings :将apk中所有的字符创，加入到限定词文档</span><br><span class="line">adb push max.valid.strings &#x2F;sdcard:配置文件需要push到sdk卡才能生效</span><br></pre></td></tr></table></figure></li>
<li><em>自定义事件执行顺序</em><br><code>应用于需要自定义执行顺序的场景（如登录），或者要保证一定要覆盖到的核心场景,实现方式如下：</code></li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在pc端新建 max.xpath.actions 文件</span><br><span class="line">编写事件序列的<span class="keyword">case</span>，参考我提供的max.xpath.actions文件，文件编写好之后push到/sdcard的根目录；举例说明：</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;prob&quot;</span>:1,										//事件发生概率，实际使用注释文件要删掉</span><br><span class="line"><span class="string">&quot;activity&quot;</span>:<span class="string">&quot;com.boomplay.ui.main.MainActivity&quot;</span>,	//作用的页面</span><br><span class="line"><span class="string">&quot;times&quot;</span>:1,										//重复次数</span><br><span class="line"><span class="string">&quot;actions&quot;</span>:[										//具体步骤的执行,同时支持多个操作</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;xpath&quot;</span>:<span class="string">&quot;//*[@text=&#x27;Charts&#x27;]&quot;</span>,			//尽量使用resource-id作为xpath路径，也可以组合使用比如<span class="string">&quot;xpath&quot;</span>: <span class="string">&quot;//*[@resource-id=&#x27;xxx&#x27;and @text=&#x27;xx&#x27;]&quot;</span></span><br><span class="line">		<span class="string">&quot;action&quot;</span>:<span class="string">&quot;CLICK&quot;</span>,						//动作支持的操作，必须大写（CLICK，LONG_CLICK，BACK，SCROLL_TOP_DOWN，SCROLL_BOTTOM_UP，SCROLL_LEFT_RIGHT，SCROLL_RIGHT_LEFT）</span><br><span class="line">		<span class="string">&quot;text&quot;</span>: <span class="string">&quot;打开页面成功&quot;</span>,</span><br><span class="line">		<span class="string">&quot;clearText&quot;</span>:<span class="literal">false</span>,						//明文，可不带</span><br><span class="line">		<span class="string">&quot;throttle&quot;</span>:5000							//action间隔事件（ms）					</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;xpath&quot;</span>:<span class="string">&quot;//*[@text=&#x27;Artists&#x27;]&quot;</span>,</span><br><span class="line">		<span class="string">&quot;action&quot;</span>:<span class="string">&quot;CLICK&quot;</span>,</span><br><span class="line">		<span class="string">&quot;throttle&quot;</span>:5000&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;,												//到不同的activity操作，需要新起一个对象</span><br><span class="line">&#123;								</span><br><span class="line"><span class="string">&quot;prob&quot;</span>:1,</span><br><span class="line"><span class="string">&quot;activity&quot;</span>:<span class="string">&quot;com.boomplay.ui.guide.GuideDialogSearchActivity&quot;</span>,</span><br><span class="line"><span class="string">&quot;times&quot;</span>:1,</span><br><span class="line"><span class="string">&quot;actions&quot;</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;xpath&quot;</span>:<span class="string">&quot;//*[@text=&#x27;Charts&#x27;]&quot;</span>,</span><br><span class="line">		<span class="string">&quot;action&quot;</span>:<span class="string">&quot;CLICK&quot;</span>,</span><br><span class="line">		<span class="string">&quot;text&quot;</span>: <span class="string">&quot;打开页面成功&quot;</span>,</span><br><span class="line">		<span class="string">&quot;clearText&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">		<span class="string">&quot;throttle&quot;</span>:5000</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;xpath&quot;</span>:<span class="string">&quot;//*[@text=&#x27;Artists&#x27;]&quot;</span>,</span><br><span class="line">		<span class="string">&quot;action&quot;</span>:<span class="string">&quot;CLICK&quot;</span>,</span><br><span class="line">		<span class="string">&quot;throttle&quot;</span>:5000&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>配置白名单</em><br><code>作用：定制策略只在白名单页面内进行操作</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：</span><br><span class="line">新建 awl.strings文件</span><br><span class="line">在文件中写入Activity的名称，如：com.boomplay.ui.main.MainActivity</span><br><span class="line">将文件push到手机&#x2F;sdcard路径下，使用时，在执行命令尾部添加：</span><br><span class="line">--act-whitelist-file &#x2F;sdcard&#x2F;awl.strings</span><br></pre></td></tr></table></figure></li>
<li><p><em>配置黑名单</em><br><code>作用：定制策略不允许访问黑名单页面</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：</span><br><span class="line">新建 abl.strings文件</span><br><span class="line">在文件中写入Activity的名称，如：com.boomplay.ui.main.MainActivity</span><br><span class="line">将文件push到手机&#x2F;sdcard路径下，使用时，在执行命令尾部添加：</span><br><span class="line">--act-blacklist-file &#x2F;sdcard&#x2F;abl.strings</span><br></pre></td></tr></table></figure>
<p><em><strong>黑白名单不能同时配置，非黑即白</strong></em></p>
</li>
<li><p><em>定制需要屏蔽的按钮/区域</em><br><code>作用：如登防止登录后，中途退出</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    新建max.widget.black文件，文件配置后，push到&#x2F;sdcard路径下</span><br><span class="line">    [</span><br><span class="line">&#123;</span><br><span class="line">    &quot;activity&quot;:&quot;com.ss.android.xxx.MainActivity&quot;,</span><br><span class="line">    &quot;xpath&quot;: &quot;&#x2F;&#x2F;*[@resource-id&#x3D;&#39;com.xxx.go:id&#x2F;aaa&#39;]&quot;&#x2F;&#x2F;通过元素控制不让访问</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;activity&quot;:&quot;com.ss.android.xxx.MainActivity&quot;,</span><br><span class="line">    &quot;bounds&quot;: 0.5									&#x2F;&#x2F;activity区域内50%区域不被点击，值为0-1</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><em>通过tree屏蔽</em><br><code>原理配置xpath：查找匹配的控件，改变控件属性，从而使控件屏蔽</code></p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建max.tree.pruning文件，文件配置完后，push到&#x2F;sdcard路径下</span><br><span class="line">配置实例：建github提供的文件参考配置</span><br></pre></td></tr></table></figure>
<ul>
<li><em>定制事件中模糊事件/突发性事件的占比</em><br><code>所谓的模糊事件，是指执行某个操作后（定制的action事件），模型会根据这个操作生成5-10个相关的操作的策略</code></li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在max.config文件中增加模糊性事件，在总的事件中的占比，配置完成后，push到&#x2F;sdcard路径</span><br><span class="line">max.fuzzingRate &#x3D; 0.01D &#x2F;&#x2F;0.01为Fuzz事件的总概率</span><br><span class="line">模糊事件，包含以下事件，（数字为配置事件在模糊性事件中的概率，以下数值为默认值，可定制）： </span><br><span class="line">	max.doRotateFuzzing &#x3D; 0.15</span><br><span class="line">	max.doAppSwitchFuzzing &#x3D; 0.15</span><br><span class="line">	max.doTrackballFuzzing &#x3D; 0.15</span><br><span class="line">	max.doNavKeyFuzzing &#x3D; 0.15</span><br><span class="line">	max.doKeyCodeFuzzing &#x3D; 0.15</span><br><span class="line">	max.doSystemKeyFuzzing &#x3D; 0.15</span><br><span class="line">	max.doDragFuzzing &#x3D; 0.5</span><br><span class="line">	max.doPinchZoomFuzzing &#x3D; 0.15 </span><br><span class="line">	max.doClickFuzzing &#x3D; 0.7</span><br><span class="line">在max.config文件中增加随机性事件（monkey随机性事件），在总的事件中的占比，配置完成后push到&#x2F;sdcard路径下</span><br><span class="line">max.startMutation &#x3D; 0.3D &#x2F;&#x2F;启动Fastbot立刻设置mutation的几率，默认30%</span><br><span class="line">随机性事件，包含以下事件，(数字为默认概率，此概率为事件总概率，可定制)：</span><br><span class="line">	max.doMutationAirplaneFuzzing &#x3D; 0.001</span><br><span class="line">	max.doMutationMutationAlwaysFinishActivitysFuzzing &#x3D; 0.1</span><br><span class="line">	max.doMutationWifiFuzzing &#x3D; 0.001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化策略</strong></p>
<ul>
<li><em>输入内容优化</em><br><code>输入是用户主观意愿很强的行为，为保证输入的内容是有价值的，更添近真实场景，在覆盖输入场景做一些策略优化，以屏蔽乱输入内容</code></li>
<li><em>操作</em></li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用ADBKeyBoard在输入栏自动输入内容，屏蔽UI输入法：UI输入法，不同终端使用不同的输入法，不稳定（安装部署adbkeyboard见下方内容，基本所有的开源的自动化工具在输入这块都会封装输入法，为了方便复用和稳定，不建议调用手机的输入法）；</span><br><span class="line">输入随机字符串：pc建一个max.config文件；配置 max.config 中 max.randomPickFromStringList &#x3D; false，最后将文件push到手机的&#x2F;sdcard目录下；</span><br><span class="line">从文件中随机读取字符串来输入：pc建一个max.config文件；配置 max.config 中 max.randomPickFromStringList &#x3D; true，然后在建一个max.strings文件，里面放用来输入的字符串（每一行为一个对象）；最后将max.config和max.strings文件push到手机的&#x2F;sdcard目录下；</span><br><span class="line">模糊输入：模糊输入和随机输入有点类似，不过有限定范围，fastbot模糊输入的限定规则如下：</span><br><span class="line">	50% 概率输入fuzzing.strings中某个string</span><br><span class="line">	35% 概率输入被测试 App 历史页面中text&#x2F;desc文本内容（不存在max.fuzzing.strings文件时概率提高到85%）</span><br><span class="line">	15% 概率不输入</span><br><span class="line">使用文件限定的模糊输入：将git项目中的test&#x2F;max.fuzzing.strings文件push到手机&#x2F;sdcard下，此文件存在模糊搜索策略及生效，文件里放想输入的字符串；</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><p>部署adbkeyboard</p>
<ul>
<li>[下载开源包]（<a href="https://github.com/senzhk/ADBKeyBoard/archive/refs/heads/master.zip%EF%BC%89">https://github.com/senzhk/ADBKeyBoard/archive/refs/heads/master.zip）</a></li>
<li>进入项目目录cd ADBKeyBoard</li>
<li>设置环境变量 export ANDROID_HOME=$HOME/Android/Sdk</li>
<li>在保证手机连接电脑，且赋予debug权限情况下，执行安装命令./gradlew installDebug</li>
<li>如果以上方式无法安装，请安装apk包：<a href="https://github.com/senzhk/ADBKeyBoard/raw/master/ADBKeyboard.apk">地址</a></li>
</ul>
</li>
<li><p><em>apk反混淆</em><br><code>是什么：混淆指的是Java混淆编译，用以防止对源码的反编译破解；反混淆，类似于解密;使得配置在 不同版本的App中可以通用 </code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置混淆映射文件max.mapping，push到手机&#x2F;sdcard中，以建立混淆前后ID映射关系：</span><br><span class="line">adb push resguard_mapping_NewsArticle_beta_version_v7.2.x_?????.txt &#x2F;sdcard&#x2F;max.mapping</span><br><span class="line">配置反混淆文件，以自定义事件为例，在 max.xpath.actions 中配置混淆前的 resource-id，参考示例文件</span><br></pre></td></tr></table></figure></li>
<li><p><em>测试过程中自动截图</em><br><code>场景：当--throttle 事件频率&gt;200时，配置了截图，会对测试过程中页面进行截图</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建max.config配置文件，增加以下属性，配置完成后文件push到&#x2F;sdcard路径下</span><br><span class="line">max.takeScreenshot &#x3D; true</span><br><span class="line">max.takeScreenshotForEveryStep &#x3D; true</span><br><span class="line">max.saveGUITreeToXmlEveryStep &#x3D;true</span><br><span class="line">目录默认保存为手机端sdcard中，如需改变保存位置，在执行命令末尾添加 --output-directory 指定路径</span><br></pre></td></tr></table></figure></li>
<li><p><em>支持外链跳转</em><br><code>支持第三方的外链跳转，跳转到第三方应用，或者跳转到端内页面</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建max.schema文件，增加配置如下，文件配置完后，push到&#x2F;sdcard路径下</span><br><span class="line">max.execSchema &#x3D; true</span><br><span class="line">max.execSchemaEveryStartup  &#x3D; true  #每次启动app先执行schema</span><br></pre></td></tr></table></figure></li>
<li><p><em>应用自动授予权限</em><br><code>如boomplay需要获取通讯录/相机权限，fastbot启动时默认会一次性各所有权限，如需每次动态给权限，需要更改配置</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在max.config中增加以下配置，则不会自动给所有权限；文件配置完之后push到&#x2F;sdcard路径下</span><br><span class="line">max.grantAllPermission &#x3D; false</span><br><span class="line">动态给权限的方式是，在执行的adb命令尾部增加对应的android权限授予的指令：</span><br><span class="line">-p com.android.packageinstaller </span><br><span class="line">-p com.android.permissioncontroller</span><br><span class="line">-p com.lbe.security.miui  # for (miui android 10)</span><br><span class="line">-p com.samsung.android.permissioncontroller #  for (samsung android 10)</span><br></pre></td></tr></table></figure></li>
<li><p><em>fastbot压缩包提供了各类素材，用以在执行选取各类素材的场景中使用，如发带图片的buzz</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push data&#x2F;fuzzing&#x2F; &#x2F;sdcard</span><br><span class="line">adb shell am broadcast -a android.intent.action.MEDIA_SCANNER_SCAN_FILE -d file:&#x2F;&#x2F;&#x2F;sdcard&#x2F;fuzzing</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>结果分析</strong></p>
<ul>
<li>异常数据<br>  crash：Crash会以追加方式写入/sdcard/crash-dump.log文件<br>  anr：写入 /sdcard/oom-traces.log 文件</li>
<li>覆盖率统计：coverage = testedActivity / totalActivities * 100<br>  testedActivity:本次测试的activity,会打印出来<br>  totalActivities:总的activity，会打印出来<br>  以上的所有activity，是不区分废弃，或者未使用的activity，为APP的所有的activity</li>
</ul>
</li>
<li><p><strong>性能采集</strong><br><code>性能采集，主要是采集内存/CPU的数据，从而来分析APP执行case时的性能</code></p>
</li>
</ul>
<ul>
<li><p><em>方法一</em></p>
<p>  通过火山提供的APP性能分析工具进行监控：<a href="https://www.volcengine.com/docs/6431/82895">工具地址</a>（火山引擎开始收费了，工具现在虽然免费，不排除未来收费，有使用风险）</p>
</li>
<li><p><em>方法二</em></p>
<p>  借助其他的性能数据抓取工具,比如 OneApm, NewRelic（付费）；或者支付宝的solopi；使用第三方工具可能会对结果有影响，最好能统一场景，保证结果一致；</p>
</li>
</ul>
<ul>
<li><strong>常用操作</strong></li>
</ul>
<ul>
<li><p><em>获取APP包名</em></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aapt dump badging apk_path</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>使用<a href="https://github.com/zhangzhao4444/Maxim">maxim</a>获取APPactivity</em></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell CLASSPATH&#x3D;&#x2F;sdcard&#x2F;monkey.jar:&#x2F;sdcard&#x2F;framework.jar exec app_process &#x2F;system&#x2F;bin tv.panda.test.monkey.api.CurrentActivity 注意里面的文件需要push到手机对应的位置后才能使用</span><br></pre></td></tr></table></figure></li>
<li><p><em>使用<a href="https://github.com/zhangzhao4444/Maxim">maxim</a>查看当前页面的TREE结构，来获取配置需要id等。。</em></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell CLASSPATH&#x3D;&#x2F;sdcard&#x2F;monkey.jar:&#x2F;sdcard&#x2F;framework.jar exec app_process &#x2F;system&#x2F;bin tv.panda.test.monkey.api.Dumptree</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>常见问题，查看帮助文档</em></p>
<ul>
<li><a href="https://github.com/bytedance/Fastbot_Android/blob/main/handbook-cn.md#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题点这里</a></li>
<li><a href="https://github.com/bytedance/Fastbot_Android/issues">其他问题可以看下issue里找下</a></li>
<li><a href="https://github.com/bytedance/Fastbot_Android/blob/main/handbook-cn.md">官方文档点这里</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>稳定性治理-暴力回放</title>
    <url>/posts/81de0e43/</url>
    <content><![CDATA[<p><code>暴力回放，是指重复执行某些操作；这种重复执行主流程操作，能极大程度的覆盖主流程的功能，保证系统核心功能的质量；</code></p>
<h4 id="覆盖场景"><a href="#覆盖场景" class="headerlink" title="覆盖场景"></a>覆盖场景</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">music首页，点击歌单播放按钮播放，然后息屏进入后台，10s后切换回前台；</span><br><span class="line">music首页，点开播放列表，然后点击music播放音乐，然后关闭播放列表，然后切换到后台，10s后切换回前台；</span><br><span class="line">music首页，进入歌单，点击全部播放，点击全部下载，然后返回首页，上下滑动一屏，然后切换回后台，10s后切换回前台；</span><br><span class="line">music首页，点击头像登录，退出，切换到后台，10s后切换回前台；</span><br><span class="line">treding首页，点击任意music播放，切换到后台，10s后回到前台，关闭播放详情页；</span><br><span class="line">首页，滑动到treding页，上下滑动一屏；然后向左滑动一屏，上下滑动一屏，然后向左滑动一屏，上下滑动一屏,然后向左滑动一屏，上下滑动一屏,然后切换到后台，停留10s;然后点击导航页到library页，然后点击导航页到search页，然后点击导航页到music页；</span><br><span class="line">搜索页，搜索music，搜索结果页左右滚动一屏；点击结果页播放，然后切换到后台休眠10s,在切换回前台;</span><br><span class="line">首页，点击导航页进入library页；点击进入喜欢的music页，点击全部播放；然后切换到后台，停留10s，在切换回前台，退出music页，切换回首页；</span><br><span class="line">首页，切换到buzz页；上下滑动两屏，点击buzz关注按钮，buzz点赞，buzz评论，点击查看buzz详情，然后回退到buzz页，然后在切换到后台，休眠10s，在切换回前台；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>暴力回放</tag>
      </tags>
  </entry>
  <entry>
    <title>稳定性治理</title>
    <url>/posts/a30df9c8/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">概述，目的？</span><br><span class="line">怎么进行稳定性治理，稳定性治理的体系建设？</span><br><span class="line">稳定性治理的过程？</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>稳定性治理概述，目的？</strong></p>
<p><code>稳定性是系统最核心的需求；稳定性包含最核心的，系统服务的稳定性和前端的稳定性；稳定性核心有两大快，一是系统稳定，在复杂的环境下能稳定运行；二是抛出异常能及时处理，降低异常带来的风险；本文的稳定性治理，主要考虑的是通过模仿异常环境下系统运行，及时发现问题，解决问题，提升系统的稳定性；</code></p>
<p><strong>怎么进行稳定性治理，稳定性治理体系的建设？</strong></p>
<p><code>稳定性治理，首要目标，是要确认稳定性的衡量指标；其次要具有构造仿真环境的能力，在复杂环境下要具有系统监控能力，同时整个体系要能实现自动化运行维护具有平台能力。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">稳定性衡量指标？</span><br><span class="line">稳定性环境监控？</span><br><span class="line">稳定性测试策略？</span><br><span class="line">自动化稳定性平台建设？</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em><strong>稳定性衡量指标?</strong></em><br><code>系统稳定；一般是指系统在定义的状态下稳定运行，且长时间不会出现异常状态,常见的异常如下：</code></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">崩溃率</span><br><span class="line">anr</span><br><span class="line">内存泄露</span><br><span class="line">oom</span><br><span class="line">系统性能</span><br></pre></td></tr></table></figure>
<ul>
<li><em>崩溃率</em><br><code>崩溃是稳定性的最大对手；通常关注的崩溃是crash；关注崩溃率，一般关注日崩溃率和崩溃用户率； </code><ul>
<li>日崩溃率=日崩溃次数/日打开总次数        合规标准：0.2%</li>
<li>崩溃用户数=去重的崩溃用户数/日活跃用户数    合规标准：0.2%</li>
</ul>
</li>
<li><em>anr</em><br><code>anr即(Application Not Response);常会直接暴露给用户，照成不好影响;</code></li>
<li><em>内存泄露</em><br><code>系统占用的堆内存未及时释放或无法释放，从而导致占用的内存一直递增，从而导致环境资源不足;</code></li>
<li><em>oom</em><br><code>app申请的内存超过最大内存的限制，系统不分配内存，导致程序崩溃;</code></li>
<li><em>系统性能</em><br><code>指在不同场景下对系统或环境的资源消耗进行监控，常监控系统资源和消耗的资源;</code></li>
</ul>
</li>
<li><p><em><strong>系统稳定性监控？</strong></em></p>
<p>  <code>系统稳定，说明系统在全局环境下，都能长期稳定的运行；揭释了稳定性检测的核心的几个点，异常环境构造，稳定运行指标监控，长期稳定性；</code></p>
<ul>
<li><em>稳定性指标</em><br><code>本文的指标监控，仅对前端的相关的指标进行监控；后端服务的监控，有运维在做;</code><ul>
<li><p>服务及时响应/且响应参数无误</p>
<ul>
<li>场景：如接口监控，特指对后端服务进行监控;</li>
<li>指标：一般监控服务相关指标（如接口响应时间/参数准确性）,资源监控（cpu/内存/带宽/io），消耗资源（流量/电量）;</li>
<li>方案：可通过仅触发服务的方式，仅对服务进行监控，如接口自动化；可通过前端触发服务来实现监控，如ui自动化实现接口覆盖；系统资源消耗可通过监控系统资源文件获取；系统监控可通过后端方案实现，如prometheus；</li>
</ul>
</li>
<li><p>前端加载时间满足用户体验/呈现无误</p>
<ul>
<li>场景：触发前端场景，来实现对产品提供给用户的服务进行监控；</li>
<li>指标：页面加载时间/页面UI测试/前端资源检测；</li>
<li>方案：可通过UI自动化，UI遍历等方式实现；数据采集可通过获取activity的响应时间获取；UI测试可通过telescop植入性来实现；</li>
</ul>
</li>
<li><p>前端稳定性</p>
<ul>
<li>场景：稳定性是最核心的指标，稳定指服务稳定不崩溃，不抛出异常；</li>
<li>指标：<ul>
<li>crash率：通过监控crash文件进行采集；</li>
<li>anr率：通过监控anr文件进行采集；</li>
<li>内存泄露：通过LeakCanary监控内存泄露,通过haha来解析hprf文件，来分析Java虚拟机的内存使用清空；</li>
<li>hprf:hprof最初是由J2SE支持的一种二进制堆转储格式，hprof文件保存了当前java堆上所有的内存使用信息，能够完整的反映虚拟机当前的内存状态；</li>
<li>oom：通过字节的tailor来进行监控；</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247487203&idx=1&sn=182584b69910c843ae95f60e74127249&chksm=e9d0c501dea74c178e16f95a2ffc5007c5dbca89a02d56895ed9b05883cf0562da689ac6146b&scene=178&cur_album_id=1590413073616519171#rd">oom问题监控</a></li>
<li>方案<ul>
<li>稳定性在不同的场景下有着不同的表现；可以通过这些方式来实现场景的覆盖；ui遍历/暴力回放/monkey测试/流量回放；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其他监控</p>
<ul>
<li>场景：除了上述指标外，我们还会对以下指标进行监控，以评估对系统的影响;</li>
<li>指标：<ul>
<li>UI资源监控：图片过大/图片持有/过度绘制/资源泄露/过度布局</li>
<li>线程阻塞</li>
<li>文件创建</li>
<li>线程创建</li>
<li>主线程io</li>
<li>启动性能</li>
</ul>
</li>
<li>方案：使用telescop的植入性和监控能力来监控；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>稳定性测试策略？</strong></em><br><code>稳定性测试时，有几个核心待解决的问题；如何解决真实环境下各种复杂环境的覆盖？如何保证效率，实现低投入高产出？如何保证采集的指标和问题场景结合，快速复现？</code></p>
<ul>
<li><p><em>如何保证覆盖率？覆盖率是如何计算的？</em><br><code>稳定性治理，在复杂环境下要保证全覆盖时不可能实现的工作；因此我们考虑实现一种可迭代优化的机制保证覆盖，保障系统的稳定，通常我们考虑系统覆盖时，从页面覆盖和代码逻辑的覆盖来实现;</code></p>
<ul>
<li>覆盖率指标：<ul>
<li>页面场景覆盖：activity覆盖70%；覆盖所有的一级页面和所有的核心二级页面以及所有的主流程相关的三四级页面；覆盖所有的核心业务流程；</li>
<li>代码行覆盖：可通过白盒走查或者代码检测工具；单测实现代码的覆盖；覆盖所有核心流程和代码的核心处理逻辑；</li>
</ul>
</li>
<li>覆盖率保障策略：<ul>
<li>终端覆盖：设备信息采集，通过埋点采集线上设备数据；至少要保证top10的设备能实现覆盖；保障top5系统版本能实现覆盖；top5-10的os版本能实现覆盖；</li>
<li>预装版本：最好能实现需预装的机型的覆盖；否则至少要保证覆盖前一个机型，相同配置的版本的设备不低于10台；</li>
<li>需要有问题统计/上报机制；能收集线上问题进行统计归纳，方便策略的设计和混度工程的实现；</li>
<li>覆盖所有的核心链路，及70%的页面（所有一级页面，所有核心二级页面，所有核心三级页面）</li>
<li>时间：看具体的策略，monkey一般不低于一天，也就是8小时；</li>
</ul>
</li>
</ul>
</li>
<li><p><em>测试方式？各种方式的优缺点？</em></p>
<ul>
<li><p>UI遍历测试<br>  <code>UI遍历，指利用爬虫和过滤策略，实现从头遍历所有页面；</code></p>
<ul>
<li>优点：实现所有流程/页面的覆盖，能保证较高的覆盖率；</li>
<li>缺点：耗时太久，无法模仿真实的用户操作，对测试版本或者测试环境有要求；很难构造高压力的场景；</li>
<li>方案：AppCrawler实现；</li>
</ul>
</li>
<li><p>暴力回放<br><code>暴力回放，指通过频繁对某些场景进行循环操作，来实现对核心场景的覆盖，此策略传音要求必须要做;</code></p>
<ul>
<li>优点：可对核心场景进行大量覆盖，保证核心链路无误；</li>
<li>缺点：能覆盖的场景有限，耗时较长；较难覆盖到特殊场景；</li>
<li>场景：通过UI自动化脚本实现循环遍历；</li>
</ul>
</li>
<li><p>monkey随机遍历<br><code>monkey是Android自带的稳定性治理的工具，也是稳定性治理的核心方式，能模仿用户进行随机性的点击操作；</code></p>
<ul>
<li>优点：实现简单，有较强的随机性，能发现一些特殊问题；</li>
<li>缺点：过于随机，不能保证覆盖率，无法模仿真实用户的操作；</li>
<li>方案：针对monkey过于随机的缺陷，为保证效率，可对monkey的策略进行定制化，具体实现如下：<ul>
<li>通过黑名单策略，跳过低频操作（如新手引导、权限类操作、关闭输入法，屏蔽其他应用的activity减少无效操作）；</li>
<li>通过白名单策略，定制执行的activity和app,减少无效操作；</li>
<li>定制事件比例，提高测试效率；</li>
<li>执行时间，一般不低于一天，也就是8小时；</li>
</ul>
</li>
</ul>
</li>
<li><p>线上流量回放<br><code>线上流量回放，指利用线上的日志数据记录的用户行为，作为源数据来建模，模仿用户操作;</code></p>
<ul>
<li>优点：覆盖大量的真实用户操作，case有效性高，针对性强；</li>
<li>缺点：需要利用大量的线上日志，对系统的要求高；利用线上日志进行回放，实现难度大；利用线上用户数据，会存在隐私安全问题；</li>
<li>方案：可使用头条的智能化monkey工具，fastbot;</li>
</ul>
</li>
</ul>
</li>
<li><p><em>具体实现，如何保证效率？</em><br><code>结合上诉几种方案的优缺点，可知，最好能四种方案结合着使用；</code></p>
<ul>
<li>新发功能版本：最好先执行一遍UI遍历（冒烟）/monkey遍历（每日）/流量回放（bug修复版本）</li>
<li>RC版本：可执行流量回放/暴力回放</li>
<li>预装版本：可执行流量回放/暴力回放</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>自动化稳定性平台的建设</strong></em></p>
</li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s/L7RTCzqQ-1GbNhMNHONdRw"><strong>阿里稳定性治理</strong></a></li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1MzYzMjE0MQ==&action=getalbum&album_id=1590413073616519171&scene=173&from_msgid=2247487203&from_itemidx=1&count=3&nolastread=1#wechat_redirect"><strong>头条稳定性治理系列</strong></a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>头条</tag>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>算法--数据结构1️⃣</title>
    <url>/posts/db1660cd/</url>
    <content><![CDATA[<h1 id="常见的数据结构有"><a href="#常见的数据结构有" class="headerlink" title="常见的数据结构有"></a>常见的数据结构有</h1><p> <code>序列（列表、链表，元祖，队列，二叉树、堆、栈）、图、集合、字典</code></p>
<span id="more"></span>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><ul>
<li>查询序列中元素出现次数的方法:collections.Counter(LIST).most_common(TOP3);可用于计数的场景；</li>
<li>序列分组：通过特定的元素，对序列或者字典分组；使用itertools.groupby()使用前要先对序列排序；</li>
<li>对序列的下标/索引重命名：collections.namedtuple()；这种感觉是让序列有了字典的特性；</li>
<li>实现：线性数据结构/链表数据结构；如下：<ul>
<li>顺序存储：[]这种线性关系的特定是；查询快O(1)，插入/删除慢O(N)</li>
<li>链表<ul>
<li>实现：self.next=null</li>
<li>特点：链式存储：当前节点含下个节点的指针，这个特定是写(add/update)快O(1),读/删很慢O(N)其他特性；单向链表/双向链表（每个节点既保留了下一个的指针，还保留了上一个节点的指针）/快指针/慢指针；</li>
</ul>
</li>
</ul>
</li>
<li>列表推导/生成器表达式：两者都能用来过滤可迭代对象；列表推导生成的对象是列表，而生成式，生成的是可迭代对象；因此列表推动会占用更更多的内存（因为要覆盖整个列表），而生成器表达式只有在调用时，才提供元素，因此他性能更优，但他只能使用一次，列表推导可反复使用；除了用于序列，还能用于hashmap；</li>
<li>sum/min/max函数中都可以放置生成器表达式 如sum(x for i in l)</li>
<li>其他的序列过滤工具：filter(fun(),iterable)/itertools.compress(iterable,Boolean)Boolean是元素为TRUE/FALSE的序列，根据是否为true过滤对应位置的iterable的值；两个工具处理后的结果都是可迭代对象需要通过list(iterable)来转化为序列;</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>实现：str()/‘str’</li>
<li>特点：字符串类似列表，不过其中的元素不可变，且只能为字符，他有序列的所有特点；底层是线性的数据结构，可以通过数组或者链表实现；</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>实现：list()/[]</li>
<li>特点：列表是最常见的线性表，数据元素都是首尾相接的（内存结构是连续的，且事先分配固定长度的内存，可在之后动态调整）；<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4></li>
<li>实现：二叉树用list表示，[根节点，左节点，右节点]</li>
<li>特点：I为当前层；当前层节点数（2^(n-1)）;总节点数2^n-1;二叉树的父节点，维护子节点的指针；二叉树的特性类似于链表，每个跟节点都有指针，指向左右节点；二叉树在列表中的分布逻辑如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在索引从0（根节点）开始的数组中：</span><br><span class="line">  父节点 i 的左子节点在位置(2*i+1)</span><br><span class="line">  父节点 i 的右子节点在位置(2*i+2)</span><br><span class="line">  子节点 i 的父节点在位置floor((i-1)/2)</span><br></pre></td></tr></table></figure>

<p><strong>二叉树遍历的方式有两种：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">深度优先：前序，中序，后序</span><br><span class="line">广度优先：从跟节点开始遍历，然后到下一级子节点，一直递归直到最下层子节点；(类似于数组构造，但数据也支持深度遍历)</span><br><span class="line">二叉树是以列表展示，以栈逻辑的方式组织数据，这是由于，最先出去的一定是最底层的左节点子树；可以通过以上的遍历方式来以不同的效率查找到数据</span><br></pre></td></tr></table></figure>

<ul>
<li>不同的二叉树：<ul>
<li>二叉查找树：父节点的键（索引）大于左子节点，小于右子节点；</li>
<li>满二叉树：每个内部节点（非叶子节点）都有两个子节点的树；</li>
<li>完全二叉树：所有叶子节点在同一层的，满二叉树；有标号（索引）的二叉树，根节点为索引0（列表中），左子节点加1，右子节点加2；  </li>
</ul>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>实现：[]</li>
<li>特点：先进先出（双端队列不是）；底层是线性的数据结构，可以通过数组或者链表实现<ul>
<li>类型：优先队列/双端队列<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优先队列：使用二叉堆实现</span><br><span class="line">  实现：heapq.heapify(queue)&#x2F;heapq.push(queue, e)&#x2F;heapq.pop(queue)&#x2F;queue[0]</span><br><span class="line">  特点：查询快，时间复杂度O(1)</span><br><span class="line">双端队列：可以在两端操作</span><br><span class="line">  实现：dq &#x3D; collections.deque();dq.appendleft(e)，dq.popleft()，dq[0]</span><br><span class="line">  特点：可通过两边操作，左右两端操作快，添加&#x2F;弹出&#x2F;查询的时间复杂度都是O(1)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li>实现：[];物理结构为数组，逻辑结构为完全二叉树;</li>
<li>特点：数据结构类似完全二叉树；堆有两种数据组织方式；根节点最大（且父节点均大于子节点）的为大根堆，跟节点最小（且父节点均小于子节点）的为小根堆；二叉树，一定满足左子节点，小于右子节点；且最底层的左叶子节点值、优先级一定最小，且最早弹出<ul>
<li>大根堆/小根堆常用来处理数据优先级问题；原理是由于堆[]最先出的是[-1]的值，因此大根堆，最大优先级的最先出，小根堆正好相反；具体实现</li>
<li>heapq.heappush([], (-priority, self._index, item))<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;priority优先级，由于堆默认弹出最小优先级，index是在优先级相同时，通过索引判断优先级</span><br><span class="line">              &gt;&gt;&gt; q.push(Item(&#39;foo&#39;), 1)</span><br><span class="line">              &gt;&gt;&gt; q.push(Item(&#39;bar&#39;), 5)</span><br><span class="line">              &gt;&gt;&gt; q.push(Item(&#39;spam&#39;), 4)</span><br><span class="line">              &gt;&gt;&gt; q.push(Item(&#39;grok&#39;), 1)</span><br><span class="line">              &gt;&gt;&gt; q.pop()</span><br><span class="line">              Item(&#39;bar&#39;)</span><br><span class="line">              &gt;&gt;&gt; q.pop()</span><br><span class="line">              Item(&#39;spam&#39;)</span><br><span class="line">              &gt;&gt;&gt; q.pop()</span><br><span class="line">              Item(&#39;foo&#39;)</span><br><span class="line">              &gt;&gt;&gt; q.pop()</span><br><span class="line">              Item(&#39;grok&#39;)</span><br><span class="line">          可用来对列表进行排序，将其转换成大根堆&#x2F;小根堆；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li>实现：[]、或使用队列实现collections.deque()</li>
<li>特点：先进后出；底层的数据结构可以是数组或者双端队列；</li>
</ul>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul>
<li>实现：（*，）</li>
<li>特点：线性序列；序列不可变；</li>
</ul>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>图是多对对的非线性数据关系，可以用列表，字典，集合实现；</li>
</ul>
<h3 id="字典-hash-map"><a href="#字典-hash-map" class="headerlink" title="字典/hash_map"></a>字典/hash_map</h3><ul>
<li>实现：dict()、｛key:value,｝</li>
<li>特点：无序的键值对（底层是动态数据和一个哈希函数构成），且key不能重复；查询块O(1),添加/删除/改很快O(1)<ul>
<li>有顺序关系的字典：Orderdict();他维护了一个双向链表，用来指示键的顺序，新加入的键放在双向链表的最后</li>
<li>以上是对字典内部的排序，字典间的排序可以使用（sorted(dicts,key=itemgetter(‘lname’,’fname’))）,利用itemgetter指定排序模式；同时min/max函数也支持（min(rows, key=itemgetter(‘uid’))）</li>
<li>以上的sort排序还可以用来对不支持排序的对象进行排序如对类或者函数排序（sorted(users, key=lambda u: u.user_id)）；同样他也适用于min/max函数；</li>
<li>单个键，有多个值的字典：defaultdict(list/set)这是建多值字典的方法即｛k:[1,2]｝</li>
<li>字典的运算：注意运算是针对键的，如果要针对值则需要转换，如sort(zip(dict.vaule,dict.key))</li>
<li>字典&amp;集合：字典可以理解成键集合和值集合的映射关系；因此字典的dict.key和dict.item均可以执行集合的逻辑操作</li>
<li>合并多个字典：c = collections.ChainMap(dict1,dict2),c其实是创建多个列表来维护这些字典的键和值，不是真的合并；这个对象查询相同键时，查到的是最先出现的键值，更新/删除数据操作，只能在第一个字典中生效；还能用dict1.update(dict2)合并字典；</li>
<li>以上两种方法的区别，ChainMap是维护了一个数组，来建立key:value关系，不新建字典，变动会两端同步；update方法执行完后建立一个完全独立的新字典，和旧字典互不影响；</li>
</ul>
</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul>
<li>实现：set()、｛*，｝</li>
<li>特点：确定，无序，元素不重复（底层也是hash实现的），类似于只有key的hash,查询慢O(N),添加/删除/改很快O(1)</li>
</ul>
<p><strong>查看对象占用的内存大小：sys.getsizeof()</strong></p>
<p><strong>教程</strong><br><a href="https://www.icourse163.org/course/ZJU-93001?outVendor=zw_mooc_pcsybzkcph_">浙大-数据结构课程-完整</a><br><a href="https://algorithm.yuanbin.me/zh-hans/basics_data_structure/graph.html">github-算法快速教程-快</a><br><a href="https://github.com/TheAlgorithms/Python/blob/master/DIRECTORY.md">GitHub-算法示例大全-Python版</a><br><strong>可视化工具</strong><br><a href="https://visualgo.net/en/list?slide=1-1">新加坡国立大学算法可视化工具</a><br><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构可视化工具</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>类对象/实例对象/类方法/实例方法/静态方法</title>
    <url>/posts/93899372/</url>
    <content><![CDATA[<ul>
<li><strong>类对象</strong></li>
</ul>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    def m1(self, n):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self:&quot;</span>, self)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def m2(cls, n):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cls:&quot;</span>, cls)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def m3(n):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.m1(1) <span class="comment"># self: &lt;__main__.A object at 0x000001E596E41A90&gt;</span></span><br><span class="line">A.m2(1) <span class="comment"># cls: &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line">A.m3(1)</span><br><span class="line"></span><br><span class="line">按顺序执行时，执行class A（）创建了A这个类对象</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实例对象</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#接源码</span></span><br><span class="line">a = A()</span><br><span class="line">是对类对象A的实例化，创建了实例对象a,也可以说a绑定了实例对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>类方法</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#接源码</span></span><br><span class="line">@classmethod</span><br><span class="line">def m2(cls, n):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cls:&quot;</span>, cls)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>类中@classmethod下方的是类方法，写法也是固定写法；其中cls必须要有，cls绑定了类对象A(),在类外部，需要这样引用A(类对象).类方法 ；因为类方法在类中能被直接引用，一般是这样引用self.类方法；这是由于self绑定的是实例对象，根据实例对象可以查找到类对象</code></p>
<ul>
<li><p>使用场景</p>
<p>  <code>  如果希望在方法裡面调用静态类，那么把方法定义成类方法是合适的，因为要是定义成静态方法，那么你就要显示地引用类A，这对继承来说可不是一件好事情。(为了方便调用，但又为了继承方便，因此不用静态方法，显示调用)  </code></p>
</li>
<li><p><strong>实例方法</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def m1(self, n):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;self:&quot;</span>, self)</span><br></pre></td></tr></table></figure>
<p><code>实例方法，必须带self;其中self绑定的实例对象a;因此外部使用可以这样使用，a.m1()；在类的内部self绑定了实例对象，因此可以直接使用self.m1来调用</code></p>
<ul>
<li><p>使用场景</p>
<p>  <code>  需要将方法作为对象属性，进行调用，继承，传递的方法，大部分类方法都会定义成实例方法；  </code></p>
</li>
<li><p><strong>静态方法</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def m3(n):</span><br><span class="line">	pass</span><br><span class="line">        </span><br><span class="line">静态方法，就是普通函数；和类对象和实例对象均无绑定关系；</span><br><span class="line">即可被类调用，也可通过实例调用；</span><br><span class="line">A.m3()</span><br><span class="line">a.m3()</span><br><span class="line">self.m3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用场景</p>
<p>  <code>  如果在方法中不需要访问任何实例方法和属性，纯粹地通过传入参数并返回数据的功能性方法，那么它就适合用静态方法来定义，它节省了实例化对象的开销成本，往往这种方法放在类外面的模块层作为一个函数存在也是没问题的，而放在类中，仅为这个类服务（定义了一个局部域函数仅为该类专门服务）。  </code></p>
</li>
<li><p><strong>装饰器</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def A(FUN):</span><br><span class="line">	<span class="built_in">return</span> FUN+1</span><br><span class="line">    </span><br><span class="line">@FUN</span><br><span class="line">def b():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">在装饰器中@后跟的是父方法，注意类方法/静态方法/装饰器方法区别	</span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/28010894">参考</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>编写博客--makedown语法说明</title>
    <url>/posts/ed6b07f3/</url>
    <content><![CDATA[<h1 id="语法总览"><a href="#语法总览" class="headerlink" title="语法总览"></a>语法总览</h1><h2 id="正文语法"><a href="#正文语法" class="headerlink" title="正文语法"></a>正文语法</h2><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; 1.=== title ===	最顶级标题</span><br><span class="line">&gt; 2.---  title --- 二级标题</span><br><span class="line">&gt; 3.<span class="comment"># title/## title/###### title	一级/二级/六级标题</span></span><br><span class="line">&gt; * tab缩进语法</span><br><span class="line">&gt; + 字体加粗使用** text ** 或__text__</span><br><span class="line">&gt; - 排序列表，无序列表使用（+-*），有序列表使用（1.数字加点）</span><br><span class="line">&gt; - 换行，如果上下行无\n(换行操作)则不换行，如果有则换行</span><br><span class="line">&gt; - 空行，如果上下行之间有空行，则会进行换行</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="资源语法"><a href="#资源语法" class="headerlink" title="资源语法"></a>资源语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">链接：</span><br><span class="line"></span><br><span class="line">&gt; - [链接](baidu.com <span class="string">&quot;百度这可省略，添加的属性值&quot;</span>)</span><br><span class="line">&gt; + [链接2][1]...[链接3][id]</span><br><span class="line">	[1]: baidu.com <span class="string">&quot;属性值1可省略&quot;</span></span><br><span class="line">	[id]: zhihu.com <span class="string">&quot;属性值2可省略&quot;</span> </span><br><span class="line"></span><br><span class="line">图片：</span><br><span class="line"></span><br><span class="line">&gt; - ![alt text](/path/.jpg <span class="string">&quot;可省略，添加的属性值&quot;</span>)</span><br><span class="line">&gt; + ![alt text][1]...![alt text][id可任意和下文保持一致即可]</span><br><span class="line">	[1]: /path/.jpg <span class="string">&quot;属性值1可省略&quot;</span></span><br><span class="line">	[id]: /path/.jpg <span class="string">&quot;属性值2可省略&quot;</span> </span><br><span class="line"></span><br><span class="line">代码块：</span><br><span class="line"></span><br><span class="line">&gt; 1. `中间是代码块`</span><br><span class="line">&gt; 2. ```bash 中间是代码块 ```</span><br><span class="line">&gt; 3. 四个空格/一个tab操作后面的代码</span><br><span class="line">&gt; 4.&lt;!-- more --&gt; 缩写/不展示全文</span><br></pre></td></tr></table></figure>

<h2 id="好看的hexo"><a href="#好看的hexo" class="headerlink" title="好看的hexo"></a>好看的hexo</h2><ul>
<li><a href="https://blog.bill.moe/"><strong>竞赛</strong></a></li>
<li><a href="https://diygod.me/"><strong>b站开源大佬</strong></a></li>
</ul>
<p><a href="https://www.appinn.com/markdown/basic.html">参考</a><br><a href="https://www.appinn.com/markdown/basic.html">参考2</a></p>
]]></content>
  </entry>
  <entry>
    <title>装饰器详解</title>
    <url>/posts/1d1282f5/</url>
    <content><![CDATA[<h1 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a>装饰器是什么</h1><span id="more"></span>

<ul>
<li>装饰器本质上是一种函数构造方法，其构造的是一种可变函数；我们知道在python中一切皆对象，函数即对象，由于对象是灵活不受约束的，因此我们在构造函数时，可将函数对象作为参数传递或者返回，可将函数对象进行随意嵌套，基于这些特性，我们可在在不变更代码的情况下，灵活的扩展函数/模块的功能；</li>
</ul>
<h1 id="装饰器的作用"><a href="#装饰器的作用" class="headerlink" title="装饰器的作用"></a>装饰器的作用</h1><ul>
<li><em><strong>为已存在的对象添加额外功能</strong></em></li>
</ul>
<h1 id="装饰器的实现"><a href="#装饰器的实现" class="headerlink" title="装饰器的实现"></a>装饰器的实现</h1><ul>
<li><strong>原则:</strong> <ul>
<li>装饰器必须接受一个callable对象</li>
<li>其实它并不关心你返回什么，可以是另外一个callable对象（大部分情况），也可以是其他类对象，比如property</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#装饰器的基本语法如下</span></span><br><span class="line">def father(funs):</span><br><span class="line">	def b(funs):</span><br><span class="line">    funs</span><br><span class="line">    pass</span><br><span class="line">	<span class="built_in">return</span> b</span><br><span class="line"><span class="comment">#@这种称为语法糖，实际等同father(son)    </span></span><br><span class="line">@father()</span><br><span class="line">def son():</span><br><span class="line">	pass</span><br><span class="line">    </span><br><span class="line"><span class="comment">#使用,执行子函数，基于结构，会将子函数作为参数传递给父函数，实际执行的是父函数</span></span><br><span class="line">son()</span><br></pre></td></tr></table></figure>
<ul>
<li>由上可知，将子函数作为参数传递给父函数，父函数，会谁传递的函数的对象的变化而执行不同的操作，从而实现可变函数的构造。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上方的结构，不支持复合结构如下，这是由于执行son时已经是复合结构了，在复用一层，就会报错，但是python针对这种场景，也有处理的方法</span></span><br><span class="line">father(son())</span><br><span class="line"></span><br><span class="line"><span class="comment">#处理方法</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#装饰器的基本语法如下</span></span><br><span class="line">def father(funs):</span><br><span class="line">	@wraps(funs)</span><br><span class="line">	def b(funs):</span><br><span class="line">    funs</span><br><span class="line">    pass</span><br><span class="line">	<span class="built_in">return</span> b</span><br><span class="line">    </span><br><span class="line">@father()</span><br><span class="line">def son():</span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时即可支持复合结构</span></span><br></pre></td></tr></table></figure></li>
<li><strong>除上诉以外，装饰器还能被进一步封装</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def logged(level, name=None, message=None):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Add logging to a function. level is the logging</span></span><br><span class="line"><span class="string">    level, name is the logger name, and message is the</span></span><br><span class="line"><span class="string">    log message. If name and message aren&#x27;t specified,</span></span><br><span class="line"><span class="string">    they default to the function&#x27;s module and name.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    def decorate(func):</span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        <span class="built_in">log</span> = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line">        @wraps(func)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="built_in">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">return</span> wrapper</span><br><span class="line">    <span class="built_in">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line">@logged(logging.DEBUG)</span><br><span class="line">def add(x, y):</span><br><span class="line">    <span class="built_in">return</span> x + y</span><br><span class="line"></span><br><span class="line">@logged(logging.CRITICAL, <span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">def spam():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Spam!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>同样一个函数，也可以有多个装饰器</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a/b/c都是装饰器，执行的优先顺序是先内后外即a(son)&gt;b(son)&gt;c(son)</span></span><br><span class="line">@c</span><br><span class="line">@b</span><br><span class="line">@a</span><br><span class="line">def son():</span><br><span class="line">	pass</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>装饰器不仅仅只能是函数，也可以是类，利用的是类的内置方法（__call__）</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class logging(object):</span><br><span class="line">    def __init__(self, level=<span class="string">&#x27;INFO&#x27;</span>):</span><br><span class="line">        self.level = level</span><br><span class="line">        </span><br><span class="line">    def __call__(self, func): <span class="comment"># 接受函数</span></span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.format(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">return</span> wrapper  <span class="comment">#返回函数</span></span><br><span class="line"></span><br><span class="line">@logging(level=<span class="string">&#x27;INFO&#x27;</span>)</span><br><span class="line">def say(something):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;say &#123;&#125;!&quot;</span>.format(something)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/cicaday/p/python-decorator.html#_caption_1"><em><strong>参考：装饰器详解</strong></em></a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里测开面试题</title>
    <url>/posts/92386e32/</url>
    <content><![CDATA[<p>技术题</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">了解多线程吗？了解 Python 的 GIL 锁吗？</span><br><span class="line">说一下进程和线程，及区别？</span><br><span class="line">进程间通信的方式有哪些？</span><br><span class="line">说一下什么是乐观锁和悲观锁？</span><br><span class="line">AOP</span><br><span class="line">什么是 IOC？</span><br><span class="line">list 和 map 相关</span><br><span class="line">解释一下工厂模式？</span><br><span class="line">内存泄漏</span><br><span class="line">会做性能测试吗？容量测试/稳定性测试？</span><br><span class="line">Python2 和 3 的区别？</span><br><span class="line">DNS 解释一下？</span><br><span class="line">用户名、密码、验证码哪个校验顺序？</span><br><span class="line">Linux 根据进程查端口/端口查进程</span><br><span class="line">常用的 Linux 指令？</span><br><span class="line">排序算法</span><br><span class="line">围绕工具开发</span><br><span class="line">工具是如何开发的？</span><br><span class="line">为什么要开发这个工具？</span><br><span class="line">公司内部没有类似平台吗？</span><br><span class="line">效能工具包含哪些？举几个例子？</span><br><span class="line">介绍一下自研的接口自动化框架？</span><br><span class="line">有哪些模块组成？</span><br><span class="line">相比其他框架有哪些优势？缺点有哪些？</span><br><span class="line">介绍一下框架的代码生成模块是怎样实现的？</span><br><span class="line">使用你的框架测一个接口需要做哪些步骤？</span><br><span class="line">接口的断言怎么做？</span><br><span class="line">接口测试带来的收益？</span><br><span class="line">testng 和 junit 优缺点</span><br><span class="line">造数据工具，如何开发、提效多少。</span><br><span class="line">大数据测试</span><br><span class="line">怎么测试数据的准确性？</span><br><span class="line">算法测试</span><br><span class="line">项目经验</span><br><span class="line">算法测试做哪些工作？</span><br><span class="line">如何进行算法评测？</span><br><span class="line">不同的算法类型，评测标准是不同的</span><br><span class="line">介绍一个最近的算法测试案例？</span><br><span class="line">如何选择测试集？测试集的特征如何选择？</span><br><span class="line">说一些算法测试发现的 badcase？</span><br><span class="line">如何保障算法质量？</span><br></pre></td></tr></table></figure>
<p>数据库事务特性：<a href="https://www.cnblogs.com/fjdingsd/p/5273008.html">详情点击此处</a><br>android生命周期:<a href="https://baike.baidu.com/item/activity/7304419">1</a><a href="https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cnhttps://juejin.cn/post/6892745298209308680">2</a><a href="https://juejin.cn/post/6892745298209308680">3</a></p>
<p>测试理论</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、单元/集成/系统/回归/alp/beta分别说明下，重要性排序？</span><br><span class="line"></span><br><span class="line">单元测试：是一种白盒静态测试；旨在对代码的最小单元进行静态扫描/走查式的测试，目的是对代码的逻辑算法条件规则等进行的覆盖测试，以在更早的发现，和找出黑盒测试不易发现的问题，一般是以开发设计文档作为参考；（具体场景如版税结算规则测试/搜索推荐场景测试）</span><br><span class="line"></span><br><span class="line">集成测试：集成测试一般是接口层/服务/sdk这一组件级别的测试；集成测试能较早的发现问题，在系统未完成开发时即可介入，集成测试一般是针对服务端的测试，主要是针对某一模块或场景的测试，可覆盖一些系统测试无法覆盖的场景，本身应该是系统测试的一种补充；一般以接口设计文档，概要设计文档作为参考（如广告定向投放，广告竞价场景）；</span><br><span class="line"></span><br><span class="line">系统测试：系统测试是针对完整系统的测试，系统测试除了需要覆盖需求文档定义的内容，验证系统实现是否满足完整需求，同时系统测试还需要结合系统环境，如运行的硬件，网络等，整体评估系统功能是否能满足设计需要，给用户带来友好的体验；</span><br><span class="line"></span><br><span class="line">回归测试：回归测试一般有两种，一种是BUG修复后的功能回归，这种一般是对修改后的问题模块/问题场景及可能影响的场景在执行一遍用例，以保证bug已回归，另一种是代码变更后的回归测试，旨在代码变更后，在重复执行一遍用例，以保证变更对旧有的功能或版本无影响；</span><br><span class="line"></span><br><span class="line">验收测试：验收测试一般有两种，alp(内测)，beta（公测）；一般指业务需求方或特定的验收人员，对待发布的系统进行最后的验收，以确定系统是否满足需求，处于可最终发布的状态；</span><br><span class="line"></span><br><span class="line">其中系统测试是最重要的，此时系统已完成开发，单元/集成测试已结束，具备完整的功能，此时能覆盖系统的完整功能进行测试，结合系统环境可以完整可靠的评估系统是否满足需求；</span><br><span class="line"></span><br><span class="line">集成测试和系统测试区别：集成和系统是在不同阶段的测试；集成一般是指对系统的接口/服务进行的测试，一般只测系统的一部分，然后系统测试是指对完整系统或者子系统的测试；对象差异导致了测试顺序的差异，一般是先集成测试后系统测试；同时由于集成测试对象比系统测试更小，一般是对接口或集成服务的测试，一般用例的粒度更细；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、黑盒用例设计方法有哪些？</span><br><span class="line"></span><br><span class="line">等价类/边界值/判定表/因果图/场景法/正交分解/错误推导/功能图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、白盒逻辑覆盖测试的方法有哪些？</span><br><span class="line"></span><br><span class="line">语句覆盖/判定覆盖/条件覆盖/条件组合覆盖/路径覆盖</span><br></pre></td></tr></table></figure>


<p>编程题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程交替打印奇偶数</span><br><span class="line">最长回文子串</span><br><span class="line">怎么打印全排列</span><br></pre></td></tr></table></figure>

<p>项目经历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">介绍一下负责的项目？</span><br><span class="line">针对老系统（有很多僵尸代码）如何保证质量？</span><br><span class="line">做过的项目遇到的最大风险点？</span><br><span class="line">怎么保障项目的质量？</span><br><span class="line">如何处理紧急需求？</span><br><span class="line">项目的迭代方式？</span><br><span class="line">说一下最近项目推动成功的案例？</span><br><span class="line">说一下自己人力分配？</span><br></pre></td></tr></table></figure>

<p>持续集成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">了解 CI 吗？解释一下 CI</span><br><span class="line">如何衡量测试用例质量？</span><br><span class="line">说说你对测试的理解？或者说质量的理解？</span><br></pre></td></tr></table></figure>

<p>团队管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">团队管理上有没有什么难点？</span><br><span class="line">你期望一个怎样的测试团队？</span><br><span class="line">团队的测试开发比是怎样的？</span><br><span class="line">如何衡量全职/外包比例？</span><br><span class="line">外包的忠诚度如何保障？</span><br><span class="line">你能为团队带来什么？</span><br></pre></td></tr></table></figure>

<p>HR 问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">为什么跳槽？</span><br><span class="line">为什么选择阿里？</span><br><span class="line">前几家公司收获</span><br><span class="line">有什么问题要问的？</span><br><span class="line">工作中最大的挑战（最大挫折），如何克服的？</span><br><span class="line">最大的有点和缺点？各自说一个？</span><br><span class="line">未来的职业 3-5 年发展规划？</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>阿里</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>New Jobs</title>
    <url>/posts/7eb8636e/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p><code>    通过二个月的冲刺，达到准高级工程师水准，进入大厂（BAT/TMDJKXB)；预期岗位是大厂的中级测开岗，或者广告/音乐/金融类的高级业务测试岗；大厂有包就行，小厂的核心产出岗；</code><br><code>    测开岗方向，主要集中在流程（devops）/服务（稳定性，性能）/自动化（ui/接口/单测）/脚本工具类（打杂，项目需要啥，开发啥）/可视化（也是流程类，不过主要集中在数据和工作流程方面），最具有发展前途的是devops和服务岗，这是真正能有产出的岗位；自动化也就是平台工具化和可视化工具，基本是一体的，小公司认为的自动化一般是这种，就业面广；脚本侠，和业务测试其实区别不大；</code></p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标企业</span><br><span class="line">企业要求</span><br><span class="line">完成规划</span><br><span class="line">面试模拟</span><br><span class="line">过往归纳</span><br><span class="line">反思总结</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="目标企业"><a href="#目标企业" class="headerlink" title="目标企业"></a>目标企业</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">百度</span><br><span class="line">阿里</span><br><span class="line">	lazada</span><br><span class="line"> 	网商银行  </span><br><span class="line">腾讯</span><br><span class="line">	腾讯音乐</span><br><span class="line">	微众银行</span><br><span class="line">头条</span><br><span class="line">滴滴</span><br><span class="line">美团</span><br><span class="line">京东</span><br><span class="line">拼多多</span><br><span class="line">小红书</span><br><span class="line">快手</span><br><span class="line">网易</span><br><span class="line">携程</span><br><span class="line"></span><br><span class="line">手机厂</span><br><span class="line">	华为</span><br><span class="line">	荣耀</span><br><span class="line">	oppo&#x2F;一加</span><br><span class="line">	vivo</span><br><span class="line">	小米</span><br><span class="line">	魅族</span><br><span class="line">	传音</span><br><span class="line">    </span><br><span class="line">汽车厂</span><br><span class="line">	比亚迪</span><br><span class="line">	特斯拉</span><br><span class="line">	广汽埃安</span><br><span class="line">	上汽</span><br><span class="line">	宝马&#x2F;奔驰&#x2F;奥迪    </span><br><span class="line">	小鹏</span><br><span class="line">	蔚来</span><br><span class="line">	理想</span><br><span class="line">	其他车企</span><br><span class="line">    </span><br><span class="line">其他制造业</span><br><span class="line">	大疆</span><br><span class="line">	顺丰</span><br><span class="line">	满帮</span><br><span class="line">	货拉拉</span><br><span class="line">    </span><br><span class="line">金融+银行+券商    </span><br><span class="line">外企 </span><br><span class="line">海外</span><br><span class="line">	虾皮</span><br><span class="line">	shenin</span><br><span class="line">	大厂出海</span><br><span class="line">		头条-tiktok</span><br><span class="line">		头条-汽水音乐</span><br><span class="line">		拼多多-TEMU</span><br><span class="line">		快手-kwai</span><br><span class="line">		万兴</span><br><span class="line">		大宇无限</span><br><span class="line">		anker</span><br><span class="line">        </span><br><span class="line">其他</span><br><span class="line">	b站</span><br><span class="line">	贝壳</span><br><span class="line">	用友</span><br><span class="line">	boss直聘</span><br><span class="line">	360</span><br><span class="line">	微博 </span><br><span class="line">	唯品会</span><br><span class="line">	爱奇艺    </span><br><span class="line">	阅文</span><br><span class="line">	达达</span><br><span class="line">	知乎</span><br><span class="line">	金山</span><br><span class="line">	喜马拉雅</span><br><span class="line">	同城艺龙</span><br><span class="line">	汽车之家</span><br><span class="line">	欢聚时代</span><br><span class="line">	微盟</span><br><span class="line">	陌陌</span><br><span class="line">	有赞</span><br><span class="line">	斗鱼</span><br><span class="line">	虎牙</span><br><span class="line">	哈罗</span><br><span class="line">	得物</span><br><span class="line">	soul</span><br><span class="line">	keep</span><br><span class="line">	涂鸦	    </span><br><span class="line">	浪潮</span><br><span class="line">	商汤</span><br><span class="line">	云从</span><br><span class="line">	旷视</span><br><span class="line">	依图</span><br><span class="line">	猎豹</span><br><span class="line">	美图</span><br><span class="line">	奇安信</span><br><span class="line">	华润</span><br><span class="line">    </span><br><span class="line">国企   </span><br><span class="line">人工智能</span><br><span class="line">AI</span><br><span class="line">  chatgpt</span><br><span class="line">  AI四小龙</span><br><span class="line">币圈</span><br></pre></td></tr></table></figure>

<h3 id="企业要求"><a href="#企业要求" class="headerlink" title="企业要求"></a>企业要求</h3><p><strong>为人</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会问面试者印象深刻的工作，主要考虑是否会在工作中思考，以及解决复杂问题的思路；</span><br><span class="line">味道&#x2F;风格和公司以及团队是否匹配,即是否认可公司的价值观；</span><br><span class="line">性格是不是积极向上的。主动、乐观、皮实；</span><br><span class="line">应聘的人有潜力么，成长性怎么样，也很重要；</span><br><span class="line">1️⃣评判潜力的准则就是：工作年限是否与工作能力相匹配。锚点就是你身边的同事，一个个去比，心里就会有数。 回想一下，你在他这个年龄的时候，是比他好，还是比他差？对于工作年限比较长的应聘者，一定要看应聘者是不是在一个方向已经钻了足够的深度。如果没有，大概率不具备潜力。</span><br><span class="line">应聘者的意愿，与岗位需要完全匹配，因此面试前一定要先了解岗位；</span><br><span class="line">来公司的动机；</span><br><span class="line">诚信一票否决。如果发现明显的不诚信，一定一票否决；</span><br><span class="line">可能会问一些逻辑思维题，考察思维的灵活性，人是否聪明。</span><br><span class="line"></span><br><span class="line">个人特质：快速学习、系统性学习、学以致用、系统性思考、强大的推动力、技术思维、突出的沟通能力、条理性、抗压性、乐观精神、抗挫折能力、迅速调整的能力、迭代改进的意识、ownership、团队合作、愿景和规划。 这些特性体现人的内核，有强大内核的人，做什么都行，技能暂时不足，也一定能补足。所以，在招聘的时候往往对是否录用的判断起决定性作用；</span><br><span class="line">    </span><br><span class="line">其他综合能力：</span><br><span class="line">1️⃣很好的项目管理能力，至少与开发经理能力同级，甚至要强于他；</span><br><span class="line">2️⃣一定的软件架构能力，只有熟悉架构，才能优化架构，发现问题；</span><br><span class="line">3️⃣一定的产品 sense：可以跟一个资深的产品经理能够顺畅的交流，明白知道他为什么会这么想，所要实现产品的意义，路径；从产品质量方面的考虑要超过产品经理，给他输出；</span><br><span class="line">4️⃣团队管理能力（这个太重要）；</span><br><span class="line">5️⃣目标管理能力；</span><br><span class="line">6️⃣有优良的品质（看上面），会捧人；</span><br></pre></td></tr></table></figure>

<p><strong>处事</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">招聘岗位需要什么样的人，匹配最重要，此岗位那些技能是重点，会着重考量；</span><br><span class="line">会着重问简历中的问题，而且会扩展，主要考量深度，还有诚信；</span><br><span class="line">项目经验：是否有正规的项目组工作经验：理解敏捷的工作模式，有良好的开发习惯，有和项目组良好的协作、沟通能力；是否对原有参与建设的业务系统的业务有一个完整的理解，需要有案例；</span><br><span class="line">项目需要体现复杂性，匹配度，需要在项目中体现自己的价值；</span><br><span class="line">技术根底：对应的技术栈是否有与工作年龄匹配的深度。举例：一个做 Java 业务开发 3~5 年的程序员应该对 Java 的基础知识（Core Java 书里的所有知识点），在设计模式，业务建模， 性能调优等一个或者几个点，有比较深的理解；有很强的故障定位及排除能力；能够熟练使用 Java 常见的框架，如 Spring 等；读过部分流行框架源码等。</span><br><span class="line">系统思考的能力，是否有模块化，体系化的思考能力。</span><br><span class="line">技能方面，考虑一个问题：应聘的同学能够提升团队平均技能的水位线么？如果不是，招聘对你团队的整体收益就会打折。除非应急，否则还是尽量招聘能够提升团队水位线的人，这很重要；</span><br><span class="line"></span><br><span class="line">基础知识，基础知识是底子，读下这两本书（《高级软件测试设计》《高级软件测试管理》），明白常问的，业务性问题背后的深意(PS:WT看案例)：</span><br><span class="line">1️⃣如果测试时间不够，你会怎么办？ </span><br><span class="line">2️⃣如果让你去测试一个你完全不熟悉的系统，你会怎么办？</span><br><span class="line">3️⃣你平时会使用那些测试设计方法？</span><br><span class="line"></span><br><span class="line">业务知识积累：</span><br><span class="line">1️⃣体现业务知识积累的全局观,全局观架构师很重要的一点；</span><br><span class="line">2️⃣业务遇到的问题,解决的问题也是重要的积累；</span><br><span class="line">3️⃣技术角度上，你要能够画得出来系统的交互图；</span><br><span class="line">4️⃣熟悉最核心的接口和最核心的参数；</span><br><span class="line">5️⃣能够读懂开发的代码，熟练使用 trace 和监控工具，诊断定位线上问题到代码行；</span><br><span class="line">《The little black book on Test Design（海盗派测试分析）》看这本书学习测试思维的套路；</span><br><span class="line"></span><br><span class="line">熟练掌握一门开发语言，也就是python：</span><br><span class="line">1️⃣系统学习过 Java 的教程，高频面试 50 题 这样的题可以自测一下，可以回答上 35 个以上；</span><br><span class="line">2️⃣熟悉最主流的 Spring 框架，能够写出一个简单的网站，实现基础的 Restful 服务；</span><br><span class="line">3️⃣读懂过一个测试框架，如 mockito 或者 Junit 的源码；</span><br><span class="line">4️⃣能够熟练实施接口测试（基于一些测试框架 如：rest-assured+Junit）；</span><br><span class="line">5️⃣能够读懂开发的业务代码，对他们的代码进行 Code Review；</span><br><span class="line">   </span><br><span class="line">精通语言的标准：</span><br><span class="line">1️⃣还拿 Java 来说吧：熟练使用 Java 的常见 API；</span><br><span class="line">2️⃣深入理解基于语言特性&#x2F;系统特性的知识，如 Collections 的实现机制、类型系统、I&#x2F;O、网络、多线程等；</span><br><span class="line">3️⃣熟知设计模式（广义范围的设计模式，不局限于 GOF 的设计模式）；</span><br><span class="line">4️⃣熟悉 JVM 的工作模式；熟练使用调试排查工具解决性能问题；</span><br><span class="line">5️⃣熟练掌握市面上常见的脚手架；</span><br><span class="line">6️⃣熟练掌握周边知识（OPs 相关，网络知识相关）有不错的实战开发经验（做过真正被生产检验的东西）；</span><br><span class="line">对于测试开发，AOP，Java 字节码技术是很重要的知识。。。</span><br><span class="line">8️⃣达到能胜任普通的开发岗位。</span><br><span class="line">   </span><br><span class="line">效能：</span><br><span class="line">1️⃣你能够举一个你用技术手段提高测试效率，增强测试能力的例子么？这是面试时最大的一个坎,因为太大，需要有明显的可量化的效能很难，环境、CI、数据、测试用例生成、数据比对的很小的一些点上，都能有不错的提效产出，从这些点能够做得好，会得到不错的加分。用明确的小案例证明价值也是可行的；</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">高级职位的其他要求：</span><br><span class="line">1️⃣计算机领域知识的通盘理解，高级岗位要求，各块，基本都要了解一点</span><br><span class="line">2️⃣计算机网络：基本的网络链路需要了解，http协议tcp&#x2F;ip协议需要吃透（推荐图解tcp&#x2F;ip）(图解http)</span><br><span class="line">3️⃣linux服务器，需要会使用基本的命令，要能在特定的性能场景定位问题；需要能读写shell,同时云原生的ks常见架构要了解，需要能简单的部署，和使用。并且能利用与测试提效；</span><br><span class="line">4️⃣数据库知识：市面常见数据库（redis，mysql，oracle）的常见 DBA 操作，问题排查；SQL 的熟练使用；</span><br><span class="line">5️⃣Web 及移动端知识：能够懂 HTML，CSS，能够读懂 Javascript 代码，能够读懂 Android 或者 iOS 的代码，做简单开发最好；</span><br><span class="line">6️⃣安全知识：常见的安全防护方法、工具使用；基本的安全攻防原理；</span><br><span class="line">软件工程&#x2F;开发过程管理：实战中各种磨练，建议系统的学习 PMP，敏捷开发的一些认证课程。</span><br><span class="line"></span><br><span class="line">有核心竞争力：</span><br><span class="line">1️⃣个人在职业技能方面要有核心竞争力，有自己的品牌优势，要在简历中体现；</span><br><span class="line">2️⃣移动端测试要有在相应端的开发能力；能读懂业务代码，完成部分页面代码的走查；能对移动端测试特性，有完整可落地的自动化工具栈实现能力，如监控工具栈（如友盟、bugly、newrelic 等）、内存泄露检测、卡顿检测、耗电量、弱网、流量、埋点、灰度、版本控制、兼容性、用户体验、安全等等的质量保障；</span><br><span class="line">3️⃣具体来说，就是能解决具体的问题，比如对降低崩溃率有通篇的方案；</span><br></pre></td></tr></table></figure>
<h3 id="企业JD"><a href="#企业JD" class="headerlink" title="企业JD"></a>企业JD</h3><p><em>腾讯</em></p>
<p><strong>测开岗</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本科及以上学历，计算机或相关专业，具备扎实的计算机和软件技术基础</span><br><span class="line">2 年及以上开发 或者 测试开发 工作经验，技术栈至少满足以下技术项中的一项或者多项：</span><br><span class="line">1️⃣熟悉 Android&#x2F;iOS 移动操作系统，具备终端的自动化测试工具或性能测试等项目开发经验；熟悉Java&#x2F;OC&#x2F;Swift 等至少一门编程语言；</span><br><span class="line">2️⃣熟悉 go&#x2F;C++&#x2F;java 等至少一种后台主流编程语言，熟悉至少一门脚本开发语言（如 shell、python）；	</span><br><span class="line">3️⃣熟悉 linux 平台下服务器调试开发；对缓存、存储、并发等场景有一定的测试开发经验；熟悉微服务架构并	能独立开发后台服务，熟悉大数据开发及应用；</span><br><span class="line">4️⃣熟悉前端开发基础知识，熟练掌握 CSS，JS，HTML 语言，至少熟练掌握一个前端 MVVM 框架（React、Vue最佳），具备丰富的前端项目开发经验；</span><br><span class="line">5️⃣三年以上软件开发经验，能熟悉掌握和运用 C&#x2F;C++&#x2F;Python 等任何一门主流编程语言；</span><br><span class="line">6️⃣在测试自动化、平台研发、web 自动化、报表分析、静态分析、开发调试工具、框架设计和分布式系统等领域中，有涉及到一项或多项相关的实践经验；</span><br><span class="line">具有发现问题的灵敏嗅觉，具备针对复杂问题的分析和解决的能力；</span><br><span class="line">8️⃣熟悉 JS ES6 Webpack Vue 有加分；</span><br><span class="line">9️⃣业务项目中，应用行业前沿的优秀的工程实践经验，提升研发和工程生产力和效率；</span><br><span class="line">1️⃣0️⃣设计、构建和落地自动化构建、测试和发布的工程基础设施；</span><br><span class="line">1️⃣1️⃣驱动研发团队落实优秀的代码规范、代码设计原则和高质量的测试；</span><br><span class="line">1️⃣2️⃣分析和定位复杂系统耦合关系，梳理跨团队分工协作，以提升系统可测试性；</span><br><span class="line"></span><br><span class="line">个人特质：</span><br><span class="line">1️⃣具备良好的学习能力、复杂问题定位和分析能力；具备创新性思维、较强的抗压能力和技术钻研能力；</span><br><span class="line">2️⃣具备扎实的编程基本功，具备一定的项目架构设计能力；</span><br><span class="line">3️⃣对 devops 工程效能实践有深入理解和实践经验者优先；</span><br><span class="line"></span><br><span class="line">【腾讯会议测试开发工程师（深圳&#x2F;广州&#x2F;北京）】</span><br><span class="line">工作职责：</span><br><span class="line"></span><br><span class="line">1️⃣参与腾讯会议及相关音视频产品进行专项测试工具能力建设设计及开发工作；</span><br><span class="line">2️⃣参与产品研发效能工具的开发工作；</span><br><span class="line">3️⃣建设产品自动化测试体系，提升团队的工作效率；</span><br><span class="line">4️⃣评估引入外部先进工作方法或技术，服务团队； 工作要求</span><br><span class="line">5️⃣计算机、通信相关专业本科及以上学历， 2 年以上社会工作经验；</span><br><span class="line">6️⃣熟悉软件开发的流程、工具及相关技能；</span><br><span class="line">7掌握数据结构，数据库，操作系统，网络等基础知识；</span><br><span class="line">8️⃣熟练掌握至少一门开发语言，编译或者脚本语言均可；</span><br><span class="line">9️⃣有自动化测试系统开发经验者优先；</span><br><span class="line">1️⃣0️⃣了解音频、视频相关知识，熟悉音质、画质、时延、卡顿等测试内容者优先考虑</span><br></pre></td></tr></table></figure>
<p><strong>业务岗</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对云服务、分布式计算、大数据处理等有深刻架构理解和测试经验；</span><br><span class="line">对 Linux&#x2F;Unix 操作系统、TCP&#x2F;IP 网络协议、NoSQL 等都有比较深入的理解和实践经验；</span><br><span class="line">具备自动化测试经验，深刻理解自动化平台和持续集成体系建设者优先；</span><br><span class="line">有丰富性能、协议或白盒测试经验者优先；</span><br><span class="line"></span><br><span class="line">【腾讯会议高级测试工程师（深圳&#x2F;广州&#x2F;北京）】</span><br><span class="line">工作职责：</span><br><span class="line">1️⃣负责腾讯会议产品的质量保障工作，以及专项测试技术、效能工具和平台等相关工作；</span><br><span class="line">2️⃣推进各端自动化体系、专项测试体系、工具平台的建设和优化，持续提升测试效率；</span><br><span class="line">3️⃣推动整个研发团队的质量意识，在保障高质量的同时通过 devops 提升研发效能。</span><br><span class="line">工作要求：</span><br><span class="line">1️⃣计算机相关专业本科以上学历，有两年及以上测试开发工作经验；</span><br><span class="line">2️⃣能通过最新的技术手段来保障和改进产品质量 ，有音视频或会议相关大型项目测试开发实践者优先考虑；</span><br><span class="line">3️⃣深入掌握测试体系、测试流程和测试技术，能通过测试技术提升效率；</span><br><span class="line">4️⃣对质量体系、流程、测试风险把握，测试范畴的定义有很好的理解和应用，独立承担过大型项目测试负责人，能够通过有效的手段、流程和方法推进产品测试开展，把控产品质量；</span><br><span class="line">5️⃣熟悉功能测试方法和设计，掌握分层测试， CICD 等测试建设手段；</span><br><span class="line">6️⃣良好的沟通能力和团队协作能力。能从整个研发的角度出发，对研发流程和研发效率的改善提出落地方案。</span><br></pre></td></tr></table></figure>

<p><em>百度</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure>

<p><em>阿里</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">至少 3 年以上工作经验</span><br><span class="line">本科及以上学历，硕士生，研究生，博士生更佳</span><br><span class="line">精通C、C++、Java、Python 等至少一种编程语言</span><br><span class="line">熟悉软件研发流程，掌握软件测试理论和方法，有设计和开发测试工具和自动化测试框架能力更佳</span><br><span class="line">喜欢钻研技术，对质量捍卫有热情，不断追求产品用户体验的完善</span><br><span class="line">善于沟通，善于团队合作</span><br><span class="line"></span><br><span class="line">【[杭州] 阿里巴巴 CBU 技术部 招聘 高级测试开发工程师 &#x2F; 测试开发专家】</span><br><span class="line">职位要求：</span><br><span class="line"></span><br><span class="line">1️⃣两年以上互联网及传统行业的测试开发经验，对软件质量保障有体系化的思考和经验。能够面对复杂情况建立体系化的软件质量控制的策略和模型，并且有大型项目成功实践的经验；</span><br><span class="line">2️⃣具备业务或测试技术（自动化、性能、安全、用户体验、稳定性等）某方面的专长，具有一定的业务建模能力或测试技术预研、选型、设计开发、统一规划的能力；</span><br><span class="line">3️⃣具备抽像提炼测试技术的共性问题，主导业务线相关领域的测试系统建设，持续发现和解决重大系统、业务问题；</span><br><span class="line">4️⃣优秀的代码实现能力，精通 C&#x2F;C++, JAVA, Python 等编程语言之一，并有实际项目代码经验;</span><br><span class="line">5️⃣逻辑能力强、思维活跃，接受新事物能力强；责任心强，积极主动，善于沟通，良好的团队合作能力；良好英文沟通能力；</span><br><span class="line">6️⃣大型互联网名企经验优先，数据和算法测试经验优先。</span><br><span class="line"></span><br><span class="line">【[北京][杭州] 阿里云存储测试开发 P6~P8 核心团队内推】</span><br><span class="line"></span><br><span class="line">1️⃣传播测试理念，设计 CI&#x2F;CD 流程，指导研发工程师持续快速地交付产品特性；</span><br><span class="line">2️⃣根据业务需求，设计和开发测试工具，包括自动化测试框架、持续回归平台、性能测试工具、资源管理工具等；</span><br><span class="line">3️⃣参与某个存储产品的测试工作，制定和实施测试计划，保障被测系统高质量发布上线；</span><br><span class="line">4️⃣针对测试和发布流程提出改进意见，提升研发工程师的幸福感。</span><br><span class="line"></span><br><span class="line">职位要求：</span><br><span class="line">1️⃣计算机本科以上相关专业，三年以上工作经验；</span><br><span class="line">2️⃣有互联网后端 、存储或网络产品自动化测试经验，有系统化的测试分析和设计能力；</span><br><span class="line">3️⃣熟悉 Linux 操作系统、熟练使用 shell 和 python 编程语言；</span><br><span class="line">4️⃣具备很强的逻辑思维能力和较高的分析、处理问题的能力，熟练的文档、沟通表达和辅导技巧；</span><br><span class="line">5️⃣善于团队合作，理解和适应变化，以结果和行动为准则，努力追求成功。​</span><br></pre></td></tr></table></figure>

<p><em>字节</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">_京东_</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<p><em>拼多多</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">_美团_</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<p><em>小红书</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">_快手_</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<p><em>网易</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先熟悉jd,招聘肯定是有明确的岗位的，先明确岗位要什么，自己是否和岗位匹配，如匹配，面试时需要表现出匹配点；</span><br><span class="line">&quot;味道&quot;,这个人和公司，和你所在的团队是否 “味道一致”? 如果不一致，需要看一下应聘者的适应能力和适应意愿。举几个例子：如果公司强调的是 “协同” 和 “Ownership”，习惯把自己的工作框边界划的特别死的人就很难适应；如果公司强调流程、严谨，非常 free sytle 的人就会很难适应。如果公司有明确的层级感，特别习惯扁平化合作关系的人就会不适应。无有好坏，只有适合还是不适合。不同类型公司培养出来的人这方面差距是非常大的。招聘的时候，一定考虑我们公司的价值观，还有公司的味道。应聘者是否适应，是否喜欢；要明确自己是否适合该企业的企业文化，上级的管理文化，薪资差距不大，优先选择自己能接受的；</span><br><span class="line">技能方面，新jd大概率技能水平会大于团队平均水平线，如果面试对技能要求过低，对项目和公司的技能水平存疑；</span><br><span class="line">意愿需要和岗位匹配，没公司愿意招个几天就走的人；</span><br><span class="line">一定要表现出诚信，不诚实，可能会让人觉得你每一句话都是假的；</span><br><span class="line">要熟悉自己的简历，学会反问，大厂尤其喜欢由表及里的问答来考虑深度；</span><br><span class="line">询问面试者最成功的经历，还有最痛苦的失败。可以考察他能够完成一件事情的能力，考察他对以往工作是否有比较深刻的思考。如果对以往工作从来没有深刻思考，未来大概率也不会有。如果没有成功经历，工作时间又很长，很大概率未来也不会有。</span><br><span class="line">案例&#x2F;故事:要有证明能力的勋章</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="面试案例"><a href="#面试案例" class="headerlink" title="面试案例"></a>面试案例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1️⃣你所在的 team 总在被开发抱怨测试用的时间太长。如何能缩短一下测试时间呢？</span><br><span class="line">通过调研，发现测试小伙伴诟病的最多的就是环境不可用。环境到底多不可用呢？</span><br><span class="line">你基于 Grafana 和 Prometheus 做了一个环境可用的监控报表，使用后，发现环境在工作日整体可用率只有 35% 左右，主要原因是：几个核心热点应用经常挂了没人管。</span><br><span class="line">你拉了整个 team，明确了部署责任人，约定了部署规则：只能中午饭和晚饭时间部署，并且部署后要自己看一下是不是 OK。</span><br><span class="line">一周后，环境可用度上升到了 65%。再深入分析，发现 2 个同学不守规矩，总是他们在破坏规则，你去找他们单独谈话。</span><br><span class="line">一周后，环境可用度上升到了 80%。还是有少量人不守规矩。</span><br><span class="line">你找 SRE 的同学提需求，做了部署卡点，非部署时间部署必须 TL 审批。</span><br><span class="line">一周后，环境可用度上升到了 85%。有些 TL 也不守规矩。</span><br><span class="line">你建了个报警，环境乱部署，坏掉了，在大团队的群里 @ 全体，告知谁搞坏了环境。</span><br><span class="line">一周后，环境可用度达到了 92%。</span><br><span class="line">你加了一个 feature：应用挂了一段时间无人响应，自动重启服务功能，仍然有问题，就自动回滚上一版本。</span><br><span class="line">你推动了开发解决了某个应用启动时间过长的问题。</span><br><span class="line">你推动了环境分组。</span><br><span class="line">你推动了测试环境版本上线的规范流程实施。</span><br><span class="line">你推动了冒烟自动化用例卡点。</span><br><span class="line">你推动了环境部署人备份机制。</span><br><span class="line">你推动了全员基础环境部署培训。</span><br><span class="line">你总结了部署手册。</span><br><span class="line">你做了。。。。。</span><br><span class="line">最后，环境可用度稳定到了 97% 以上。你为测试节省了 60% 以上 block 时间（原来可用度为 35%）</span><br><span class="line"></span><br><span class="line">2️⃣上面的问题，除了环境，还有一个槽点：开发提测质量不高。测试的头几天，很多主流程都走不通，导致测试总是在等待，或者是跟着开发一起联调。而这段时间，已经被习惯性的认为是测试时间了，因为：提测了。</span><br><span class="line"></span><br><span class="line">你推动了：测试提供冒烟用例，开发必须完成一定程度的自测才能提测。</span><br><span class="line">你推动了：测试和开发做自动化同期共建，在开发过程中，核心功能就被自动化用例保护起来了。</span><br><span class="line">你推动了：开发切分 feature 提测，而不是攒一个大招一下子提一坨。</span><br><span class="line">你推动了：代码 Codereview 变成团队常规活动，QA 在早期跟进核心代码，把问题坑杀在萌芽阶段。</span><br><span class="line">你推动了：外部资源联调非常早的进行，不会让它在测试后期成为测试 blocker。</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">3️⃣你发现测试时间长，QA 自己也有问题。</span><br><span class="line"></span><br><span class="line">你推动了：有明确的测试计划，并让所有干系人都有明确的预期。</span><br><span class="line">你推动了：测试依据风险测试，最大的风险得到最快的 cover，科学分配时间，明显缩短 bug 反馈时间弧。</span><br><span class="line">你推动了：bug 严格管理，所有重要 bug 都及时修复。</span><br><span class="line">你推动了：良好的沟通和汇报机制，每天让团队主要干系人清晰的知道，距离发布还差多远。</span><br><span class="line">你推动了。。。。</span><br><span class="line"></span><br><span class="line">你能讲出自己做过 5 个以上这样的成功例子，我敢保障，你会被 1 线大厂疯抢。职级基本都是专家起。</span><br><span class="line"></span><br><span class="line">持续学习能力和复杂问题解决能力</span><br><span class="line">4️⃣：</span><br><span class="line">你近期的工作是帮助团队提升后台服务稳定性。你看到了 netflix 内部使用一个叫做 ChaosMonkey 的东西来随机对生产服务期进行攻击，而逼迫工程师提高稳定性，所以，你也实现了类似（更温和）的内部机制，推动团队稳定性的提高。</span><br><span class="line">你怎么知道这个叫做 ChaosMonkey 的东西呢？ 因为你会习惯性浏览一线厂商的技术博客，参与行业大会，关注各类新技术。持续性的养成习惯。</span><br><span class="line"></span><br><span class="line">5️⃣：</span><br><span class="line">做大规模接口自动化好难，外部数据依赖太难搞，参数构造太费劲，assert 太难写。如果能够简单的录制回放就好了。</span><br><span class="line">但是，外部依赖是个天坑，写操作 mock 也是个天坑，assert 也是个天坑。</span><br><span class="line">实际的案例是，经过几年多个团队持续不懈的填坑，阿里内部已经有应用级的录制回放工具了，数百个应用成功的是用了它，把不可能回归的任务变成了可能（上万数量级的 case 当天生成，当天投入使用，并可以分析覆盖率），自动化测试实施需要付出的工作时间革命性降低（不足原来付出时间的 10%）</span><br><span class="line"></span><br><span class="line">6️⃣某个版本的某个模块问题很多，但上线时间紧迫怎么办？</span><br><span class="line">基于风险的测试。测试的本质是抽样，时间资源总是有限的。要把资源用在刀刃上。先看看那个模块是干嘛的，是不是重要，如果出问题，影响面有多大？然后具体问题具体分析。如果是核心模块，会造成重大损失，那质量一定是不能丢的，抽调别的力量加强这块儿投入，把风险明确的传递给主要干系人，必要时延期项目。如果是非关键模块，识别出问题，可以做：设定一个最小实现目标，砍 feature，用运营&#x2F;客服的手段补足。长效方法：自动化防护网建立，让回归的时间成本、人力投入成本低下来;在项目的初期就能够一定程度的识别这种风险，早加资源，别让这种事儿变成到了最后：一坨毛病，deadline 不变。 QA 最大的一个价值就是：像探照灯一样很早的预期到风险，并同步给主要干系人。</span><br><span class="line"></span><br><span class="line">7️⃣如果测试时间不够，你会怎么办？</span><br><span class="line">仍然没有标准答案，但我比较满意的点会有：</span><br><span class="line"></span><br><span class="line">跳出这个问题，讲如何从初期避免测试时间不够，以前有过很成功的案例是很好加分项。</span><br><span class="line">懂得基于风险的测试，估算时间，设计测试策略，把最有限的时间分配在项目风险最大的地方。这是项非常重要的能力（有专业知识，请参考 ISTQB 教程）有非常成熟的形式化方法，也有非常多的实战 checklist（做过大项目的人肯定能够讲出不少条）。</span><br><span class="line">清晰让主要干系人随时知道现在项目的状态，特别是质量情况，未来可能的走势，大概什么可能达到发布状态。 QA 是一个夜间走山路汽车的大灯，他的职责就是最有效的发现项目所有的大坑，并明确的告诉司机（项目主要干系人）。这里面隐含着对沟通能力的考察，也隐含着对风险管理的能力的考察。</span><br><span class="line">一定的项目管理能力，如何让团队对现状，对现在的项目计划是否能够有效进行下去有一个清晰的认识，并且引导团队 work smart 搞定挑战。你不一定是 TL，在系统测试阶段，从某种意义上 QA 就是项目 Leader。在关键时刻，项目的成败，重要决策是否能够被做出，与负责项目的 QA 有重大关系。</span><br><span class="line">软技能：推动能力，ownership，协调能力，抗压能力，能否激励团队，给团队信心等等。</span><br><span class="line">如果应聘者谈到以前工作，可能会追问，考察其它知识点。</span><br><span class="line">只能回答出 “加班呗”，而没有其他思路的人，大概率只能 pass 了。虽然接受加班一般用人单位都比较喜欢，但没有展示出任何 QA 应有的能力，技能上肯定是不合格了。</span><br><span class="line"></span><br><span class="line">8️⃣你平时会使用那些测试设计方法？</span><br><span class="line">主要考察做测试设计的时候是否靠谱。思路是否开阔，是否收过专业训练，是否积累了自己的一套方法。仍然没有标准答案。</span><br><span class="line"></span><br><span class="line">如果只能讲出：我会等价类，边界值，然后。。。。我想想。。。想不出来了。 。。 如果再简单引导，还是无法给出更多内容，大概率会被 pass（很多应聘者都会这样）。</span><br><span class="line">如果你觉得你没有听懂这个问题，反问我，我会给你加分。</span><br><span class="line">如果你熟练掌握等价类、边界值、判定表、状态图转化、组合测试等通用方法，并能够举出一个例子来，我会给加分（最基本的东西用了）。</span><br><span class="line">如果能够给出基于被测物详细分析做测试设计的案例，我会给加很多分。</span><br><span class="line">有固定套路的人（例如 可以使用 基于 guide word 的测试设计 ）会加分。</span><br><span class="line">能够讲出自己一套方法论，并且有明确案例支撑的人会大大加分。</span><br><span class="line">能够结合自己工作侃侃而谈并说到点上的人（虽然显得比较散），也会给加分。</span><br><span class="line">测试设计本质上要回答两个问题：你的测试设计是有效的么？（是否经过测试就靠谱了，覆盖率是？）你的测试是高效的么？（是不是能够用不太多的用例高效找出主要问题，这在大规模项目里非常重要） 再往大里讲讲，“测试设计” 不仅仅包含了一些简单的方法的使用，还包含了过程活动、质量意识在里边。不展开说了，有兴趣的同学可以参考这本书The little black book on Test Design 通读 5 遍，同时把他引用的所有链接全看了。再跟你的工作联系起来，再不断的翻过来调过去揣摩、实践里边的方法，半年后，你看测试会有比现在深太多的认识。别人问你测试设计，你能给他讲 1 天。你的工作也会发生本质改变。</span><br><span class="line">还是那句话，面试主要还是考察平时的工作经验积累、思考积累、解决问题的能力的积累。</span><br><span class="line"></span><br><span class="line">9️⃣如果让你去测试一个你完全不熟悉的系统，你会怎么办？</span><br><span class="line">1.这个问题是一个开放性的问题，适合不断加入上下文来追问。那个面试官的模式很像我。😀。</span><br><span class="line">2.有上下文的持续追问是能够检验应聘者对问题有没有深入理解、简历上过去工作经历有没有水分的非常好的做法。如果只是了解皮毛，简历注水非常严重，被追问几句必然败下阵来，并且留下非常不好的印象（不诚实）。</span><br><span class="line">3.回到这个具体的问题，从这个问题出发的考察点有几个：是不是具备快速学习能力？是不是有很好的获取知识的套路（测试的过程本质上是一个学习的过程）？是不是有很强的探索精神？是不是有很强的沟通能力？是不是有不错的总结能力？</span><br><span class="line">这里并没有标准答案，但一定是有考察点的。</span><br><span class="line">4.如果你的回答里有明确的亮点，一定会加分，加分比较多，胜出的几率就很大。举几个加分的亮点的例子：</span><br><span class="line">a.我会先去直接操作和观察被测物。（比直接奔向需求要加分很多，想一下，你实际工作中，快速理解一个东西靠的是什么？肯定不是先读文档，且不说这些文档是不是能够正确的描述被测物）</span><br><span class="line">b.我依托原来的工作经验，讲出了十几种信息来源，而不是只能讲出需求：同类产品，说明书，直接操作、观察被测物，原有版本，找产品经理，找开发，找销售，运维，客服，找用户，公司知识库，历史邮件，会议纪要，原来的各种文档，代码，google，相关法规，行业标准。。。。 能够有效开动脑筋，从各种地方获取信息帮助测试的人会让人眼前一亮。 只能讲出依照需求，说不出其它的人基本上会被 pass。</span><br><span class="line">c.讲出原来几天搞定了一个从来没有经手过的系统的测试，并经受住追问，不管路子多野，多山寨，也会是加分项。</span><br><span class="line">d.能讲出克服的一个具体困难点的例子，并经受住追问，也会是加分项。</span><br><span class="line"></span><br><span class="line">追问就会转到其它问题，考察点会结合你的反馈变更。 比如那个问题：如果项目进度很赶呢？ 我的理解是要考察你有没有 “迭代” 的工作思路。 如果回答给出了快速上手的正确方法，给出了通过迭代，一边学一边加深理解，一边给出质量反馈的思路，肯定会是加分项。</span><br><span class="line">6.一般能有五六个亮点，你胜出的几率就很大了。</span><br></pre></td></tr></table></figure>
<p><strong>面试的初衷还是要在一个时间段内（1 小时）尽量了解应聘同学的各方面是不是适合这个岗位。应试会有些用。但最关键还是平时的积累和思考。</strong></p>
<p><a href="https://testerhome.com/topics/30722#reply9">大厂面试问题汇总</a></p>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><ul>
<li><strong>熟悉系统，发现问题解决问题，系统学习</strong></li>
</ul>
<h3 id="完成规划"><a href="#完成规划" class="headerlink" title="完成规划"></a>完成规划</h3><p><em><strong>补全基础知识</strong></em></p>
<ul>
<li><a href="https://blog.51cto.com/u_15127510/4549327">高级软件测试分析师</a></li>
<li>高级软件测试管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>面试话题</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DevOps一体化研发体系：需结合自己公司的CICDCT体系进行说明,深化出他的理解</span><br><span class="line">工作中的技巧：时间不足场景/线上问题场景/绩效汇报/工作汇报的场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>pytest 框架</title>
    <url>/posts/7e188ca1/</url>
    <content><![CDATA[<p><code>pytest是一个单测框架；能对定义的测试对象进行测试，并且可以针对测试对象进行前后置处理，对测试结果进行断言，对执行过程中的异常进行干预，并且可以收集测试结果以生成xml格式的测试报告</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原理</span><br><span class="line">使用场景</span><br><span class="line">如何使用</span><br><span class="line">①调度/执行</span><br><span class="line">②前后置处理（固件）</span><br><span class="line">③用例断言</span><br><span class="line">④异常处理</span><br><span class="line">⑤参数化</span><br><span class="line">⑥定制报告</span><br><span class="line">⑦性能-缓存</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>pytest是一套单测框架；有着自己的巡检方法，他会自动查找整个包中以test开头/结尾的模块，并查找其中test开头/结尾的方法/类（类很特殊必须要以Test开头，且类中不能有__init__方法），全部保存在内存中，在触发执行时，会根据调度指令来确定自动执行的用例范围，来进行执行； 同时执行用例时做了装饰器操作，将用例作为参数传递到pytest框架中执行。</code></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><strong>用例自动单测场景：</strong> 如接口自动化、UI自动化、各类用例场景；</li>
<li><strong>通用前后置处理场景：</strong> 如数据库操作前的建立连接，操作完成后的断开连接；</li>
<li><strong>参数化操作场景：</strong> 如多设备操作、各种UI操作、各种接口操作；</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><code>分为：调度/执行、前后置处理（固件）、用例(断言+异常处理+跳过+标记)、参数化、定制报告、性能（缓存操作）</code></p>
<h3 id="调度-执行"><a href="#调度-执行" class="headerlink" title="调度/执行"></a>调度/执行</h3><p><strong>调度有两种方式：命令行、pytest.main()</strong></p>
<ul>
<li><p><strong>pytest.main()：</strong><code>实际也是调用命令行来进行的操作，我们程序一般使用pytest.main()来调度；注意pytest.main([&#39;-m&#39;,&#39;对象&#39;]);第一个参数是选项，第二个参数是对象；pytest.main()会将当前模块加入缓存，因此不建议执行过程中调用多次，最好只调用一次，示例如下。</code></p>
<ul>
<li>pytest.main([“-qq”], plugins=[MyPlugin()])        //指定一个插件运行</li>
<li>pytest.main([‘-sq’,’test_nodeid.py::TestNodeId::test_two[1-1]’])</li>
</ul>
</li>
<li><p><strong>命令行调用：</strong><code>pytest 各选项如-rx 对象如test_1.py::test_fun </code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对象：可通过命令行执行特定包内的用例/特定目录下/特定模块/特定方法/特定方法的特定参数化参数</span><br><span class="line">pytest –pyargs pkg.testing</span><br><span class="line">pytest testing/pytest test_mod.py/pytest test_mod.py::test_fun</span><br><span class="line">pytest -q -s test_nodeid.py::TestNodeId::test_two[1-1]</span><br><span class="line"></span><br><span class="line">模糊匹配：执行含特定字符或（也可以是和）不含特定字符的模块/类/函数：</span><br><span class="line">pytest -k “_class and/or not two”</span><br><span class="line"></span><br><span class="line">还可以为用例添加标记。从而指定特定标记的用例:pytest -m 标记名</span><br><span class="line">@pytest.mark.标记名</span><br><span class="line">def test_one()</span><br></pre></td></tr></table></figure></li>
<li><p><strong>pytest自动巡检机制：</strong><code>pytest会自动化去查找到测试用例，他是按模块的首尾是否是test来判断的，模块中的类（类很特殊必须要以Test开头，且类中不能有__init__方法）/方法首尾是test则判定为测试用例，这些测试用例维护在内存中，以数组的形式维护，触发执行时会自动执行这些用例；用例执行顺序是按测试用例的名称从大到小来的，可以利用pytest-ordering插件来定制用例的执行顺序； 默认情况下执行pytest.main()时仅执行当前模块的用例，如果需要执行其他路径下的用例，可以指定路径。</code></p>
</li>
<li><p><strong>常用命令行选项</strong></p>
<ul>
<li><strong>查看结果</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest -q							//-q选项可以查看精简版的测试报告</span><br><span class="line">pytest -r							//(同-q只是可以过滤)显示精简的总结报告；-r后还要加一个参数，表示需要显示的内容，其他的会过滤，如-rfs(f是失败的，s是跳过的，显示失败的和跳过的实例)</span><br><span class="line">pytest -s							//-s是--capture=no的快捷方式，是用来关闭输出(标准输出/标准错误)捕获，使得可以看到<span class="built_in">print</span>()输出的内容</span><br><span class="line">pytest --capture=fd（默认捕获行为）	//指定只捕获文件/接口层面的标准输出/标准错误</span><br><span class="line">pytest --capture=sys				//指定只捕获系统级别的标准输出/标准错误</span><br><span class="line">pytest -l, --showlocals         <span class="comment"># 打印本地变量</span></span><br><span class="line">pytest --tb=auto              <span class="comment"># 默认模式</span></span><br><span class="line">pytest --tb=long              <span class="comment"># 尽可能详细的输出</span></span><br><span class="line">pytest --full-trace				   //比--tb=long更详细的输出模式</span><br><span class="line">pytest --tb=short             <span class="comment"># 更简短的输出</span></span><br><span class="line">pytest --tb=line              <span class="comment"># 每个失败信息总结在一行中</span></span><br><span class="line">pytest --tb=native             <span class="comment"># python的标准输出</span></span><br><span class="line">pytest --tb=no               <span class="comment"># 不打印失败信息</span></span><br><span class="line">pytest --pdb                 //失败时进入pdb诊断器模式</span><br><span class="line">pytest --trace						 //启动时就进入pdb诊断器模式</span><br><span class="line">pytest --durations=10				 //获取执行最慢的十个测试用例</span><br><span class="line">pytest -vv							 //获取用例的执行时间</span><br><span class="line">pytest --show-capture				 //定义是否显示，标准输出、标准错误、或异常堆栈；支持的选项值有[no,stdout,stderr,<span class="built_in">log</span>,all，默认为all]</span><br><span class="line">pytest --assert=plain选项			  //关闭断言失败提示信息</span><br><span class="line">python  -p no:faulthandler 		   //默认是打开的，可以通过此命令关闭回溯信息当用例执行出现断错误或超时，faulthandler模块，可以展示Python脚本的回溯信息（回溯不是错误信息，此时程序也不会中断，只是打印此时的相关信息，类似监控）;</span><br><span class="line">faulthandler_timeout=5			   //（pytest.ini文件配置）可以配置超时时间，一旦超时则显示所有线程的回溯信息</span><br><span class="line">pytest -o faulthandler_timeout=X   //命令行配置超时时间</span><br><span class="line">pytest --disable-warnings			//命令行选项来阻止，告警信息的显示（有捕获告警只是不显示）</span><br><span class="line">pytest -p no:warnings          //命令行，直接禁止告警的捕获；</span><br><span class="line"></span><br><span class="line">pytest -q -s --collect-only test_params.py	//collect-only仅显示测试ID，不执行用例（用来收集测试用例的名称）</span><br><span class="line">设置固件的测试ID：使用ids @pytest.fixture(params=[0, 1], ids=[<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>]),也可以用一个函数来动态生成测试ID@pytest.fixture(params=[0, 1], ids=fun());</span><br><span class="line">同理也可以设置用例的测试ID：@pytest.mark.parametrize(argnames, argvalues, indirect=False, ids=None, scope=None) 参数化时ids是每个测试的实例的测试ID，报告可以记录，默认值是每一个实例的argvalue_拼接，如上是1_2；手动定义时ids值长度必须和argvalue长度保持一致；默认所有的id都进行了ascii编码，可以在pytest.ini中禁用ascii编码</span><br><span class="line">（disable_test_id_escaping_and_forfeit_all_rights_to_community_support = True）</span><br></pre></td></tr></table></figure></li>
<li><strong>执行</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest ::							//执行指定的模块方法/类</span><br><span class="line">pytest path							//执行指定路径及子路径下的所有以<span class="built_in">test</span>开头或结尾的模块中，以<span class="built_in">test</span>开头或结尾的方法/类</span><br><span class="line">pytest -k 							//模糊匹配要执行的用例</span><br><span class="line">pytest -m							//执行指定标记用例</span><br><span class="line"></span><br><span class="line">pytest -x							//pytest遇到第一个失败时退出执行</span><br><span class="line">pytest --maxfail==2					//设定允许失败的最大次数</span><br><span class="line">pytest -p mypluginmodule		//-p尽早加载插件，插件可以是本地的插件，也可以是公共插件</span><br><span class="line">pytest -p no:doctest			//加no提前阻止插件的加载</span><br></pre></td></tr></table></figure></li>
<li><strong>结果</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest --junitxml=path  		//在path路径生成一个xml格式的测试报告</span><br><span class="line">junit_suite_name = 节点名   	//（pytest.ini中）自定义XML文件中testsuite根节点的名称</span><br><span class="line">junit_duration_report = call	   //（pytest.ini）报告只记录测试用例时间，不含前后置时间，默认time属性是含所有时间的</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="固件-前后置处理"><a href="#固件-前后置处理" class="headerlink" title="固件-前后置处理"></a>固件-前后置处理</h3><p><code>固件的作用是提供了一个固定的基线，能重复的运行；固件装饰器(@pytest.fixture)的作用是注册一个固件，测试用例可以通过显示调用的方式使用固件（固件作为入参），调用的是固件的形参，实际生效的是固件的返回对象作为入参；默认可以不调用固件，因为固件默认配置了自动调用</code></p>
<ul>
<li><p><strong>作用：固件的作用主要是进行用例的前后置处理</strong><br><code>固件根本作用域的不同，可以分别针对session/包/模块/类/方法进行前后置处理</code></p>
</li>
<li><p><strong>前后置处理</strong></p>
<ul>
<li><strong>实现示例：前后置处理有三种实现方式：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前后置处理方法1-yield</span></span><br><span class="line">@pytest.fixture()</span><br><span class="line">def smtp_connection_yield():</span><br><span class="line">    smtp_connection = smtplib.SMTP(<span class="string">&quot;smtp.163.com&quot;</span>, 25, timeout=5)</span><br><span class="line">    yield smtp_connection</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;关闭SMTP连接&quot;</span>)</span><br><span class="line">    smtp_connection.close()</span><br><span class="line">   </span><br><span class="line"><span class="comment">#前后置处理方法2-利用上下文自动关闭对象</span></span><br><span class="line">@pytest.fixture()</span><br><span class="line">def smtp_connection_yield():</span><br><span class="line">    with smtplib.SMTP(<span class="string">&quot;smtp.163.com&quot;</span>, 25, timeout=5) as smtp_connection:</span><br><span class="line">        yield smtp_connection</span><br><span class="line">        </span><br><span class="line"><span class="comment">#利用注册的方式，来注册后置处理</span></span><br><span class="line">@pytest.fixture()</span><br><span class="line">def smtp_connection_fin(request):</span><br><span class="line">    smtp_connection = smtplib.SMTP(<span class="string">&quot;smtp.163.com&quot;</span>, 25, timeout=5)</span><br><span class="line"></span><br><span class="line">    def fin():</span><br><span class="line">        smtp_connection.close()</span><br><span class="line"></span><br><span class="line">    request.addfinalizer(fin)</span><br><span class="line">    <span class="built_in">return</span> smtp_connection</span><br><span class="line">    </span><br><span class="line">//(这个后置操作，只能对前置产生的实例对象生效)    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>固件的使用</strong></p>
<ul>
<li><strong>放置位置：</strong> 固件一般是放置在conftest.py模块中统一维护；当然也可以在用例模块中定义固件；固件是支持显示调用（作为测试用例的入参）和自动调用的（默认就支持@pytest.fixture(autouse=True）autouse=True可省略）</li>
<li><strong>作用域</strong><br><code>固件一般放置在conftest.py模块中，而此模块一般放置根目录/功能目录的顶层（可以放置多个此模块，按就近原则生效，也就是在用例当前目录找到固件后就不去上一级查找）；可以为每个固件定义作用域，定义完后，固件分别在作用域的范围内执行，默认的作用域是@pytest.fixture(scope=&#39;function&#39;),作用域主要决定的是执行次数和执行顺序</code></li>
</ul>
<p><strong>支持的作用域有：@pytest.fixture(scope=’function/class/module/session/package’,autouse=True)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@pytest.fixture(scope=<span class="string">&#x27;function&#x27;</span>）			//每个用例方法都执行一遍固件的前后置处理</span><br><span class="line">@pytest.fixture(scope=<span class="string">&#x27;class&#x27;</span>）				//每个用例类仅执行一遍固件的前后置处理</span><br><span class="line">@pytest.fixture(scope=<span class="string">&#x27;module&#x27;</span>）				//每个模块仅执行一遍固件的前后置处理</span><br><span class="line">@pytest.fixture(scope=<span class="string">&#x27;session&#x27;</span>）			//每个会话对象仅执行一遍固件的前后置处理</span><br><span class="line">@pytest.fixture(scope=<span class="string">&#x27;package&#x27;</span>）			//每个包仅执行一遍固件的前后置处理</span><br><span class="line"></span><br><span class="line">类显示的调用固件：@pytest.mark.usefixtures(<span class="string">&#x27;固件名&#x27;</span>,<span class="string">&#x27;第二个固件&#x27;</span>)，此装饰器也可以给fun使用；</span><br><span class="line">模块显示的调用固件：<span class="built_in">test</span>=pytest.mark.usefixtures(<span class="string">&quot;transact&quot;</span>)</span><br><span class="line"></span><br><span class="line">可以使用固件来生成工厂函数，从而实现模块化，和函数定制（此时固件是可以接受参数的）；</span><br><span class="line"></span><br><span class="line">固件可以进行参数化：如下，固件进行参数化后会创建多个实例，因此使用这些实例的测试用例也会执行多次</span><br><span class="line">@pytest.fixture(params=[(<span class="string">&#x27;3+5&#x27;</span>, 8),pytest.param((<span class="string">&#x27;6*9&#x27;</span>, 42),</span><br><span class="line">              marks=pytest.mark.xfail,id=<span class="string">&#x27;failed&#x27;</span>)])</span><br><span class="line"> 如果不想执行多次，可以使用模糊匹配来匹配具体到具体的实例： pytest -k 163 用例       //固件进行参数化时，一定是一个实例执行完后（含前后置处理，才开始新的实例工作）    </span><br><span class="line">//同上固件可以打标记，配置测试ID；使用参数化装饰器等价的方法如下：</span><br><span class="line">@pytest.mark.parametrize(<span class="string">&#x27;test_input, expected&#x27;</span>,[(<span class="string">&#x27;3+5&#x27;</span>, 8),</span><br><span class="line">     pytest.param(<span class="string">&#x27;6*9&#x27;</span>, 42, marks=pytest.mark.xfail,id=<span class="string">&#x27;failed&#x27;</span>)])	</span><br><span class="line">//给固件重命名后，原来的名字不可用，只能使用新的名称来显示的调用固件：@pytest.fixture(name=<span class="string">&quot;my_fixture_alias&quot;</span>)</span><br><span class="line">用例按条件执行固件：@pytest.mark.parametrize(<span class="string">&quot;condition&quot;</span>, [True, False])</span><br><span class="line">//复写操作，除了在conftest中，用例模块中，还可以在用例的参数化中进行复写(不做特殊配置时，参数名会覆盖同名固件)</span><br><span class="line">@pytest.mark.parametrize(<span class="string">&#x27;已定义固件名&#x27;</span>, [<span class="string">&#x27;directly-overridden-username&#x27;</span>])</span><br><span class="line"></span><br><span class="line">每个用例可以执行多个固件；执行顺序是显示调用优先级&gt;自动调用；按作用域大小来，作用域越大越优先；作用域相同时，按从上到下的顺序来，不过，固件中参数是固件时调用的固件要优先执行；查找固件的顺序则按就近原则；</span><br></pre></td></tr></table></figure>
<ul>
<li>pytest内置的固件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest有现成的一些固件，可以直接在测试用例中调用，或者在自定义的固件中调用；</span><br><span class="line">查看现成的固件的方法：pytest -q -v --fixtures；</span><br><span class="line">在程序执行时，动态的修改对象（使用固件monkeypatch）;这种修改是临时性的，不改本地代码；</span><br><span class="line">创建临时文件/目录，（使用tmp_path）；</span><br><span class="line">在测试用例中访问捕获信息（即标准输出/标准错误）:可以使用固件capsys、capfd、capsysbinary </span><br><span class="line">  capsys捕获的是系统级别，如capsys.readouterr()结果是个系统级别的标准输出和标准错误的元组</span><br><span class="line">  capfd捕获的是文件/接口级别，如capfd.readouterr()结果是个接口级别的标准输出和标准错误的元组</span><br><span class="line">  capsysbinary用来返回非文本型的数据，capsysbinary.readouterr()返回的是字节流</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特殊场景-文档测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文档测试/注释测试；pytest会自动收集所有名称匹配<span class="built_in">test</span>*.txt规则的文件，并调用doctest执行它们；注释中的代码的执行使用的是Python的标准库doctest模块来实现的；</span><br><span class="line">注释需要满足几个条件：</span><br><span class="line">①文件名称是以<span class="built_in">test</span>开头或结尾的Python文件；</span><br><span class="line">②文档字符串中的注释必须是类似python交互式会话形式的注释(&gt;&gt;&gt; something())</span><br><span class="line">//可以通过pytest --doctest-glob=<span class="string">&#x27;*.rst&#x27;</span>来扩展支持的文档格式</span><br><span class="line">//执行文档中的注释代码，必须要加选项pytest --doctest-modules命令行选项;也可以在pytest.ini文件中配置指定必须要文档测试[pytest]</span><br><span class="line">addopts = --doctest-modules</span><br><span class="line">//用pytest --doctest-continue-on-failure选项在文档测试遇到第一个失败后继续执行</span><br><span class="line">//可以定制文档测试失败后的，失败输出格式pytest --doctest-modules --doctest-report none/udiff/cdiff/ndiff</span><br><span class="line">通过在文档中添加<span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span>&gt;&gt;&gt; tmp = getfixture(<span class="string">&#x27;tmpdir&#x27;</span>)<span class="string">&#x27;&#x27;</span><span class="string">&#x27;的方式在文档中使用固件;通过doctest_namespace 固件定义的参数，可以在文档中直接使用</span></span><br></pre></td></tr></table></figure>
<p><strong>使用pytest.skip(‘注释’)，直接跳过文档测试，默认不执行文档测试</strong></p>
</li>
</ul>
<h3 id="用例-断言-异常处理-跳过-标记"><a href="#用例-断言-异常处理-跳过-标记" class="headerlink" title="用例:(断言+异常处理+跳过+标记)"></a>用例:(断言+异常处理+跳过+标记)</h3><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><ul>
<li><strong>示例</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常规断言</span></span><br><span class="line">def test_</span><br><span class="line">	assert True		//如果判断条件的结果为True则断言成功；</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定预期异常</span></span><br><span class="line">def test_mytest():</span><br><span class="line">    with pytest.raises(SystemExit) as excinfo:</span><br><span class="line">        f()		//若用例没抛出指定异常则断言失败，且必须是上下文中的最后一行，因为raises之后的不会被执行</span><br><span class="line">    assert <span class="string">&#x27;456&#x27;</span> <span class="keyword">in</span> str(excinfo.value)	//excinfo是上下文的实例，且在上下文环境中   </span><br><span class="line"></span><br><span class="line"><span class="comment">#可以给异常加标记</span></span><br><span class="line">@pytest.mark.xfail(raises=IndexError)	//可以给异常加标记,出现IndexError，则标记用例失败类型为xfail，这种用法一般用来标记未修复的bug</span><br><span class="line">def test_f():</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>
除了断言还可以设置断点：使用pdb.set_trace()，只影响断点用例；</li>
</ul>
<p><strong>异常的结果</strong>    </p>
<ul>
<li>不同数据类型的断言，不同地方都会标记出来；</li>
<li>可以给断言失败，添加说明，可以用运算重载符，出现系统提示的字符串异常时，重载为我们想要的内容；第二种是利用钩子pytest_assertrepr_compare，来自定义异常；</li>
<li>断言的异常信息，会存储在本地，如需禁止可以在conftest.py文件中加入这些配置实现：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.dont_write_bytecode = True</span><br></pre></td></tr></table></figure></li>
<li>关闭断言的失败提示功能：有两种方式（基本不会关闭）<ul>
<li>在需要关闭提示的模块的docstring中添加PYTEST_DONT_REWRITE字符串；</li>
<li>执行pytest时，添加–assert=plain选项</li>
</ul>
</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning告警，可以手动通过warnings.warn方法来触发特定的告警；</span><br><span class="line">recwarn fixture的功能和pytest.warning()等价；</span><br><span class="line">可以通过命令行 pytest -W arg(action:message:category:module:lineno)方式来执行，从而自定义捕获的告警；</span><br><span class="line">等价行为是通过pytest.ini配置文件来配置filterwarnings项（用来自定义过滤，也可以配置不捕获）；等价的装饰器为@pytest.mark.filterwarnings；</span><br><span class="line">--disable-warnings命令行选项来阻止，告警信息的显示（有捕获告警只是不显示）；</span><br><span class="line">-p no:warnings命令行，直接禁止告警的捕获；</span><br><span class="line">等价的使用pytest.deprecated_call方法来调用告警对象，也会实现禁止捕获告警；</span><br><span class="line">assert pytest.warns((DeprecationWarning, PendingDeprecationWarning), api_call_v1, match=r<span class="string">&#x27;和 pytest.raises() 方法一样，这时 pytest 不再判断告警信息是否正确&#x27;</span>) == 200</span><br><span class="line">来通过匹配告警，这个操作是匹配到的告警不显示,同时进行断言；</span><br><span class="line"></span><br><span class="line">异常提示：pytest.fail(<span class="string">&#x27;期望 api_call_v1 触发一个告警，实际上没有；&#x27;</span>)用来触发异常提示；</span><br></pre></td></tr></table></figure>
<h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><p><code>使用标记来给用例打上不同的标记，从而在结果收集时，实现对用例的区分；</code></p>
<ul>
<li><strong>查看用例标记：</strong><br><code> 使用 pytest -r来定制显示不同标记的用例；支持的标记有 (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed, (p)assed, (P)assed with output, (a)ll except passed(p/P), or (A)ll</code></li>
<li><strong>@pytest.mark.xfail()用来标记预期是失败的用例，如果满足预期的失败，则结果为xfail,如果是成功，则结果一般是xpass，可能是FAILED，详情如下</strong></li>
</ul>
<p><img src="/text_image/pytest_xfail.png" alt="alt text"></p>
<ul>
<li><code>标记可以和参数化装饰器结合，他提供了一个方法 pytest.param，可以给每个参数对应的实例打一个标记，并给一个测试id</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@pytest.mark.parametrize(</span><br><span class="line">    (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;expected&#x27;</span>),</span><br><span class="line">    [(2, 1),</span><br><span class="line">     pytest.param(2, 1, marks=pytest.mark.xfail(), id=<span class="string">&#x27;XPASS&#x27;</span>),</span><br><span class="line">     pytest.param(0, 1, marks=pytest.mark.xfail(raises=ZeroDivisionError), id=<span class="string">&#x27;XFAIL&#x27;</span>),</span><br><span class="line">     pytest.param(1, 2, marks=pytest.mark.skip(reason=<span class="string">&#x27;无效的参数，跳过执行&#x27;</span>)),</span><br><span class="line">     pytest.param(1, 2, marks=pytest.mark.skipif(sys.version_info &lt;= (3, 8), reason=<span class="string">&#x27;请使用3.8及以上版本的python。&#x27;</span>))])</span><br><span class="line">def test_params(n, expected):</span><br><span class="line">    assert 2 / n == expected</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="跳过"><a href="#跳过" class="headerlink" title="跳过"></a>跳过</h4><p><strong>跳过用例的方法总结如下：</strong><br><img src="/text_image/pytest_skip.png" alt="alt text"><br><code>其中@pytest.mark.skipif     //如果一个用例有多个条件跳过装饰器，满足任意一个即跳过； @pytest.importorskip装饰器是会先进行import模块操作，同时会判断模块的版本；如果版本不对，或import失败则跳过；</code></p>
<h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><h4 id="固件的参数化"><a href="#固件的参数化" class="headerlink" title="固件的参数化"></a>固件的参数化</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用@pytest.fixture(params=[(<span class="string">&#x27;3+5&#x27;</span>, 8),pytest.param((<span class="string">&#x27;6*9&#x27;</span>, 42),</span><br><span class="line">              marks=pytest.mark.xfail,id=<span class="string">&#x27;failed&#x27;</span>)])；和pytest.mark.parametrize装饰器是等价的</span><br></pre></td></tr></table></figure>
<h4 id="测试用例参数化"><a href="#测试用例参数化" class="headerlink" title="测试用例参数化"></a>测试用例参数化</h4><p><code>参数化是指对用例的参数传递不同的值，来执行多次，从而覆盖用例不同的场景（不同值）</code></p>
<ul>
<li><strong>对象</strong><ul>
<li>可以对测试用例方法进行参数化</li>
<li>可以对测试类进行参数化</li>
<li>可以对模块进行参数化：<code>pytestmark = pytest.mark.parametrize(&#39;test_input, expected&#39;, [(1, 2), (3, 4)])后续的用例直接调用参数即可</code></li>
</ul>
</li>
<li><strong>方法：@pytest.mark.parametrize(argnames, argvalues, indirect=False, ids=None, scope=None)</strong><ul>
<li><strong>argnames：</strong><code>参数名必须是用例引入的参数的子集（fun(arg1,arg2),必须是这两个参数的子集）；且引入的参数必须是没有默认值的；结构可以是用逗号分隔的字符串，或者一个列表/元组; 参数名默认会覆盖同名的固件;</code></li>
<li><strong>argvalues：</strong><code>实际返回的是一个命名元祖，ParameterSet(values=(1, 2), marks=[], id=None)];可以不带标记和测试id,也可以带；结构上必须是一个可迭代对象可以是[(1, 2), [2, 3], set([3, 4])]/方法返回的可迭代对象； 如果argvalue要带标记和测试ID，可以这样实现：pytest.param(2, 1,  marks=pytest.mark.xfail(), id=&#39;XPASS&#39;)param方法实际是对命名元祖的封装；</code></li>
<li><strong>indirect参数：</strong><code>有默认值，为TRUE表示参数名不覆盖同名固件，且参数值要传递给固件，最后固件的返回才是实参@pytest.mark.parametrize(&#39;min, max&#39;, [(1, 2), (3, 4)], indirect=True/[&#39;max&#39;])    //[&#39;max&#39;]仅指定这个参数名不覆盖固件</code></li>
<li><strong>ids：</strong><code>ids是每个测试的实例的测试ID，报告可以记录，默认值是每一个实例的argvalue_拼接，如上是1_2；手动定义时ids值长度必须和argvalue长度保持一致；默认所有的id都进行了ascii编码，可以在pytest.ini中禁用ascii编码（disable_test_id_escaping_and_forfeit_all_rights_to_community_support = True） 可以构造函数方法来使用每个的argvalue参数来生成ids，类似ids=fun()</code></li>
<li><strong>scope：</strong><code>scope定义的是argnames的作用域，并通过argvalues的实例划分测试用例，影响到测试用例的收集顺序（不同用例，相同参数时，会根据值的大小来划分收集顺序；如果参数是固件时，且不覆盖，则参数的作用域，就是固件的作用域，按这个顺序收集测试结果，默认是function级别）</code></li>
<li><strong>特殊情况：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果参数化没传值时，实例的结果将会被设置为SKIPPED；</span><br><span class="line">这种情况可以在pytest.ini中设置empty_parameter_set_mark选项来改变这种行为，可以的值如下:</span><br><span class="line">  skip：默认值</span><br><span class="line">  xfail：执行跳过直接将示例标记为XFAIL，等价于xfail(run=False)</span><br><span class="line">  fail_at_collect：上报一个CollectError异常；</span><br></pre></td></tr></table></figure>
<strong>一个用例上可以有多个参数化标记，执行顺序是从近到远，组合提供值<br>@pytest.mark.parametrize(‘test_input’, [1, 2, 3])<br>@pytest.mark.parametrize(‘test_output, expected’, [(1, 2), (3, 4)])<br>结果：1_2_1,1_2_2,1_2_3,3_4_1,…</strong></li>
</ul>
</li>
</ul>
<h3 id="定制报告"><a href="#定制报告" class="headerlink" title="定制报告"></a>定制报告</h3><p><strong>为测试报告中的测试用例添加额外的信息，使用record_property fixture</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def test_record_property(record_property):</span><br><span class="line">    record_property(<span class="string">&quot;test_id额外信息&quot;</span>, 10010额外信息值)</span><br><span class="line">    assert 1</span><br><span class="line">也可以在测试报告中加入用例的标记信息		//修改pytest_collection_modifyitems钩子方法，添加对test_id标记的支持;</span><br><span class="line">可以为测试报告添加用例额外的属性信息		//使用record_xml_attribute fixture</span><br><span class="line">可以在测试报告中为整个测试集添加额外的信息；</span><br><span class="line"></span><br><span class="line">可以在报告中为用例创建链接</span><br><span class="line">pytest --pastebin=all			//为所有用例创建链接</span><br><span class="line">pytest --pastebin=failed		//为失败用例创建链接</span><br></pre></td></tr></table></figure>
<p><strong>其他的对测试报告的定制操作，见上方选项合集</strong></p>
<h3 id="性能-缓存"><a href="#性能-缓存" class="headerlink" title="性能-缓存"></a>性能-缓存</h3><ul>
<li><p><strong>是什么：</strong><code>pytest执行时默认会在根目录生成一个.pytest_cache文件夹，用来记录执行的情况，主要记录执行的所有失败（lastfailed）、执行的所有实例（nodeids）、最近一次失败（stepwise）、缓存配置数据（）;缓存是通过pytest自带的cacheprovider插件来实现；</code></p>
</li>
<li><p><strong>作用：</strong><code>可以通过选项来依赖缓存的结果和配置数据来定制执行的顺序、和跳过某些用例、使用缓存配置数据，从而提高性能；</code></p>
</li>
<li><p><strong>怎么样：</strong><code>生成缓存文件-控制执行顺序（范围）；</code></p>
<ul>
<li>缓存文件：默认位置是根目录生成一个.pytest_cache文件夹；可以通过pytest.ini中配置cache_dir = .pytest-cache来自定义缓存文件夹路径，可配置相对和绝对路径；</li>
<li>缓存中主要起作用的是lastfailed(所有失败实例)/nodeids（所有实例）/stepwise（最近失败实例）</li>
</ul>
</li>
</ul>
<p>│   └───.pytest-cache<br>│       │   .gitignore<br>│       │   CACHEDIR.TAG<br>│       │   README.md<br>│       │<br>│       └───v<br>│           └───cache<br>│                   lastfailed<br>│                   nodeids<br>│                   stepwise</p>
<ul>
<li><strong>控制执行顺序（范围）:通过一些选项来利用上面的文件控制实例的执行顺序，并且过滤一些实例</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看缓存：pytest src/chapter-12/ -q --cache-show <span class="string">&#x27;lastfailed&#x27;</span>/<span class="string">&#x27;nodeids&#x27;</span>/<span class="string">&#x27;stepwise&#x27;</span></span><br><span class="line">pytest --lf --collect-only src/chapter-12/			//仅执行已经收集到的失败实例</span><br><span class="line">pytest --collect-only -s --ff src/chapter-12/		//先执行上次收集到的失败实例，在执行其他</span><br><span class="line">pytest --collect-only -s --nf src/chapter-12/		//先执行新添加的-继而执行修改的（按最晚修改最先执行）-最后执行其他实例；</span><br><span class="line">pytest --cache-clear -q -s src/chapter-12/test_pass.py	//先删除缓存文件夹（pytest-cache），在创建缓存文件夹，保存最新的缓存数据</span><br><span class="line"></span><br><span class="line">//以下都用于之前没有采集到失败实例的场景</span><br><span class="line">pytest -q -s --ff --lfnf none src/chapter-12/test_pass.py		//会忽略失败</span><br><span class="line"></span><br><span class="line">pytest -q -s --ff --lfnf all src/chapter-12/test_pass.py		//遇到失败就结束了，只保留之前的成功的</span><br><span class="line"></span><br><span class="line"><span class="comment">#缓存配置数据</span></span><br><span class="line">@pytest.fixture</span><br><span class="line">def mydata(request):</span><br><span class="line">    val = request.config.cache.get(<span class="string">&quot;example/value&quot;</span>, None)		//读取缓存配置</span><br><span class="line">    <span class="keyword">if</span> val is None:</span><br><span class="line">        expensive_computation()</span><br><span class="line">        val = 42</span><br><span class="line">        <span class="comment">#设置缓存配置。没有文件时，会先创建在设置，已存在会覆盖旧的</span></span><br><span class="line">        request.config.cache.set(<span class="string">&quot;example/value&quot;</span>, val)		</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line"></span><br><span class="line">stepwise文件用来记录最近一次的失败；可以指定从这个失败开始执行，用此选项调度一般遇到失败pytest就会结束执行如下：</span><br><span class="line">pytest --cache-clear --sw -q src/chapter-12/test_sample.py		</span><br><span class="line">//--cache-clear见上方删除旧缓存，--sw是（stepwise缩写），此选项执行时，遇到失败就会结束整个pytest,并将这个失败记录到stepwise文件；如果不指定--sw选项，这个文件不记录数据；下次在也--sw选项执行时，会优先执行stepwise文件中记录的实例，当遇到下一个失败时才结束，并且会使用新的失败来覆盖这个文件；</span><br><span class="line">pytest --sw --stepwise-skip -q src/chapter-12/test_sample.py	//跳过这个失败，继续执行后面的，遇到后续的失败在结束；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://learning-pytest.readthedocs.io/zh/latest/doc/intro/getting-started.html">pytest-概要版</a><br><a href="https://github.com/luizyao/pytest-chinese-doc">官方文档-中文版</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>实战--传音预装</title>
    <url>/posts/fbd896d0/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">确认需要覆盖的场景；</span><br><span class="line">场景的指标监控；</span><br><span class="line">构建脚本；</span><br><span class="line">分析监控数据，采集异常数据定位问题；</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><strong>确认需要覆盖的场景：</strong></li>
</ul>
<p><code>一般需要覆盖功能/性能/兼容/耗电/升级这几块，功能一般覆盖app的主功能</code></p>
<ul>
<li><em>方案：</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动app,点击播放栏播放按钮播放music，在切换到后台，在切换回前台；</span><br><span class="line">treding页上下滑动，在切换到music页上下滑动，在切换回treding页；</span><br><span class="line">music页点击歌单，进入歌单，歌单上下滑动两页，然后返回music页；在点击进入chart页，上下滑动两页，在返回；在点击进入艺人页，上下滑动两页，在返回；在点击进入曲风页，上下滑动，在进入第一个曲风，上下滑动，然后返回music首页；在次进入歌单页，上下滑动，然后在次点击第一个歌单进入歌单详情页，然后返回music首页；点击进入视频页，上下滑动，然后返回music首页；点击进入bbc，上下滑动，然后返回music首页；</span><br><span class="line">treding页播放music，然后返回treding;进入music页，点击歌单上浮按钮，进行全部播放，点击歌单详情页的全部播放按钮进行播放，点击歌单详情页的music播放，返回music后；进入播放列表，点击music播放；在进入播放详情页，切歌播放，在返回music首页，点击进入video页，点击视频进行播放，返回treding页;</span><br><span class="line">treding页进行music下载，music首页歌单全局下载按钮进行下载，点击进入歌单详情页，通过全部下载按钮进行下载，进入播放详情页，下载music；</span><br><span class="line">library页，通过localmusic或者下载music对本地下载的music进行播放，播放和后台循环切换；</span><br><span class="line">后台播放music时，分别同时打开，Facebook，WhatsApp，Twitter，Instagram，chrome；在切换回前台；</span><br><span class="line">music页/library页/buzz页/account页进行循环切换；</span><br><span class="line">buzz页，一二级页面循环切换，且每个页面均进行上下滑动；buzz页，点击评论和点赞按键；</span><br><span class="line">account页，进行登录，退出应用，切换回前台，退出登录；</span><br><span class="line">notification,页面循环切换，且每个页面进行上下滑动；</span><br><span class="line">前台常驻10分钟，切换到后台常驻10分钟，在切换回前台；</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>场景的指标监控：</strong></p>
<p>  <code>由于渠道方未提供确切的合规标准，因此选用网易云音乐作为对比范本；在相同场景下，资源消耗超出网易云10%-30%判定为合规，否则判断为异常</code></p>
<ul>
<li><em>监控性能工具：</em></li>
</ul>
<p>  支付宝：solopi</p>
<ul>
<li><em>监控指标：</em></li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU:cpu_max,cpu_ave;需要区分进程cpu和系统cpu</span><br><span class="line">ROM:需要监控pps&#x2F;privatedirty-main&#x2F;全局内存&#x2F;activity的内存泄露&#x2F;是否有oom问题，同时需要提供hprof文件；</span><br><span class="line">带宽：环境带宽，最大占用的带宽；</span><br><span class="line">响应耗时：前端渲染耗时；</span><br><span class="line">启动耗时：应用启动耗时，activity启动耗时；</span><br><span class="line">电量：前台&#x2F;高频&#x2F;后台常驻电量消耗；</span><br><span class="line">流量：前台&#x2F;高频&#x2F;后台常驻消耗,升级，下载时的资源消耗；</span><br><span class="line">app抛出的异常堆栈：监控adb日志获取；</span><br><span class="line">场景数据：查看工具报告，和工具收集的异常数据；</span><br><span class="line">线程状态：监控app创建的所有线程及状态；</span><br></pre></td></tr></table></figure>
<ul>
<li><em>网易指标</em><ul>
<li><strong>场景1：</strong> 启动app,点击播放栏播放按钮播放music，在切换到后台，在切换回前台；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程cpu:31.04&#x2F;20.68&#x2F;22.62&#x2F;28.35&#x2F;35.68(max)&#x3D;27.33	11.22&#x2F;10.30&#x2F;10.65&#x2F;9.11&#x2F;13.36(ave)&#x3D;10.72</span><br><span class="line">总cpu:86.08&#x2F;79.02&#x2F;78.69&#x2F;91.11&#x2F;87(max)&#x3D;84.03	45.80&#x2F;44.40&#x2F;41.81&#x2F;40.14&#x2F;48.35(ave)&#x3D;44</span><br><span class="line">private-ram:196.40&#x2F;243.39&#x2F;168.5&#x2F;157.63&#x2F;168.03(max)&#x3D;177.64	186.76&#x2F;231.17&#x2F;158.1&#x2F;144.2&#x2F;141.02(ave)&#x3D;163.02</span><br><span class="line">pss-ram：267.32&#x2F;177.49&#x2F;234.1&#x2F;221.47&#x2F;235.23(max)&#x3D;230.27	256.2&#x2F;163.50&#x2F;219.3&#x2F;211.83&#x2F;206.29(ave)&#x3D;212.47</span><br><span class="line">系统总ram：3453&#x2F;3365&#x2F;3372&#x2F;3457&#x2F;3421(max)&#x3D;3415.33	3410.91&#x2F;3349.44&#x2F;3335.2&#x2F;3325.13&#x2F;3377.08(ave)&#x3D;3353.91</span><br><span class="line">全局上行流量：449.13&#x2F;383.05&#x2F;423.08&#x2F;629.68&#x2F;4627&#x3D;500.63</span><br><span class="line">全局下行流量：1768.87&#x2F;1732.48&#x2F;1862.45&#x2F;3001.82&#x2F;33997.12&#x3D;2211.05</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景2：</strong> 启动耗时；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpu:41.86&#x2F;40&#x2F;54.73&#x2F;41.79&#x2F;43.54</span><br><span class="line">rom:2977&#x2F;3007&#x2F;3028&#x2F;2986&#x2F;2924</span><br><span class="line">上行流量：32.34&#x2F;9.72&#x2F;11.13&#x2F;11.74&#x2F;20.76</span><br><span class="line">下行流量：138.13&#x2F;61.34&#x2F;32.75&#x2F;76.30&#x2F;54.90</span><br><span class="line">启动耗时：771ms&#x2F;2431ms&#x2F;1080ms&#x2F;781&#x2F;748ms</span><br></pre></td></tr></table></figure></li>
<li><strong>场景3：</strong> treding页上下滑动，在切换到music页上下滑动，在切换回treding页；；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:56.28&#x2F;69.59&#x2F;65.96&#x2F;54.79&#x2F;75.57(max)&#x3D;	40.32&#x2F;39.65&#x2F;40.95&#x2F;36.15&#x2F;38.25(ave)</span><br><span class="line">进程cpu:21.84&#x2F;23.71&#x2F;22.19&#x2F;20.37&#x2F;24.17(max)&#x3D;&#x3D;22.58	11.64&#x2F;11.6&#x2F;12.07&#x2F;9.35&#x2F;10.64(ave)&#x3D;11.29</span><br><span class="line">pss-ram：403.67&#x2F;361.57&#x2F;359.02&#x2F;375.05&#x2F;339.13(max)&#x3D;365.21	388.28&#x2F;349&#x2F;340.59&#x2F;359.07&#x2F;320.53(ave)&#x3D;349.55</span><br><span class="line">private-ram:327.68&#x2F;288.42&#x2F;284.15&#x2F;300.31&#x2F;265.09(max)	&#x3D;290.96	313.29&#x2F;275.5&#x2F;266.61&#x2F;284&#x2F;248.88(ave)&#x3D;275.37</span><br><span class="line">系统总ram：3635&#x2F;3578&#x2F;3587&#x2F;3571&#x2F;3500(max)&#x3D;3578.67	3623&#x2F;3563.6&#x2F;3570.09&#x2F;3560.56&#x2F;3484.78(ave)&#x3D;3564.75</span><br><span class="line">全局上行流量：281.49&#x2F;351.88&#x2F;342.72&#x2F;256.57&#x2F;320.48&#x3D;341.90</span><br><span class="line">全局下行流量：1406.78&#x2F;1530.86&#x2F;1694.41&#x2F;1208.77&#x2F;1678.10&#x3D;1538.58</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景4：</strong> music页点击歌单，进入歌单，歌单上下滑动两页，然后返回music页；在点击进入chart页，上下滑动两页，在返回；在点击进入艺人页，上下滑动两页，在返回；在点击进入曲风页，上下滑动，在进入第一个曲风，上下滑动，然后返回music首页；在次进入歌单页，上下滑动，然后在次点击第一个歌单进入歌单详情页，然后返回music首页；点击进入视频页，上下滑动，然后返回music首页；点击进入bbc，上下滑动，然后返回music首页；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:75.71&#x2F;80.96&#x2F;89.29&#x2F;87.47&#x2F;91.79(max)&#x3D;85.91	39.67&#x2F;40.07&#x2F;44.62&#x2F;43.97&#x2F;39.84(ave)&#x3D;41.29</span><br><span class="line">进程cpu:49.75&#x2F;51.24&#x2F;62.76&#x2F;50.77&#x2F;63.49(max)&#x3D;54.92	14.63&#x2F;14.62&#x2F;16.87&#x2F;16.06&#x2F;13.35(ave)&#x3D;15.10</span><br><span class="line">pss-ram：267.17&#x2F;271.73&#x2F;265.97&#x2F;262.30&#x2F;314.29(max)&#x3D;268.29	216.92&#x2F;222.82&#x2F;220.84&#x2F;218.53&#x2F;281.03(ave)&#x3D;220.73</span><br><span class="line">private-ram:204.31&#x2F;209.68&#x2F;205.87&#x2F;202&#x2F;240.15(max)&#x3D;206.62	157.54&#x2F;163.98&#x2F;161.26&#x2F;159.72&#x2F;206.50(ave)&#x3D;161.65</span><br><span class="line">系统总ram：3415&#x2F;3414&#x2F;3428&#x2F;3394&#x2F;3412(max)&#x3D;3413.67	3371.28&#x2F;3379.18&#x2F;3383.33&#x2F;3337.13&#x2F;3374.4(ave)&#x3D;3374.95</span><br><span class="line">全局上行流量：809.21&#x2F;896.26&#x2F;810.98&#x2F;858.86&#x2F;827.16&#x3D;832.33</span><br><span class="line">全局下行流量：4067.93&#x2F;4459.75&#x2F;3786.03&#x2F;3666.64&#x2F;5148.2&#x3D;4104.57</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景5：</strong> treding页播放music，然后返回treding;进入music页，点击歌单上浮按钮，进行全部播放，点击歌单详情页的全部播放按钮进行播放，点击歌单详情页的music播放，返回music后；进入播放列表，点击music播放；在进入播放详情页，切歌播放，在返回music首页，点击进入video页，点击视频进行播放，返回treding页；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:82.99&#x2F;73.3&#x2F;79.35(max)&#x3D;78.55	45.87&#x2F;45.57&#x2F;44.19(ave)&#x3D;45.21</span><br><span class="line">进程cpu:28.88&#x2F;33.77&#x2F;30.33(max)&#x3D;30.99	12.87&#x2F;11.60&#x2F;11.34(ave)&#x3D;11.94</span><br><span class="line">pss-ram：360.44&#x2F;339.74&#x2F;348.03(max)&#x3D;349.4	332&#x2F;313.36&#x2F;314.22(ave)&#x3D;319.86</span><br><span class="line">private-ram:262.51&#x2F;250.52&#x2F;259.28(max)&#x3D;257.44	233.83&#x2F;224.32&#x2F;228.88(ave)&#x3D;229.01</span><br><span class="line">系统总ram：3449&#x2F;3485&#x2F;3462(max)&#x3D;3465.33	3407.38&#x2F;3431.68&#x2F;3427.11(ave)&#x3D;3422.06</span><br><span class="line">全局上行流量：14914.79&#x2F;6908.25&#x2F;11193.83&#x3D;11005.62</span><br><span class="line">全局下行流量：35355.44&#x2F;17913.15&#x2F;28217.16&#x3D;27161.92</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景6：</strong> treding页进行music下载，music首页歌单全局下载按钮进行下载，点击进入歌单详情页，通过全部下载按钮进行下载，进入播放详情页，下载music；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:73.77&#x2F;83.13&#x2F;77.37&#x2F;51.35&#x2F;72.18(max)	46.94&#x2F;49.59&#x2F;46.94&#x2F;29.66&#x2F;41.61(ave)</span><br><span class="line">进程cpu:20.62&#x2F;21.09&#x2F;21.91&#x2F;15.18&#x2F;10.79(max)	11.91&#x2F;13.48&#x2F;10.14&#x2F;7.87&#x2F;10.31(ave)</span><br><span class="line">pss-ram：351.01&#x2F;301.85&#x2F;307.79&#x2F;(max)	339.44&#x2F;291.96&#x2F;297.10(ave)</span><br><span class="line">private-ram:269.26&#x2F;222.66&#x2F;228.95(max)	259.39&#x2F;212.57&#x2F;217.98(ave)</span><br><span class="line">系统总ram：2765&#x2F;2813&#x2F;2676(max)	2738.27&#x2F;2770.88&#x2F;2667.55(ave)</span><br><span class="line">全局上行流量：16531.35&#x2F;21262.26&#x2F;9539.49&#x2F;3160.78&#x2F;4068.34</span><br><span class="line">全局下行流量：32460.28&#x2F;43211.35&#x2F;18512.41&#x2F;6134.98&#x2F;7870.63</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景7：</strong> library页，通过localmusic或者下载music对本地下载的music进行播放，播放和后台循环切换；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:(max)	(ave)</span><br><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景8：</strong> 后台播放music时，分别同时打开，Facebook，WhatsApp，Twitter，Instagram，chrome；在切换回前台；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:(max)	(ave)</span><br><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景9：</strong> music页/library页/buzz页/account页进行循环切换；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:(max)	(ave)</span><br><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景10：</strong> buzz页，一二级页面循环切换，且每个页面均进行上下滑动；buzz页，点击评论和点赞按键；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:(max)	(ave)</span><br><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景11：</strong> account页，进行登录，退出应用，切换回前台，退出登录(无法登录)；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:94.5&#x2F;100&#x2F;82.71&#x2F;92.37(max)&#x3D;93.44	37.83&#x2F;45.15&#x2F;39.34&#x2F;32.20(ave)&#x3D;35.02</span><br><span class="line">进程cpu:42.78&#x2F;19.69&#x2F;23.83&#x2F;43.29(max)&#x3D;32.40	11.17&#x2F;9.02&#x2F;10.08&#x2F;9.10(ave)&#x3D;9.84</span><br><span class="line">pss-ram：263.71&#x2F;240.92&#x2F;125.89(max)&#x3D;252.315	206.20&#x2F;236.28&#x2F;120.34(ave)&#x3D;221.24</span><br><span class="line">private-ram:205&#x2F;184.32&#x2F;75.10(max)&#x3D;194.66	150.55&#x2F;179.58&#x2F;68.81(ave)&#x3D;165.07</span><br><span class="line">系统总ram：2753&#x2F;2785&#x2F;2529(max)&#x3D;2689	2699.31&#x2F;2752.05&#x2F;2483.05(ave)&#x3D;2644.80</span><br><span class="line">全局上行流量：1157.70&#x2F;1290.43&#x2F;730.34&#x2F;1402.62&#x3D;1283.59</span><br><span class="line">全局下行流量：2662.21&#x2F;2518.72&#x2F;556.74&#x2F;6012.13&#x3D;2590.47</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景12：</strong> notification,页面循环切换，且每个页面进行上下滑动；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">总cpu:(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景12：</strong> 首次进入页面的资源消耗；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:(max)	(ave)</span><br><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
<li><strong>场景13：</strong> 前台常驻10分钟，切换到后台常驻10分钟，在切换回前台；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总cpu:(max)	(ave)</span><br><span class="line">进程cpu:(max)	(ave)</span><br><span class="line">pss-ram：(max)	(ave)</span><br><span class="line">private-ram:(max)	(ave)</span><br><span class="line">系统总ram：(max)	(ave)</span><br><span class="line">全局上行流量：</span><br><span class="line">全局下行流量：</span><br><span class="line">响应耗时：</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构建脚本：</strong></p>
</li>
</ul>
<ul>
<li><p><em>方案：</em></p>
<p>  <code>使用solopi构建脚本；录制脚本时，需要保证时间尽量长，且需要规避无效操作，需要保证脚本尽量简单；在批量执行前，需要先进行三次循环调试，以保证脚本无异常，可批量回放和单脚本循环执行，短时间执行，建议单脚本，跑全维度稳定性，建议批量执行；   </code><br><strong>注意实际执行时，需要保证覆盖的机型，尽量接近真实场景；且用solopi进行多次重复执行的压测场景时，建议不要选择重复播放选项来重复播放多次，这种会生成多个性能文件，且一次只能执行一个用例，可以使用批量执行，选择多个用例，一个用例要执行几次，就选中几次，具体看我的教学视频</strong></p>
</li>
</ul>
<p>监控指标：见上方监控指标</p>
<ul>
<li><p><strong>分析监控数据，采集异常数据定位问题 :</strong></p>
<p>  <code>本方案，主要是为了实现APP稳定性的评测；因此分析时，主要关注终端性能，消耗资源，是否有异常</code></p>
</li>
</ul>
<ul>
<li><p><em>资源路径：</em></p>
<p>  <code>该路径下包含有终端资源数据（CPU/MEN/带宽/响应耗时/fps..）和消耗资源数据(电量/流量)，具体数据按勾选的监控对象来落地；</code></p>
</li>
</ul>
<p><img src="/text_image/solopi_%E8%B5%84%E6%BA%90.jpg" alt="alt_text"></p>
<ul>
<li><p><em>工具各路径说明：</em></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  solopi/error:工具的错误日志；</span><br><span class="line">  solopi/logcat:整个工具的logcat;</span><br><span class="line">  solopi/patch:扩展/补丁，可实现对solopi工具的功能扩展；</span><br><span class="line">  solopi/records：最重要的文件夹，测试对象（app）的所有数据放在此路径下；</span><br><span class="line">solopi\records\error：app执行，adb监控到的异常会记录在这个目录下；</span><br><span class="line">solopi\records\<span class="built_in">export</span>：导出的用例，会放在这个路径下，从这里复制出来给其他人用</span><br><span class="line">solopi\records\import：从<span class="built_in">export</span>导出的用例，放在这个路径下，然后在solopi配置里点导入按钮，这样就成功导入了；</span><br><span class="line">solopi\records\replay：存放solopi用例执行的保存结果，必须点保存，才会落地；否则存放在cpu中，退出会话就会清空，以json格式存放，可以解析看下；</span><br><span class="line">solopi\records\logcat：存放app的，所有adb日志，和工具的adb日志差不多；</span><br><span class="line">solopi\records\records\20220217183647_20220218093514：见上图，为资源路径，文件名为时间戳；</span><br><span class="line">solopi\records\screenshot:存放app录屏的路径;</span><br><span class="line">solopi\records\screenshots:脚本执行失败时会截图，此为存放失败截图的路径；</span><br><span class="line">solopi\records\tmp：临时目录，用以存放一些临时文件，如强制结束时，所处页面的截图；</span><br><span class="line">  solopi/ScreenCaptures:存放录屏的目录，通过录屏分帧，可以计算每页的启动耗时；</span><br><span class="line">  solopi/screenshots:脚本故障截图的存放路径，脚本故障时会截图；</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p><em>分析数据：</em></p>
<p>  执行操作且确认结束后，需要按照以下顺序来进行分析，上一步失败，下一步中断：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1、先确认本次脚本，是否执行成功；先查看执行结果，仅当执行成功后，将执行结果导出，归档；</span><br><span class="line"> 2、查看下工具的error路径，查看是否有异常抛出，确认与APP无关，则过滤，否则记录；</span><br><span class="line"> 3、通过工具，查看录制的性能结果，观察有无异常值，主要关注以下几点：</span><br><span class="line">cpu:单独执行app时，cpu峰值是否超过80-90%，且cpu超过75%占比是否过大，对比相同场景下网易云的数据，是否超出网易指标20-30%；</span><br><span class="line">men:查看内存是否存在一直增长，不随场景释放的内存泄露问题；查看内存是否存在oom问题，查看hprof文件，结合内存曲线配合场景，分析内存消耗是否合理；同时需要关注相同场景下网易云音乐的资源消耗对比是否比我们的APP具有明显的优势；</span><br><span class="line">带宽：带宽，主要考虑，下载资源和实际消耗的流量比，是否实际消耗的在一个合理区间内；以及最大占有带宽，和分配带宽比，分析带宽资源能否得到合理的利用；</span><br><span class="line">响应耗时：响应耗时，是用户感知最明显的指标；需要符合业界的规范；</span><br><span class="line">启动耗时：activity启动耗时，通过数帧的方式计算，也是用户能直接感知到的，结合响应耗时，需要符合业界规范；</span><br><span class="line">流量：流量，主要考虑升级场景流量消耗，后台常驻&#x2F;前台常驻的流量消耗，活跃及下载场景下的流量消耗；</span><br><span class="line">电量：电量考虑用户活跃场景&#x2F;后台常驻&#x2F;前台常驻时的电量消耗；</span><br><span class="line">异常日志监控：主要是关注工具solopi\records\error或solopi\error及solopi\records\logcat路径下，查看有无异常抛出；</span><br><span class="line">anr&#x2F;crash收集：关注APP的crash和anr目录下是否有响应的异常收集文件；</span><br></pre></td></tr></table></figure></li>
</ul>
<p>扩展：有时开发需要dump文件来分析，内存的消耗，此时就需要下载hprf文件提供给开发，低于win10版本，可使用下图方案：<br><img src="/text_image/low_win10.jpg" alt="alt_text"><br>高于win10版本，可通过,以下方式获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、ps -ef|grep com.afmobi.boomplayer			--获取pid</span><br><span class="line">2、 <span class="built_in">kill</span> -10 pid</span><br><span class="line">3、adb bugreport</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>实战</tag>
        <tag>预装</tag>
      </tags>
  </entry>
  <entry>
    <title>质量保障体系--测试设计</title>
    <url>/posts/9eaf5086/</url>
    <content><![CDATA[<p><code>作为一个测试，最核心的工作是保障产品/服务的质量；不管是通过流程，手工测试，还是脚本工具，都是为最终目的服务的，我写这篇文章的最终目的，是为了测试设计能成为一个标准作业；测试一个产品/需求的标准链路如下：</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><strong>收集信息</strong></li>
<li><strong>分析信息</strong></li>
<li><strong>测试设计</strong></li>
<li><strong>测试执行</strong></li>
<li><strong>归纳并标准化</strong><ul>
<li><strong>各单功能的标准件</strong> <span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a><strong>收集信息</strong></h2><p><code>要保证充足的测试，仅仅依赖需求和设计文档是不够的；尤其是我们的需求往往是不够完善的；可参考的信息来源如下，其组织形式也体现了信息收集和提炼过程：</code><br><img src="/text_image/%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%9D%A5%E6%BA%90.png" alt="alt text"></p>
<h2 id="分析信息"><a href="#分析信息" class="headerlink" title="分析信息"></a><strong>分析信息</strong></h2><p><code>分析信息是将收集到的信息，提炼、重组、输出成测试大纲的过程；快速信息提炼可用SFDIPOT方法；但一般还是会用MFQ方法来建立测试大纲；具体如下：</code></p>
<ul>
<li>SFDIPOT模型<br><img src="/text_image/SFDIPOT.png" alt="alt text"></li>
<li>SFDIPOT实例<br><img src="/text_image/SFDIPOT%E5%AE%9E%E4%BE%8B.png" alt="alt text"></li>
<li>MFQ模型：<code>M指单功能、F指单功能间的交互、Q质量属性（非功能）</code><br><img src="/text_image/MFQ%E6%A8%A1%E5%9E%8B.png" alt="alt text"></li>
<li>MFQ实例<br><img src="/text_image/MFQ%E5%AE%9E%E4%BE%8B.png" alt="alt text"></li>
<li>MFQ中，Q质量属性，参考大纲<br><img src="/text_image/Q%E9%9D%9E%E5%8A%9F%E8%83%BD%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7.png" alt="alt text"><br><code>以上模型，其实是信息组织方式；具体的分析策略如下，供参考：</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">尽早尽快：问题发现的越早越好，信息获取的越快越好；</span><br><span class="line">获取的信息越多，信息源越多越好；</span><br><span class="line">疑问；收集疑问，解决疑问，很有价值，质疑一切；</span><br><span class="line">仔细阅读，关注关键字，多思考；</span><br><span class="line">寻找矛盾、漏洞和容易被误解的东西；</span><br><span class="line">除非式探索 —— 在你的产品、流程或者模型的任何你关心的表述后面加上 “除非……”。然后看看新增的部分引导你到了那些方面；</span><br><span class="line">要和业务结合，脱离实际是不行的；</span><br><span class="line">相关性判断 —— 你认为它重要吗？其他人认为这很重要吗？会变得重要吗？用户是否会对这个问题感到不安/恼火？</span><br><span class="line">假设问题；如果…怎么办？–就可能发生的事情或经验进行头脑风暴；</span><br><span class="line">横向思维 —— 人工分离，类比，寻找替代品，相反方面，随机刺激 — 任何有用的东西都可以做；</span><br><span class="line">关键点；——让自己暴露在你认为能产生好想法的信息/情境中；</span><br><span class="line">拉近拉远 —— 放大或缩小详细程度，并检查内容；</span><br><span class="line">图/立体信息组织；以重要的方式将不同的知识、细节和大局结合起来；什么值得仔细研究？让信息变的更立体，更容易理解；</span><br><span class="line">建模；利用测试方法分析，如等价类、因果图、流程等；得到实例；</span><br><span class="line">挖掘隐藏的信息；用户的隐藏需求。隐藏的问题等；</span><br><span class="line">多样性；从多个方面考虑问题；</span><br><span class="line">松弛式探索 —— “让你自己分心吧……因为你永远不知道你会发现什么……但是要定期根据任务来评估你的状态 “</span><br><span class="line">投入并退出 —— 从最困难的部分开始，看看会发生什么，想退出就退出；</span><br><span class="line">拉姆斯菲尔德式探索 —— 调查已知的未知，考虑未知的未知；</span><br><span class="line">不要停下来 —— 当你找到你要找的东西时，多想想看是否有更好的东西等着你；</span><br><span class="line">总是暂停 —— 分析（和设计）是一个连续的活动，是不是暂停一下；</span><br><span class="line">由他人完成–找出由他人执行的测试类型；您可以跳过或轻松覆盖它们（复用）；</span><br><span class="line">上下文分析 - 找出当前情况下哪些因素可以指导你的测试工作。</span><br><span class="line">测试框架 —— 将你的测试活动与你的测试任务联系起来，并了解更多信息（整体联系）；</span><br><span class="line">我做了什么假设 —— 解释你的测试活动，并提出质疑（质疑自己）；</span><br></pre></td></tr></table></figure>
<strong>以上分析过程都是围绕着‘理解什么是重要的’展开的</strong><h2 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a><strong>测试设计</strong></h2><code>测试设计一定要基于上下文、基于风险，有的放矢的；常用的测试设计方法有（等价类/边界值/流程图/状态转换法/组合（因果图+判定表、正交实验法）/错误推导法）</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">等价类：输入数值，有多种类型时；分类取值，用局部代替整体实现覆盖；注意既要覆盖有效等价类，又要覆盖无效等价类；</span><br><span class="line">边界值：常和等价类一起使用，取各类数据的边界值或极值，以覆盖极限情况；</span><br><span class="line">流程图：画流程图覆盖业务的所有流程，通常要覆盖主要流程/次要流程/异常流程等；</span><br><span class="line">状态转换法：列出需求的所有状态、并整理转换关系；以实现对所有状态关系的覆盖，如登录；状态转换和流程法的主要区别是，流程的链路方向是固定的，状态转换的方向是可逆的；</span><br><span class="line">正交实验法：是一种在众多组合输入数据中，取样本的方法；以实现样本（均匀且全面）表示整体；具体操作制作‘混合’正交表。表的列为输入参数，列的值为参数值；行为执行次数，每一行为该次执行的参数组合；当参数不够时为空；</span><br><span class="line">错误推导：根据收集/推测的可能错误，验证是否存在相关错误；（参考常见错误list）</span><br><span class="line">因果图+判定表法：两种方法常一起使用，根据因果关系生成判定表；在根据判定表进行测试；因果图是这样的，利用输入的组合关系、多个输入及多输出各自的逻辑关系（常见的逻辑关系有等/非/或/与/异或/包含/排他等），来画因果图，并生成判定表；判定表的列即为测试用例,因果图法和判定表如下；</span><br></pre></td></tr></table></figure>
<p><img src="/text_image/%E5%9B%A0%E6%9E%9C%E5%9B%BE.jpg" alt="alt text"><br><strong>判定表</strong><br><img src="/text_image/%E5%88%A4%E5%AE%9A%E8%A1%A8.png" alt="alt text"><br><code>至于方法怎么使用，这需理解这些方法的价值；方法其实是一种套路，用来解决特定问题的；因此每种方法都有最适合的场景；重点是我们要明白场景的特征和方法的匹配关系；具体如下：</code><br><strong>注意不同方法覆盖率计算特征不同，但总归都是覆盖率=覆盖场景/所有场景；这种覆盖率只是相对覆盖率</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">等价类+边界值（数据）：最适合的场景是，输入之间彼此独立，且输入可能有多种类型时，试用它；</span><br><span class="line">流程图（流程）：场景是分步骤的流程时，考虑用流程法覆盖；</span><br><span class="line">状态转换法（状态）:如果场景是包含多个状态，且状态直接能互相装换，那状态转换法就比流程法适用；</span><br><span class="line">因果图+判定表（规则）：适用于多参数组合的场景，且参数间存在逻辑关系；先画因果图，在做判定表；</span><br><span class="line">正交实验法（组合）：使用输入参数众多，但参数间相对独立，且需要组合输入的场景；</span><br></pre></td></tr></table></figure>
<p><strong>如何找到需求的特征呢：基于经验，通过收集到的信息；查找关键词、抓住核心功能、围绕既定目标、尝试其他特征的方式判断；注意一个场景，往往有多个特征，抓主干，同时在一个特征无法保障覆盖时，可以覆盖多个特征。</strong></p>
<p><code>测试设计（建模），往往得到的是测试点，需要我们进一步把测试点具体成可执行的测试用例；在测试分析过程中可参考的经验如下：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">所有的分析启发法都可以用作设计启发法；</span><br><span class="line">信息要及时更新—— 尽可能的保持测试的规范细节为最新。事情都会发生变换，你会从最新的信息中了解更多；</span><br><span class="line">各样的半度量方式 —— “与其完美地进行一两种测试，不如在相当好的水平上进行更多不同类型的测试。”</span><br><span class="line">越快越好 —— 这样你就可以从产品中获得更多信息；</span><br><span class="line">“把所有应该自动化的测试都实现自动化。”—至少完成一次测试后，你会更清楚这一点；</span><br><span class="line">不玩花活：</span><br><span class="line">  使用简单的测试也能达到目标；</span><br><span class="line">  你不必使用花哨的测试技术，特别是在不需要的时候；</span><br><span class="line">复杂度：</span><br><span class="line">  复杂测试能够让你更有效率；</span><br><span class="line">  在设计复杂的测试时不能太小心；</span><br><span class="line">自由覆盖 —— 通过一次测试，就可以覆盖很多不同的内容。利用质量特征的持续性测试想法，将这些方法保留在你的意识深处，关注异常的发生；</span><br><span class="line">适当的粒度 - 考虑测试的详细级别，以提高可评审性；</span><br><span class="line">最具代表性–使用最常见、最容易出错、包罗万象、最重要的示例；</span><br><span class="line">重要性原则 - 将大多数测试集中在主要目的上，但要寻找其他目的和可能的错误；</span><br><span class="line">偶然性——如果测试能发现我们不知道的重要事情，那就更好了；</span><br><span class="line">可以丢弃 —— 不要害怕丢弃你不再相信有相关性的测试；</span><br><span class="line">实践出真知——试一下这个软件，你就会感觉到什么是重要的，什么是容易出错的，以及如何测试它；</span><br><span class="line">直觉——“当你在思考难以预测的事情并且信息很少的时候，相信你的直觉。”</span><br><span class="line">从软件测试中收获课程的五个例子 —— “在边界测试…测试每个错误消息…测试不同于程序员的配置…执行设置很烦人的测试…避免冗余测试。”</span><br><span class="line">与信息目标保持一致—测试是否可以针对不同的信息目标进行调整？</span><br><span class="line">良好的测试 —— 强大、有效、有价值、可信、可能、非冗余、激励、可执行、可维护、可重复、重要、易于评估、支持故障排除、适当复杂、负责任、性价比高、易于理解、能够实现偶然性；</span><br><span class="line">改变策略——如果你的测试没有揭示新的、有趣的信息，那么是时候改变策略了；</span><br><span class="line">用在别处？ —— 这个伟大的测试想法能否用与于领域的测试？</span><br><span class="line">谁能做到？–你可能会包含你无法执行的测试想法。</span><br><span class="line">多样性审查（结对）——如果审查者提供新的内容，请找一个想法更为不同的人。</span><br><span class="line">未读测试设计 —— 如果开发人员没有阅读你的高等级的测试设计，请询问他们原因。</span><br><span class="line">最喜欢的技巧 —— 你最好的测试设计技巧可能不是完美的匹配，但它可能会给你最好的结果；</span><br><span class="line">任何与探索性测试、基于经验的测试或错误猜测相关的技能都是有用的；</span><br><span class="line">元问题 —— 对于棘手的设计问题，您可以使用诸如 CIA Phoenix 清单之类的问题；</span><br></pre></td></tr></table></figure>
<h2 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a><strong>测试执行</strong></h2><p><code>测试执行阶段，也存在着信息获取；纠错的过程；当然获取信息-决策-反馈-优化是贯穿质量活动始终的； 在执行活动中关注的较多的‘覆盖’和‘用例有效性’的问题；判断的依据是‘风险（风险发生的概率/后果）’，虽然每种模型都有一定的覆盖率，但同时任何模型也无法保证100%的覆盖率(测试是一个混沌工程)，因此在执行时，我会尝试覆盖所有被认为重要的东西</code></p>
<p><strong>覆盖率模型–广度/深度判断</strong><br><img src="/text_image/%E6%B5%8B%E8%AF%95%E6%B7%B1%E5%BA%A6%E5%9B%BE.png" alt="alt text"><br><strong>覆盖率模型–执行价值</strong><br><img src="/text_image/%E5%81%9A%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E4%BA%8B.png" alt="alt text"></p>
<p><code>测试执行可参考的经验：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">所有的分析启发式和设计启发式都可以用作执行启发式；</span><br><span class="line">基本的启发 —— 如果它存在，我想测试它；</span><br><span class="line">重要问题优先——先找出最重要的问题；</span><br><span class="line">主干——如果方便的话，首先看看大的功能工作是否正常；</span><br><span class="line">更宽泛的区分——如果 “这个” 可以或不可以，我们可以跳过 “那个”；</span><br><span class="line">多信息源——使用比需求更复杂的 “文档”；</span><br><span class="line">再做一件事——另外做一些容易出错的、大众的或者用户可能会做的事情。不要想太多，做点什么，看看会发生什么；</span><br><span class="line">死亡蜜蜂启发 - 如果我改变了一个数据文件，发现我正在测试的应用程序不再发生崩溃，下一步我要做的就是再次改变它，这样我就可以再次看到崩溃；</span><br><span class="line">隆隆作响——当产品做了奇怪的事情，一个大灾难可能会发生；</span><br><span class="line">慢慢挪动——以一种刻意过度精细的方式做某事；</span><br><span class="line">用户错误——研究无意（典型）错误；</span><br><span class="line">行动方法——成为一个 “真正” 的用户；</span><br><span class="line">二分法——当有奇怪的事情发生时，去掉 “一半”，直到找到必要的成分；</span><br><span class="line">可翻转性启发——尝试从意外使用中获得价值；</span><br><span class="line">基本配置矩阵——确定跨越 “边界” 的几个平台；</span><br><span class="line">并发测试执行——同时运行多个测试想法以获得新的交互和想法；</span><br><span class="line">似曾相识的启发式方法——当遇到错误消息时，多重复一次（如果不完全相同，代码是可疑的）；</span><br><span class="line">看看很多地方——测试结果可以通过几个地方来解释；</span><br><span class="line">其他地方是否存在问题——发现的问题是否存在于其他地方？</span><br><span class="line">直觉 - “相信你的直觉。尝试任何感觉有希望的测试”</span><br><span class="line">结对测试——协同测试执行激发新的更快的思考；</span><br><span class="line">测试辅助——有工具可以立刻帮助我吗？</span><br><span class="line">极性动态——在谨慎与快速、嬉戏与严肃、客观与主观等之间切换；</span><br><span class="line">现在——“我现在能做的最好的测试是什么？</span><br><span class="line">情绪——运用你的感官。</span><br><span class="line">新视角发现失败——看看新的东西；让别人看看你的东西；</span><br><span class="line">即兴表演</span><br><span class="line">（不）确定性问题——总是有问题，但它们可能并不重要</span><br><span class="line">我可能用错了启发——如果我发现许多问题，可能是我的模型是错误的；</span><br></pre></td></tr></table></figure>
<p><strong>快速测试 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用一些快速的，并不总是有效果的测试来刺激你的执行（这些测试来自 Kaner&#x2F;Bach 等.);</span><br><span class="line">鞋子测试——找到一个输入字段，将光标移到它上，将鞋子放在键盘上，然后去吃午饭;</span><br><span class="line">边界测试——测试边界值因为边界的错误编码是一个常见的错误。</span><br><span class="line">Whittaker 攻击</span><br><span class="line">  输入：强制错误消息、默认值、浏览数据、溢出缓冲区、查找交互、重复多次。</span><br><span class="line">  输出：强制不同、无效、属性更改、屏幕刷新。探索存储的数据和计算。填充或损坏文件系统；无效&#x2F;不可访问的文件。</span><br><span class="line">干扰测试——取消、暂停、交换、中止、后退&#x2F;下一步、竞争、删除、注销。</span><br><span class="line">跟踪最近的变化——意外的副作用。</span><br><span class="line">探索数据关系——利用依赖关系，跟踪数据，干扰，删除。</span><br><span class="line">变化之旅——尽可能在各个维度上变化;</span><br><span class="line">复杂度之旅——查找最复杂的功能和数据，创建复杂的文件。</span><br><span class="line">示例数据之旅——尽可能使用任何示例数据。越复杂越好。</span><br><span class="line">持续使用 - 测试时，不要重置系统。打开窗口和文件。让磁盘和内存使用量增加。你希望随着时间的推移，这个系统会自己打结。</span><br><span class="line">调整 - 将某些参数设置为某个值，然后在以后的任何时间将该值重置为其他值，而不重置或重新创建包含的文档或数据结构。</span><br><span class="line">Dog Pilling——一次运行更多进程；同时存在更多状态。</span><br><span class="line">减弱——当系统处于适当的状态时开始使用一个函数，然后将状态部分更改为不适当的状态。</span><br><span class="line">错误消息处理——使错误消息发生。重点测试错误被忽略后的情况。</span><br><span class="line">点击狂热——测试不仅仅是 “敲击键盘”，但这句话并非空穴来风。试着敲击键盘。试着到处点击。</span><br><span class="line">多个实例——同时运行应用程序的许多实例。打开相同的文件。</span><br><span class="line">功能交互——发现各个功能交互或共享数据的位置。寻找任何相互依赖的关系。浏览他们。给他们压力。</span><br><span class="line">便宜的工具！–了解如何使用 InCtrl5, Filemon, Regmon, AppVerifier, Perfmon, Task Manager, Threadhijacker, Zed Attack Proxy, Color Oracle（所有这些都是免费的）</span><br><span class="line">资源匮乏——逐渐降低内存和其他资源，直到产品优雅得降级或不优雅得崩溃。</span><br><span class="line">执行 “作者说”——查看联机帮助或用户手册，找到有关如何执行一些有趣活动的说明。做那些动作。然后即兴表演。</span><br><span class="line">疯狂配置——在安装产品之前或之后以非标准或非默认方式修改 O&#x2F;S 配置。</span><br><span class="line">摸索——找到产品中产生大量数据或执行某些操作非常快的方面;</span><br></pre></td></tr></table></figure>
<h2 id="归纳并标准化"><a href="#归纳并标准化" class="headerlink" title="归纳并标准化"></a><strong>归纳并标准化</strong></h2><p><code>以上的过程，就是一个完整的‘测试过程’；其中每一步都是独立的，但都有其价值；无论如何，测试本质都是基于‘上下文’和‘风险’的活动；获取信息-分析-决策-反馈-优化，永远贯穿质量活动的始终，本节的目的是让较小的单功能/独立的功能，测试活动，能实现标准作业；这个想法的依据是由于，任何产品功能都是大同小异的，都是由相似的各个小功能组成的，本节考虑输出各小功能的checklist来实现标准作业</code><br><img src="/text_image/%E5%8F%8D%E9%A6%88%E6%9C%BA%E5%88%B6.png" alt="alt text"></p>
<h3 id="标准作业实例"><a href="#标准作业实例" class="headerlink" title="标准作业实例"></a>标准作业实例</h3><ul>
<li><a href="https://www.processon.com/view/link/64be5dbc392b97462f4b12c9">‘大富翁游戏’</a></li>
</ul>
<p><strong>看到这是不是有种感觉，测试工作流程，越来越像工厂的流水线；这其实就是互联网的发展方向，未来估计行业的发展趋势也会和制造业趋同；不知是行业的幸运，还是个人的不幸！！！</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>实战</tag>
        <tag>质量体系</tag>
        <tag>测试设计</tag>
      </tags>
  </entry>
  <entry>
    <title>质量保障体系--2023/07/10</title>
    <url>/posts/274713e6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>测试的核心价值在于保障产品的质量，提效增质；要全面的保障质量，就需要一个完善的体系，从各方面入手来保障产品的质量，本次将以传易互联--音乐项目的质量保障体系进行分析，从而探索质量保障体系的设计</code></p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">传易音乐质量保障体系</span><br><span class="line">质量保障体系的设计理念</span><br><span class="line">质量保障体系落地</span><br><span class="line">传音音乐质量保障体系理想版</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="传音音乐质量保障体系"><a href="#传音音乐质量保障体系" class="headerlink" title="传音音乐质量保障体系"></a>传音音乐质量保障体系</h2><p><code>质量保障体系是为具体业务服务的，因此需要结合业务特色设计，好的质量保障体系是兼顾质量、效率、成本，的一种综合性的设计</code></p>
<h3 id="传易音乐业务特点"><a href="#传易音乐业务特点" class="headerlink" title="传易音乐业务特点"></a>传易音乐业务特点</h3><p><code>传易音乐提供面向非洲主要国家的，音频流媒体服务（音乐+音频直播）；主要由内容端+产品端+数据端+直播业务+商业化业务构成；主要特点是服务国家多，语种人群多，终端设备复杂，产品交付链路复杂，基于这种复杂的海外业务特点，质量保障体系，需要兼顾各类复杂场景</code></p>
<h3 id="传音音乐产品交付体系"><a href="#传音音乐产品交付体系" class="headerlink" title="传音音乐产品交付体系"></a>传音音乐产品交付体系</h3><p><code>传易音乐的产品交互体系如下；参与方主要有产品、设计、开发、测试、项目管理人员；整个链路主要基于tapd平台来进行管理追溯，项目主要由项目管理人员协调跟踪，通过在线excel表格来排期和维护进度。整个链路整体合理，各方都有参与；但也有不足之处，问题如下：</code><br><img src="/text_image/%E4%BC%A0%E6%98%93%E4%BA%92%E8%81%94%E4%BA%A4%E4%BB%98%E4%BD%93%E7%B3%BB.png" alt="alt text"><br><strong>交互体系的缺陷</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对用户来说：我们的产品设计风格变动极大，几乎每一个大版本风格都有极大变化；广告太多；不太稳定；</span><br><span class="line">业务：业务缺乏全局的规划，重点经常变；比如这个季度重点发力会员，下个季度就是游戏，突然重心又在广告，产品方面也是，这种混乱局面会导致一系列问题，出现这种问题的原因个人觉得还是管理层对音乐业务了解并不够深；</span><br><span class="line">需求：由于公司是由业务主导的，业务的混乱导致需求没有一个全局的规划，业务方经常会介入研发过程，会导致开发中断，转而开发新的需求；但后期项目方和业务进行了沟通后，需求由三方（项目、业务、产品）协商准入，并于每周四统一进行需求评审，一定的解决了插入问题；</span><br><span class="line">价值：由于公司内部博弈剧烈，且需求没有一个全局的规划，导致整个产品的风格变动频繁，未有效形成产品自身的品牌，且需求的价值无法量化，投入产出比无法量化分析；</span><br><span class="line">研发：需求无全局规划，研发的人员波动很大，经常会出现项目开发到一半，就出现人员抽调情况，导致原有排期受阻；不过研发在每个季度都有大方向的规划，一般是偏向架构/稳定性/成本把控的，基本都能有效落地；</span><br><span class="line">业务排期：开发/测试，排期极度紧张，且每个人手上同时期基本上都有三四个需求，导致业务很难复盘，资料/能力很难总结，人浮于事的后果就是，整个过程很难实现量化，投入产出比很难分析；且研发虽然在架构方面有大的规划，但过于紧张的人效和时间，导致落地会大打折扣，导致上线产品容易出现性能/稳定性问题；</span><br><span class="line">测试：测试方面在年度季度都会有规划，基本就是我于年终/季度末提交下一季度的规划，这些规划会转变为部门的okr由我负责完成（21年的时候，我手底下还有两个人一般意义上是由我这个组来完成），但由于从21年中开始，公司持续在裁员（一起负责测试架构的另外两个同事被裁了），且公司业务中心变动极大，我又开始负责广告业务，基本没有时间完成规划，只有在管理层有需求时，如（预装需求，必须要做稳定性）；线上出现严重性能问题（必须要进行性能治理），才有一段较时间来完成特定的非业务需求；</span><br><span class="line">总体来看，就是没规划、没标准、无数据无法量化、无细则；</span><br></pre></td></tr></table></figure>

<h3 id="传易音乐质量保障体系分析"><a href="#传易音乐质量保障体系分析" class="headerlink" title="传易音乐质量保障体系分析"></a>传易音乐质量保障体系分析</h3><p><code>传易质量保障体系在全面保障质量的情况下，还需要兼顾成本和效率；同时由于海外业务的复杂性，主要是非洲网络环境较差，普遍都是2/3G网络，终端环境配置较低；因此在设计质量保障体系时需要兼顾这种复杂场景。现有质量保障体系如下：</code></p>
<p><img src="/text_image/%E4%BC%A0%E6%98%93%E9%9F%B3%E4%B9%90%E8%B4%A8%E9%87%8F%E4%BF%9D%E9%9A%9C%E4%BD%93%E7%B3%BB.png" alt="alt text"><br><strong>质量保障体系的缺陷</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">质量保障体系，未做量化分析改造，无数据产出及呈现，很难量化价值；</span><br><span class="line">且体系未制定细化的标准，效果很难衡量；</span><br><span class="line">体系缺乏完整/长期的规划，未能有效的实施和优化；</span><br><span class="line">部分环节/工具，落地不到位，效果不佳，如UI自动化，接口自动化等；</span><br><span class="line">缺失归纳整理，无wiki资料库，能力很难输出和传递；</span><br><span class="line">工具很散乱，未做平台化集成；</span><br></pre></td></tr></table></figure>
<h2 id="质量保障体系的设计理念"><a href="#质量保障体系的设计理念" class="headerlink" title="质量保障体系的设计理念"></a>质量保障体系的设计理念</h2><p><code>质量保障体系，需要遵循全面保障质量；有效平衡质量、效率、成本的理念设计；需要做到质量有数据可量化、有标准可衡量、能落地有效果、可传承可输出、使用成本低</code></p>
<p><strong>设计理念</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">有标准可衡量</span><br><span class="line">有能力有效果</span><br><span class="line">有数据可量化</span><br><span class="line">可传承可输出使用成本低,能兼顾成本、效率、质量</span><br></pre></td></tr></table></figure>
<p><img src="/text_image/%E9%98%BF%E9%87%8C%E8%B4%A8%E9%87%8F%E4%BF%9D%E9%9A%9C%E4%BD%93%E7%B3%BB.png" alt="alt text"></p>
<h3 id="质量标准"><a href="#质量标准" class="headerlink" title="质量标准"></a>质量标准</h3><p><code>质量的标准简单理解就是不出问题，因此对问题的定义，就是对质量标准的定义；我们一般要考虑功能、稳定性、性能（前后端/系统性能）,易用性，因此质量标准的建立抓手就是业务，只有基于业务建立细致完善的质量标准才有意义，而有了标准体系才能有效运转</code></p>
<p><strong>传易音乐的质量标准</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以季度为周期，责任主体是按流程、事故原因分担的；一般的功能性故障必现且是主流程的测试承担100%责任（严重级别），用例漏测同理；非主流程的或非必现的且出现概率较高的，严重级别低一级，测试承担主要责任，开发次之；非测试环境出现的问题或发布导致的问题，开发和测试均摊责任；性能或者稳定性问题，视问题类型，来界定责任主体，此类问题测试只承担次要责任；同时问题持续时间，影响范围，也会影响问题的严重性和责任主体；</span><br><span class="line">每年度制定功能性问题合规标准、性能、系统稳定性问题的合规标准；并根据影响时长，影响范围，严重程度来划分问题等级，问题由项目经理统一收纳，并记录责任主体，在季度末由此数据来影响kpi分值；</span><br><span class="line">提测标准，业务主流程功能ok,自测用例执行通过；</span><br><span class="line">测试通过标准，尽量保证无bug遗留或无严重级别/普通级别的bug遗留；同时根据业务类型来确定，功能、性能、稳定性、安全、兼容性、回归策略是否通过；</span><br><span class="line">验收标准，测试不参与标准制定；但会提交一份验收用例给产品、设计、业务方，是否通过验收由他们自行决定；</span><br></pre></td></tr></table></figure>
<p><strong>不足</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标准制定的不够细致，只有大的框架；</span><br><span class="line">质量问题，只有线上严重级别的问题才会收纳、复盘；且通过在线excel维护；没有形成长期的工作，数据太少，无法持续分析，很难通过数据来进一步优化；</span><br><span class="line">整个标准落地执行不到位，尤其是提测&#x2F;验收的标准未严格实施；其针对标准不执行的情况，没有成文的解决方案，很难长期有效针对此类问题暴露风险；</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong><br><img src="/text_image/%E8%B4%A8%E9%87%8Fgoc%E6%A0%87%E5%87%86.png" alt="alt text"></p>
<h4 id="合理的质量标准"><a href="#合理的质量标准" class="headerlink" title="合理的质量标准"></a>合理的质量标准</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">标准必须要成文，可落地的，既有大框架，也有细则且与业务贴合的；</span><br><span class="line">必须要数据支持，不建议通过一个简单的excel维护，必须要成习惯，有长期数据；</span><br><span class="line">标准必须要在每个阶段都有（自测/测试/验收/线上），且标准不仅限制于事上，对人员，流程都要有要求；</span><br><span class="line">标准必须要有效，要和kpi、升职加薪结合；</span><br><span class="line">除了以上情况，海外业务由于其特殊性；对系统可用性/稳定性有着更高的要求；业界对可用性通常通过Availability公式来衡量（Availability=MTBF/MTBF+MTTR=系统非故障时间/系统非故障时间+系统故障后平均修复时间）,由此可知，要提升系统的可用性，需要从系统的稳定性和系统的维护性下手；另一个衡量系统可用性的标准是1-5-10（1分钟发现、5分钟定位、10分钟修复），这对系统的架构设计有着更高的要求；</span><br><span class="line">覆盖率标准：代码覆盖率是测试度量的有效手段之一，但是要均衡覆盖和成本，做全量代码覆盖不太现实，而且很难做到精细化；在日常迭代过程中，增量代码覆盖率更加直观，可以对每次代码变更做精细化的覆盖率管理，持续提升代码覆盖率。做覆盖率分析是要考虑影响范围，需要考虑（变更导致的调用链路，及链路中受影响的函数；同时也要考虑多链路下其他的分支）</span><br><span class="line">问题率：质量体系最重要的点是保证质量，因此不出现问题才是质量保障的核心；</span><br></pre></td></tr></table></figure>

<p><code>部分细节如下：</code><br><strong>增量代码覆盖率原理</strong><br><img src="/text_image/%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%8E%9F%E7%90%86.jpg" alt="alt text"></p>
<h3 id="覆盖范围"><a href="#覆盖范围" class="headerlink" title="覆盖范围"></a>覆盖范围</h3><p><code>理论上质量保障体系要全面的保障质量，方方面面都要覆盖，但实际工作中要均衡考虑</code><br><strong>范围</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">流程：流程把控，流程优化</span><br><span class="line">测试环节：codereview、单元、集成、系统</span><br><span class="line">类别：性能、兼容、稳定性、监控、功能、安全</span><br></pre></td></tr></table></figure>
<h3 id="测试能力建设"><a href="#测试能力建设" class="headerlink" title="测试能力建设"></a>测试能力建设</h3><p><code>能力建设，一般是指自动化、工具或平台研发能力；但实际项目过程中，协作能力也很重要,这里讲讲工具/平台的建设</code></p>
<p><strong>工具/平台价值</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解决手动测试无法解决的事，如稳定性测试；</span><br><span class="line">自动化测试执行是按固定逻辑来的，能实现执行标准的统一；</span><br><span class="line">提效，可用于解决大量的重复性工作的场景，节省人力，提高效率；</span><br><span class="line">有数据，可溯源；有利于沉淀数据和能力，精准的分析解决问题；</span><br></pre></td></tr></table></figure>
<p><strong>质量保障体系三要素：质量活动、工具平台、质量流程</strong></p>
<p><code>以下按这三块来分别讲述质量体系的构建</code></p>
<h4 id="质量活动及测试执行"><a href="#质量活动及测试执行" class="headerlink" title="质量活动及测试执行"></a>质量活动及测试执行</h4><p><code>在测试策略方面保障质量；主要有两种思路①根据问题设计策略，②分析流程来设计策略 </code></p>
<h5 id="根据问题来设计策略"><a href="#根据问题来设计策略" class="headerlink" title="根据问题来设计策略"></a>根据问题来设计策略</h5><p><code>发现问题，分析问题，从而预防问题</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">需要一个记录问题的‘小本本’，记录下问题、然后分析问题（做复盘，是共性、还是特定问题、是否经常出现）、然后设计策略来预防此类问题；如app经常崩溃，那么质量活动需要包含此类检测；</span><br><span class="line">可以拉取最近一年的线上数据分析，来发现问题；</span><br></pre></td></tr></table></figure>
<h5 id="分析流程来设计策略"><a href="#分析流程来设计策略" class="headerlink" title="分析流程来设计策略"></a>分析流程来设计策略</h5><p><code>研发过程中的各流程都有可能出问题，本着早发现早解决的原则，在各流程设置卡点，来规避风险，同时各环节也可以设置多条防线，全面的保障质量</code><br><strong>如以下情况</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Case1: 业务有很复杂的业务人员配置流程，这个环节会引入业务配置问题，可以在这个环节后定制质量活动，如配置规则校验，配置预跑等。   </span><br><span class="line"></span><br><span class="line">Case2: 业务在运行时仍有新机构/新商户接入环节，可以定制质量活动，如新接入时进行联调验证、性能压测。</span><br><span class="line"></span><br><span class="line">Case3: 业务有间隔性的数据跑批环节，那么在每次数据跑批结束后，可以定制质量活动，在每次跑批后做结果验证。典型业务有日切，月账单生成，关键报表生成等。</span><br></pre></td></tr></table></figure>
<h4 id="工具平台建设"><a href="#工具平台建设" class="headerlink" title="工具平台建设"></a>工具平台建设</h4><p><code>建设工具平台，需要把握好成本和收益；至于如何平衡成本和收益，我的想法是这样的；有些工具是必须的如预装的压测，这种成本不是重点，先必须做出来；但有些比如前端功能测试，研发成熟的ui自动化成本比较高，那可以先考虑部署开源的成熟的产品（或者先手工替代，提前做好回归用例的有效性分析来降低成本）</code></p>
<h4 id="质量流程"><a href="#质量流程" class="headerlink" title="质量流程"></a>质量流程</h4><p><code>质量流程要平衡好质量防控，和效率；要贴合业务、研发体系来设计；并且要结合实际情况，及时调整</code></p>
<h3 id="质量保障体系落地"><a href="#质量保障体系落地" class="headerlink" title="质量保障体系落地"></a>质量保障体系落地</h3><p><code>在具体落地的过程中，要把控好，质量、成本、效率，做好均衡来设计具体的质量策略</code><br><strong>具体落地的策略</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">具体的质量策略，要结合业务；最好结合业务数据，做量化分析制定；</span><br><span class="line">评估质量、效率、成本现行情况，做好平衡；</span><br><span class="line">策略要具体，要能保障项目的一致性，形成共识，实现质量标准化；</span><br></pre></td></tr></table></figure>
<p><strong>举例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">比如，质量保障体系规定了要做灰度发布，那么怎样做灰度发布？质量策略可以进一步规定执行细节：至少要包含从1%-&gt;10%-&gt;50%-&gt;100%四个阶梯的灰度，且灰度时长不小于2小时。</span><br><span class="line"></span><br><span class="line">再比如，质量保障体系约定了低风险项目可开发自测，那么质量策略可以进一步定义低风险项目包括bug fix，页面展示修改类项目等。</span><br><span class="line"></span><br><span class="line">再比如，质量保障体系要求回归测试要完整，那么质量策略可以进一步定义完整回归的具体要求：全部P0P1用例(不区分手工自动化) or 全部自动化用例 or 人工评估的所有场景用例 or 代码变更分析的所有自动化用例 等。</span><br></pre></td></tr></table></figure>
<p><strong>质量工具/平台具体落地的策略</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">提效；要综合提效；代码不是目的，提效才是；</span><br><span class="line">要有具体落地的场景，一个质量工具平台最好能锁定某个稳定存在的质量活动、防线作为服务对象，以保证质量工具平台自身的存续性；</span><br><span class="line">维护/使用/培训成本也需要考虑；</span><br><span class="line">设计时要考虑能力沉淀和输出，最大化工具的价值；</span><br><span class="line">要尊重历史积累，考虑历史工具数据沉淀和价值挖掘；</span><br><span class="line">避免重复造轮子；要做到工具平台信息的充分共享、及时刷新，避免因信息不足导致的重复造轮子，其次在有同类工具平台新建初期，及时发起评审，确定定位和发展路线，避免发展成已有轮子的复制品。最后，要在大横向组织里阶段性review同领域工具平台，做好顶层设计（定向发展or关停并转）；</span><br><span class="line">要做好工具的服务推广，工具的价值在于使用；</span><br><span class="line">要保证工具平台体系的持续发展，需要有统一的度量指标，否则难以运营迭代；服务好业务和需求，阶段性考虑质量工具平台的整合、共建、打通，串联形成工具平台体系，形成一致性的服务体系；</span><br><span class="line">需要考虑工具间的集成，结果的集成，联系，实现持续集成；</span><br><span class="line"></span><br><span class="line">先保障基础的平台有，如组织协作的平台，bug管理平台，代码托管平台；</span><br><span class="line">要做好整体规划；分析缺口，必要的工具优先做,但要保证效果（覆盖率，发现率，召回率，准确率等），效果越好越有价值；</span><br><span class="line">非必要的一般是提效的工具，在进一步拆分工作，分析日常工作中各部分工作的占比耗时，以及未来的趋势，优先覆盖重复性强场景；</span><br><span class="line">提效工具要做好性价比综合分析，对比人力或其他工具，当新开发工具的成本（一次性开发成本和维护性成本的考量：接入成本、迁移成本、培训成本、每次使用成本、维护升级成本）相对于收益有明显优势时才有价值；</span><br><span class="line">在devops研发体系、云原生等架构升级中，质量工具做好设计要支持整合同步升级；</span><br><span class="line">自动化测试体系，数据构造是一块很大的工作；可以基于线上流量采集回放的方式；为自动化各环节提供数据；</span><br></pre></td></tr></table></figure>
<p><strong>参考：阿里国际团队质量工具平台的设计方案</strong><br><img src="/text_image/%E8%B4%A8%E9%87%8F%E5%B7%A5%E5%85%B7%E5%B9%B3%E5%8F%B0%E8%AE%BE%E8%AE%A1.png" alt="alt text"><br><img src="/text_image/%E8%B4%A8%E9%87%8F%E5%B7%A5%E5%85%B7%E5%B9%B3%E5%8F%B0%E6%96%B9%E6%A1%88.png" alt="alt text"></p>
<p><strong>针对质量工具/平台各环节，进行了归纳</strong></p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">存量老代码，缺乏单测的情况下，需要方案实现快速补全；</span><br><span class="line">复杂系统或者模块，构造数据成本很高，需要有工具支持；</span><br><span class="line">系统重构，单测容易大面积的失效，需要在设计时考虑如何解决；</span><br></pre></td></tr></table></figure>
<p><strong>如下是阿里国际团队的解决思路</strong><br><img src="/text_image/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.png" alt="alt text"></p>
<h4 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h4><p><code>海外业务，由于多集群，多站点的特点，用例的维护成本很高，且会持续加大；因此在用例构造上，需要加大自动化，减少人力投入</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在用例收集上，自动收集、分析、自动去重重复用例，就可以自动沉淀用例集，同时也需要有人工输入专家维护，提升特征丰富度和用例覆盖率。</span><br><span class="line"></span><br><span class="line">在用例管理上，弱化了传统相对复杂的用例集管理功能，使用系统托管的方式进行用例维护，并且用例运行时自动根据多租户、合规等条件进行调度，保证准确性同时降低人工介入成本。</span><br><span class="line"></span><br><span class="line">在回放结果上，通过对错误、断言等聚合分析，有效减少失败分类数量，降低人工排查的成本，并在运行后提供代码覆盖率和业务覆盖率度量结果。</span><br></pre></td></tr></table></figure>
<p><strong>如下是阿里国际团队的解决思路</strong><br><img src="/text_image/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86.png" alt="alt text"></p>
<h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p><code>集成测试是针对局部业务，或者模块单元的测试；可通过功能测试实现，但实际工程中可能会存在功能无法覆盖的情况，此时需要通过mock来构造数据，通过模块单元的代码的测试来实现覆盖，关于集成和单元的区别如下</code><br><img src="/text_image/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95.png" alt="alt text"></p>
<h4 id="用例-工具持续集成"><a href="#用例-工具持续集成" class="headerlink" title="用例/工具持续集成"></a>用例/工具持续集成</h4><p><code>持续集成，能实现定时/持续调度，能实现定时监控，用例有效性监控，结果聚合，同时进行串联能保证服务的一致性，形成全链路、全覆盖的质量展示，架构如下</code><br><img src="/text_image/%E4%B8%80%E4%BD%93%E5%8C%96%E7%9A%84%E7%94%A8%E4%BE%8B%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.png" alt="alt text"></p>
<h4 id="环境管控"><a href="#环境管控" class="headerlink" title="环境管控"></a>环境管控</h4><p><code>环境的稳定性，会直接影响开发测试的效率；同时环境还需要兼顾成本，毕竟预算有限；同时作为服务海外用户的公司，我们对海外环境也有需求；</code><br><strong>测试环境问题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">测试效率问题：测试环境的稳定性，会严重影响上下游测试效率；</span><br><span class="line">测试环境资源问题：需求高峰期并发，涉及测试环境抢占；需求低峰期，多余测试环境被闲置；</span><br><span class="line">测试环境隔离问题：子域内需求需要相互隔离；子域之间快速支撑联调；</span><br><span class="line">测试环境使用成本：测试环境答疑成本，以及构建成本；</span><br><span class="line"></span><br><span class="line">其中的难点</span><br><span class="line">支持隔离：测试环境隔离支持同步接口/HTTP服务和异步消息隔离；</span><br><span class="line">弹性部署：测试环境资源根据需求情况，弹性占用，同时也要控制预发环境膨胀的问题；</span><br><span class="line">环境问题定位：往往业务问题、系统问题都会被上报为环境问题，导致排查耗时，如何快速定位问题？</span><br><span class="line">各环境如何保障长期有效，更新同步；</span><br><span class="line"></span><br><span class="line">魅族通过集群的方式，实现固定节点放置固定服务，进行标准化，通过代理/路由的方式灵活指向服务机器，来实现隔离，弹性部署；</span><br></pre></td></tr></table></figure>
<p><strong>环境流转的实例（阿里）</strong><br><img src="/text_image/%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.png" alt="alt text"><br><strong>保证环境稳定性的思路（阿里）</strong><br><img src="/text_image/%E7%8E%AF%E5%A2%83%E7%A8%B3%E5%AE%9A%E6%80%A7.png" alt="alt text"></p>
<h4 id="针对海外-业务特点考虑的落地策略"><a href="#针对海外-业务特点考虑的落地策略" class="headerlink" title="针对海外/业务特点考虑的落地策略"></a>针对海外/业务特点考虑的落地策略</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">由于业务在海外，会有数据安全和监管的考量（数据不允许出入境）；测试数据、测试用例运行维护会面临一定挑战；</span><br><span class="line">海外业务，由于要部署多个国家，集群分散，站点众多，测试工作量会大幅提升；</span><br><span class="line">由于业务复杂度较高，且研发有着自测和联调的需求，需要提供工具支持，针对后端接口的自测和联调，现在使用的是免费的工具apifox（提供团队协作、接口管理、mock、调试、压测、联调等能力)</span><br></pre></td></tr></table></figure>
<h4 id="质量流程-1"><a href="#质量流程-1" class="headerlink" title="质量流程"></a>质量流程</h4><p><code>要保障质量，但靠人和工具是不行的；还需要一套完善的流程，从工业界的角度考虑即SOP(标准作业程序)，即给整个交互体系，制定一个细化且可量化的流程，sop的价值如下：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">流程可量化，有线上数据，正因为如此，才可以进一步的运营和优化；有数据才可以判定价值；</span><br><span class="line">有细致完善的标准，才可保障产品和服务的品质，才能保证有效的覆盖率；</span><br><span class="line">sop还会使整个链路更清晰，从而保证各环节互不干扰，能大幅提高交付效率；</span><br></pre></td></tr></table></figure>
<h5 id="如何建立一个完善的sop流程"><a href="#如何建立一个完善的sop流程" class="headerlink" title="如何建立一个完善的sop流程"></a>如何建立一个完善的sop流程</h5><p><code>要建立完善的交付体系，需要从业务入手；发现现有体系中的问题，聚集关键节点；加强组织协作形成共识；通过线上流程管控沉淀数据；基于数据分析运营优化不断迭代，推导过程如下</code><br><img src="/text_image/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8Bsop%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B.png" alt="alt text"></p>
<p><strong>参考sop体系如下，核心：筛选关键节点/问题+线下会议对焦+线上流程管控+数据分析优化</strong><br><img src="/text_image/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8BSOP%E4%BD%93%E7%B3%BB.png" alt="alt text"></p>
<p><strong>SOP研发体系运营和落地</strong><br><code>标准作业流程要想产生价值，需要做好运营和落地，但具体的实施还是要和业务结合</code></p>
<ul>
<li>落地方式：<ul>
<li>①通过架构升级的方式来推动落地,建立目标，推动前进；</li>
<li>②绑定kpi、okr指定责任人来，分阶段推动落地，在落地过程中要持续观察数据、分析效果； </li>
</ul>
</li>
</ul>
<p><strong>SOP流程运营目标（阿里参考表）</strong><br><img src="/text_image/SOP%E8%BF%90%E8%90%A5%E7%9B%AE%E6%A0%87.png" alt="alt text"><br><strong>SOP数字化参考报表</strong><br><img src="/text_image/sop%E6%95%B0%E5%AD%97%E5%8C%96%E6%8A%A5%E8%A1%A8.jpg" alt="alt text"></p>
<h3 id="传音音乐质量保障体系理想版"><a href="#传音音乐质量保障体系理想版" class="headerlink" title="传音音乐质量保障体系理想版"></a>传音音乐质量保障体系理想版</h3><p><code>质量保障体系是用来保障质量的，没问题或者问题变少了就是最大的价值,具体来看</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通过量化数据分析，质量问题，通过结果来确定质量保障体系的价值；</span><br><span class="line">分析具体的问题和结果，有问题就能找到体系薄弱点，进一步优化；结果好，也需要确认价值在哪，是否能进一步细化深化优化；</span><br><span class="line">最后分析质量工具平台的支撑度和技术价值，针对性的实现价值量化可呈现；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>质量体系</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-7月新工作准备</title>
    <url>/posts/377e71de/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><pre><code>通过半个季度的学习，达到准高级工程师水准，进入大厂（BAT/TMDJKXB）;
</code></pre>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><em><strong>科目</strong></em></p>
<ul>
<li>✔语言基础</li>
<li>✔算法</li>
<li>✔计算机网络</li>
<li>计算机系统/云原生体系</li>
<li>✔数据库</li>
<li>大数据架构</li>
<li>前端</li>
<li>✔测试设计</li>
</ul>
<p><em><strong>执行规划</strong></em></p>
<ul>
<li>✔工作梳理</li>
<li>✔质量体系构建</li>
<li>✔技术复盘</li>
<li>✔期望岗位</li>
<li>✔岗位技能要求分析</li>
<li>✔面试题</li>
<li>✔准备简历</li>
<li>人脉资源</li>
<li>✔面试复盘</li>
</ul>
<span id="more"></span>

<h2 id="科目"><a href="#科目" class="headerlink" title="科目"></a>科目</h2><h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><p><code>语言需要解决的问题，操作对象（支持数据类型），对象可进行哪些处理（运算/算法），语句组织（函数/类/模快），应用解决实际问题（建模/面向对象编程） </code></p>
<p><em>书籍：</em></p>
<ul>
<li>python学习手册</li>
<li><a href="https://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html">python快速教程</a></li>
<li><a href="https://github.com/daolf/Most-recommended-programming-books#methodology">最好的python技术书籍合集</a></li>
</ul>
<p><em>实战：</em></p>
<ul>
<li>leetcode</li>
<li>牛客（对应面试企业的题）</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>发一到两天滚一遍算法图解</li>
<li>leetcode结合企业面试题刷算法</li>
</ul>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul>
<li><p><a href="https://www.cnblogs.com/1009gavin/category/1177473.html">计算机网络系列博客</a></p>
</li>
<li><p><a href="https://www.processon.com/view/link/64c636417807695f148f7852">网络全流程图</a></p>
</li>
<li><p>针对面试中常见的网络和协议问题进行准备</p>
<h3 id="系统-云原生体系"><a href="#系统-云原生体系" class="headerlink" title="系统/云原生体系"></a>系统/云原生体系</h3></li>
<li><p><a href="https://www.cnblogs.com/1009gavin/p/8553995.html">shell脚本编写</a></p>
</li>
<li><p><a href="https://note.youdao.com/ynoteshare/index.html?id=6e76d9bbd23102bf1e84fbd53e3ae86d&type=note&_time=1689494339990">linux常用命令</a></p>
</li>
<li><p>测试环境部署相关（docker/k8s/自动化环境部署/自动化测试后端环境问题定位）</p>
</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li><a href="https://www.cnblogs.com/1009gavin/category/1174710.html">sql简单语法</a></li>
<li><a href="%E6%8A%BD%E5%87%A0%E4%B8%AA%E7%9C%8B%E4%B8%80%E4%B8%8B">sql经典实例</a></li>
<li><a href="%E6%8A%BD%E5%87%A0%E4%B8%AA%E5%81%9A%E4%B8%80%E4%B8%8B">leetcodesql题</a></li>
<li>redis常见面试题刷几个</li>
<li>数据库特性操作（慢查询/分表/防攻击等）</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h3 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h3><ul>
<li>《海盗派测试分析》看这本书学习测试思维的套路；<a href="https://www.bujiaban.xyz/posts/9eaf5086/">测试设计</a></li>
<li><a href="https://testerhome.com/topics/24284">The Little Black Book of Test Design</a>；看这本小书学习测试思维；</li>
<li>高级软件测试分析师</li>
<li>高级软件测试管理<br><strong>后两本书是国际软件测试工程师高级考试的教材</strong></li>
</ul>
<h2 id="执行规划"><a href="#执行规划" class="headerlink" title="执行规划"></a>执行规划</h2><h3 id="工作梳理"><a href="#工作梳理" class="headerlink" title="工作梳理"></a>工作梳理</h3><p><a href="https://www.bujiaban.xyz/posts/c184c696/">传易工作总结</a></p>
<h3 id="质量体系构建"><a href="#质量体系构建" class="headerlink" title="质量体系构建"></a>质量体系构建</h3><p><a href="https://www.bujiaban.xyz/posts/274713e6/">质量保障体系</a></p>
<h3 id="技术复盘"><a href="#技术复盘" class="headerlink" title="技术复盘"></a>技术复盘</h3><p><strong>见上方</strong></p>
<h3 id="期望岗位"><a href="#期望岗位" class="headerlink" title="期望岗位"></a>期望岗位</h3><ul>
<li><strong>管理方向</strong></li>
</ul>
<p><code>小公司的管理岗（研发团队10-100）；构建sop体系，研发平台工具，管理人员；筛选出价值观、目标能达成一致的人遵循，平等、低预期、身体力行的原则来管理</code></p>
<ul>
<li><strong>业务岗</strong><ul>
<li>业务方向：尽量找大数据相关的方向（大数据体系，我必须先了解下）；优先考虑广告、音乐（内容）、金融业务；</li>
<li>技术方向：优先考虑性能、；sop流程建设；其次才是各类工具岗；</li>
</ul>
</li>
</ul>
<h3 id="岗位技能要求分析"><a href="#岗位技能要求分析" class="headerlink" title="岗位技能要求分析"></a>岗位技能要求分析</h3><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p><code>管理岗位始终围绕着；团队管理/体系建设/平台研发/协调管控，来开展工作</code></p>
<ul>
<li><p><strong>腾讯</strong><br><strong>岗位要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">经验：具备两到三年以上的管理经验（相关行业），5年以上工作经验（各领域）；要有质量中台团队管理经验，快速迭代的项目经验；有大型项目的经验能负责团队的管理；</span><br><span class="line">团队：有团队搭建管理优化经验；</span><br><span class="line">云体系：熟悉云原生，有持续交付实践经验；有智能化和中台化改造的经验；熟悉K8S、devops建设；</span><br><span class="line">质量体系：能建设质量体系，有整体技术规划，工具平台的架构设计能力；架构经验要全面，含业务架构、效能流程、基础技术架构（安全/可用性/技术平台）；要具备研发流程组织管控能力；具备建立sop研发体系能力，能推动运营优化流程；</span><br><span class="line">技术：要有技术能力，广而深的能力，实现核心代码，解决核心问题难题，且独立/主导开发过平台；</span><br><span class="line">其他：懂推荐算法，机器学习加分；</span><br></pre></td></tr></table></figure>
<p><strong>岗位职责</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">业务：开发工具、平台，服务业务，参与或组织或规划业务测试；</span><br><span class="line">质量体系：负责质量体系的建设优化；参与云环境下的持续交互体系建设；深刻理解CICD 及测试各项技术，有服务化、云化软件开发的实践经验者优先；主导项目/业务进行数字化、信息化、标准化改造；</span><br><span class="line">管理：团队管理/招聘/规划/搭建，出色的团队领导能力和管理能力，有丰富的团队建设经验，有能力吸引和发展杰出人才；</span><br><span class="line">协作：沟通协作（跨部门），推动；擅于跨团队沟通和协作，具有强烈的责任感和大局观，良好的沟通、表达、协作能力及服务意识。</span><br></pre></td></tr></table></figure>
<p><strong>个人品质要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">自驱动能力强，诚实；</span><br><span class="line">海外项目，需要有海外项目经验，良好的英文口头及书面表达能力，能使用英文作为工作语言；</span><br><span class="line">具备一定的谈判能力与冲突管理能力，能够承担一定的压力；</span><br></pre></td></tr></table></figure></li>
<li><p><strong>其他公司</strong><br><strong>同上</strong></p>
</li>
</ul>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p><code>业务方面，必须是历史具有经验的；过往工作主要集中在大数据业务的广告，金融风控，音乐类文娱产品；技能方面，主要考虑稳定性、性能、测试平台</code></p>
<h5 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h5><p><code>广告基本是我职业生涯的全部，广告业务主要分为全链路业务，专项、业务专项主要是模型、对接外部的广告sdk；</code><br><strong>岗位要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">经验：具有3年以上广告/大数据业务的经验,具有工具/测试平台开发经验（尤其需要有前端经验）；有专项经验、性能、安全、白盒；</span><br><span class="line">coding：熟悉C/C++/Java/Golang等至少一种编程语言，有Shell或Python等使用经验者优先；深入了解语言特性，数据结构与算法，体系结构等计科知识出色；</span><br><span class="line">云体系：熟悉云原生有K8S、flink、spark、微服务等经验，有持续交付实践经验；有智能化和中台化改造的经验；</span><br><span class="line">平台：熟悉常用的框架，开源项目；给开源项目贡献过代码者优先；其中要对主流前端框架（React\Vue\Angular等）有一定了解，同时对后端的Django／flask等框架也需要有了解；</span><br><span class="line">大数据：熟悉大数据的kafka等技术；且了解机器学习、搜索/推荐/广告等算法；</span><br></pre></td></tr></table></figure>
<p><strong>岗位职责</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">业务：负责广告产品/服务的业务测试，并负责各类专项测试；</span><br><span class="line">环境：负责环境治理及运营；</span><br><span class="line">工具：负责工具平台的开发、运营；</span><br><span class="line">质量体系：负责质量体系的建设优化；</span><br></pre></td></tr></table></figure>
<h5 id="音视频文娱"><a href="#音视频文娱" class="headerlink" title="音视频文娱"></a>音视频文娱</h5><p><code>音视频等产品，最核心的点是音视频资源、推拉流方面的质量专项，其他功能和常规产品差异不大</code></p>
<p><strong>岗位要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">经验：三年以上的音视频产品测试经验（具备多媒体行业经验，有点播、直播、媒体服务、音视频产品）</span><br><span class="line">coding：熟悉C/C++/Java/Golang等至少一种编程语言，有Shell或Python等使用经验者优先（或者至少精通python、了解java）；深入了解语言特性，数据结构与算法，体系结构等计科知识出色；音视频产品需要一定的前端（android/ios）经验；</span><br><span class="line">音视频：了解多线程、及音视频播放原理；熟悉MP4、HLS、DASH、TS、FLV等多媒体容器格式及编解码、网络等策略优化；熟悉音视频生产、传输、播放全流程；熟悉YUV，RGB图像格式；PCM等音视频开发基础知识；了解H.264/H.265/VP9/AV1等至少一种音视频编解码标准；</span><br><span class="line">音频评测：熟悉语音编码或者音频编解码标准，如G.7xx、AMR系列、EVS、AAC系列、OPUS等；熟悉语音编码或者音频编解码标准；熟悉音频质量相关的测试流程，包括音质，响度，时延，连麦通话、音效等测试；</span><br><span class="line">视频评测：有（FFmpeg、H.265&amp;H.266、Traffic Control配置、Wireshark网络分析、OpenCV）等视觉检测评估工具使用经验、视频编解码、流媒体协议，对播放器等相关经验；</span><br><span class="line">音视频专项：精通音视频专项Qoe评测，熟悉音视频的上下行全链路，有参与过Media Codec/Android Framework/ RTC Qos/采集渲染优化/前后处理优化等专项的其中一种，能洞察产品的体验不足；</span><br></pre></td></tr></table></figure>
<p><strong>岗位职责</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">业务：负责音视频产品/服务的业务测试，并负责各类专项测试（特殊的点、音质、画质、音视频编解码、渲染、网络策略、时延、卡顿、流畅度、弱网）；</span><br><span class="line">环境：负责环境治理及运营；</span><br><span class="line">工具：负责工具平台的开发、运营；</span><br><span class="line">质量体系：负责质量体系的建设优化；</span><br><span class="line">音视频测评体系：负责音质测评体系建设，音质测评模型开发；</span><br></pre></td></tr></table></figure>

<h5 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h5><p><code>从入行以上，经历的项目都和大数据强相关（广告），因此在大数据项目方面，我的职业经历有一定的优势；大数据项目职业方向主要有，基于大数据架构的数据测试和大数据应用方面的模型测试。</code><br><strong>岗位要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">经验：三年以上的大数据项目测试经验；需要有相应的业务的经验（典型业务、搜索推荐、广告、数仓）；</span><br><span class="line">架构：熟悉大数据相关组件包括Hadoop、Hive、Hbase、Spark、Storm、Kafka、flink，flume、pulsar、es、clickhouse、Druid等分布式框架原理，有相关的调优、运维、开发经验者优先；</span><br><span class="line">应用：有大数据集群部署经验，有丰富大数据场景经验，问题快速定位跟踪者优先；</span><br><span class="line">数据：有数据湖相关开发测试经验，覆盖数据加工（离线数仓、ETL）/数据平台/数据产品测试；有落地形成数据测试的方法论，且熟悉sql；</span><br><span class="line">模型：有AI工程系统开发或测试（特征工程/训练/预测）经验，统计学/数据挖掘/机器学习等背景知识，了解常见的算法指标评(AUC/ROC/F1)和AB实验优先；具备算法模型评估经验 / 推荐排序类系统测试经验；</span><br><span class="line">云体系：熟悉云原生，有持续交付实践经验；有智能化和中台化改造的经验；</span><br><span class="line">coding：熟悉C/C++/Java/Golang等至少一种编程语言，有Shell或Python等使用经验者优先（或者至少精通python、了解java）；深入了解语言特性，数据结构与算法，体系结构等计科知识出色；</span><br><span class="line">体系：数据质量体系建设、运营；含数据构造，数据录制/回放，数据全链路追踪，数据监控等；以及效果评估体系建设；</span><br></pre></td></tr></table></figure>
<p><strong>岗位职责</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">业务：负责大数据产品/服务的业务测试，并负责各类专项测试；</span><br><span class="line">环境：负责环境治理及运营；</span><br><span class="line">工具：负责工具平台的开发、运营；</span><br><span class="line">质量体系：负责质量体系的建设优化；</span><br></pre></td></tr></table></figure>

<h5 id="海外"><a href="#海外" class="headerlink" title="海外"></a>海外</h5><p><code>海外项目最重要的是语言和背景；英语、其次是市场所属的小语种最佳</code><br><strong>岗位要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语言：英文读写能力良好，具备基本的英文表达能力，能使用英文作为工作语言；</span><br><span class="line">经验：海外项目的经验，尤其是海外项目的协作经验；针对国际化业务在全球不同地区合规、数据、安全等方面的差异和风险，探索和构建相适应的质量保障策略和手段，并进行有效的落地；</span><br><span class="line">沟通：海外需要跨国或者跨部门沟通，对沟通协作也会有一定的要求；</span><br><span class="line">管理：海外人员/团队的构建和管理；</span><br><span class="line">技能：比国内低一档；</span><br></pre></td></tr></table></figure>
<p><strong>岗位职责</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">业务：负责海外产品/服务的业务测试，并负责各类专项测试；</span><br><span class="line">环境：负责环境治理及运营；</span><br><span class="line">工具：负责工具平台的开发、运营；</span><br><span class="line">质量体系：负责质量体系的建设优化；</span><br><span class="line">管理：复杂团队的搭建管理，沟通协作；</span><br></pre></td></tr></table></figure>
<h5 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h5><p><code>效能岗主要有两类，面向业务的效能提升；另一类是面向基础架构的效能平台建设</code></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="面试真题合集"><a href="#面试真题合集" class="headerlink" title="面试真题合集"></a>面试真题合集</h4><ul>
<li><a href="http://localhost:4000/posts/7eb8636e/">部分流程问题</a></li>
<li><a href="https://testerhome.com/topics/30721">部分测开面试技术题</a></li>
<li><a href="https://maimai.cn/article/list?uid=222663796">脉脉-霍格沃兹面试题合集</a></li>
<li><a href="https://maimai.cn/feed_list?feeds_api=/groundhog/feed/v5/user?only_realname_status=1&u2=236921909&&title=%E6%9E%AB%E5%8F%B6%E7%9A%84%E5%8E%9F%E5%88%9B%E5%8A%A8%E6%80%81&simple=1">脉脉社区面试题合集</a></li>
<li><a href="https://www.nowcoder.com/discuss/402039097496293376?sourceSSR=search">22年腾讯面经导航汇总</a></li>
<li><a href="https://nowcoder.com/discuss/397702159398088704?sourceSSR=users">22年工行面试汇总</a></li>
<li><a href="https://www.nowcoder.com/discuss/394088421159956480?sourceSSR=users">22年阿里秋招面经导航汇总</a></li>
<li><a href="https://www.nowcoder.com/discuss/386159825611235328?sourceSSR=users">22年美团秋招面经导航汇总</a></li>
</ul>
<h4 id="质量流程"><a href="#质量流程" class="headerlink" title="质量流程"></a><strong>质量流程</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基本的测试流程？</span><br><span class="line">测试周期是五天，今天是第三天，发现了一个主流程bug，你需要做什么？</span><br><span class="line">	评估整体问题风险，修改计划，影响范围，需要调动的修复资源</span><br><span class="line">	对交付时间的影响，整体项目是否可以接受，根据时间承受范围，做出修复方案的判断</span><br><span class="line">	完成修复计划</span><br><span class="line">	复盘整体问题，讨论为什么主流程问题会在测试后期才被发现。测试流程或总理，缺失？需求临时变更？代码无选择入库？堵住漏洞防止问题再次发生</span><br><span class="line"></span><br><span class="line">了解哪些测试方法；?黑盒白盒测试的测试用例设计方法都有哪些？</span><br><span class="line">介绍一下单元测试和冒烟测试？单元测试写过吗？</span><br><span class="line">项目质量的准入准出原则？</span><br><span class="line">灰度上线的标准是是么？</span><br><span class="line">平时怎么做的测试？</span><br><span class="line">现在的业务方面测试流程，质量保障方面的措施，除了自动化，人工怎么分配的?</span><br><span class="line">深问了覆盖率、接口自动化，同时也简单说了下BDA(数据测试)、CTS（android系列兼容测试（Compatibility Test suite））、PFT（），流水线一些准入要求</span><br><span class="line">如何看待peer之间观点不一致？怎么解决?</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：需求评审阶段对需求进行分析-开发设计阶段对设计进行分析判断-设计测试方案-写才测试用例/准备测试数据/测试环境-提交自测用例给开发（辅助开发自测）-测试执行/bug跟踪-rc验收-复杂产品验收-灰度测试-线上验收-资料整理归档；（其中还涉及到部分环境的准入准出的标准的建立、事后的复盘）以上现有流程；</span><br><span class="line">测试流程，其实是质量体系很重要的一部分；需要遵循SOP标准（标准、文本、自动化）、基于上下文和风险的测试逻辑；兼顾成本和质量；因此在设计流程时，需要考虑以下方面：</span><br><span class="line">1、如何建立质量标准，OKR、KPI等工具如何和标准结合；维护质量标准，有无线上/线下问题的收集归纳机制；</span><br><span class="line">2、有没有配套工具，来运营流程；分析优化问题；</span><br><span class="line">3、如何提高流程的效率，如何建立适合公司的敏捷模式，如何和云原生、中台等相结合提效；</span><br><span class="line">4、如何根据公司的规模，人员情况，推动以上问题的处理；</span><br><span class="line"></span><br><span class="line">答②：测试的主要工作是提前发现问题，暴露风险；</span><br><span class="line">因此要赶快把风险暴露出来；先评估现阶段的风险，影响的范围；然后把风险立即暴露给项目组，组织协调资源，修改计划；</span><br><span class="line">完成修复计划；复盘问题，考虑为何没有提前发现主流程问题，是需求变更没有及时同步，还是开发私自更加了主流程代码或者其他代码合入问题，还是测试设计不合理；</span><br><span class="line">针对具体的原因，和未来可能出现的风险，优化流程，新增一些卡点策略或流程要求；</span><br><span class="line"></span><br><span class="line">答③：测试是一系列的活动；我理解的测试方法，应该是不局限于测试设计的；测试活动的主要过程有，测试信息收集（KYN）、测试信息分析（MFQ/SFDIPOT）、测试方法建模（PPDCS）、测试点覆盖率/有效性分析、最后是执行环节、其实每个环节都很重要需要注意，都考虑方式方法；但是我们一般问的都是测试设计/或者说是建模时候的方法；根据场景不同、特征不同使用不同的方法。比如如果是一些输入数据或者参数，具有数据/类型特征的，（如登录，注册输入的场景，就考虑使用等价类，边界值，覆盖有效等级类的各类，然后各类无效等价类边界值）；如果特征是一些状态变化的，（比如视频播放，暂停，恢复播放这些），我会考虑使用状态迁移法；如果是流程性的，（比如新手引导），我会考虑使用流程图；如果是输入直接有逻辑关系，输入输出有因果关系（比如抽奖活动的一些，IP限制，国家限制，不同国家，不同奖品不同中奖率这些），我会考虑因果图+判定表，然后使用没一列作为一条测试点；然后比如是一些数据报表，组合查询，这种输入参数没有逻辑约束，我可能直接就用组合法（也就是正交实验法）；白盒测试设计方法，主要是覆盖率方面考虑吧；考虑覆盖路径/覆盖条件/覆盖条件组合/覆盖语句这些，还是要根据具体业务和当前项目的情况来；这个问题有点大，我不确定我答的方向是否是对的；其他的一些方法，考虑其他方面，基于风险的，比如有些模块，测试/线上经常出问题，那功能迭代，过去的bug，是不是要做下参考甚至走一遍，其他的就是人员，为了保障质量是否对每个人员的开发质量，或者测试人员的质量需要做量化，如果有些人质量不好，是不是要进行一些培训或者帮助、或者调整；对提测功能大小、代码合并啊这些；当然这些都是要考虑，但一般不在测试设计环境考虑了，会在其他阶段；</span><br><span class="line"></span><br><span class="line">答④</span><br><span class="line">我是这样理解这个问题的，我先说一下黑盒/白盒的测试方法吧，然后我在讲下我在工作中哪些场景中用到了；黑盒（等价类/边界值/判定表/因果分析/正交分解/场景/错误推导/功能图）白盒（语句覆盖/判定覆盖/条件覆盖/条件组合覆盖/路径覆盖）；然后举例说明使用情况，举例最好能体现测试设计能力（覆盖率/成本/效率）</span><br><span class="line"></span><br><span class="line">答⑤</span><br><span class="line">单测是对系统最小粒度的测试；白盒层面的测试，一般是覆盖代码的函数/类/模块/多模块的测试（讲的时候需要体现单测的标准/覆盖率/流程/量化）；我们这边的单测是由开发实现单测代码，部分功能由测试codereview，检查单测代码的覆盖率（覆盖率要达到90%）；这种方式导致了单测环境测试参与不多，对整个项目的单测覆盖率很难衡量、还有就是需要codereview测试能参与的人力比较少，考虑通过开源框架实现一个待测覆盖率的检查脚本，同时开发单测时需要一些测试数据，这块未来考虑实现一个mock工具通过测试造数，开发调用给开发提供数据；冒烟是有测试在用例设计时标记冒烟用例（通过在线excel文档维护），提交给开发执行，开发执行通过后，标记执行通过，然后在进行提测；提测时，测试会先验收一遍冒烟用例，一旦冒烟不通过则会打回，且会记录，后续项目会根据文档数据归总，会影响开发的绩效；</span><br><span class="line"></span><br><span class="line">答⑥</span><br><span class="line">（各环节标准/标准的文档量化/优化）我们质量保障的设计在各环节都有准入准出标准，依次是需求分析阶段需求进入评审必须要有原型图有文档，且同一个需求评审不能多于两次，开发/设计/测试方案评审同理（测试用例的覆盖率不低于90%）；在提测前开发必须要进行单测且单测的覆盖率不低于90%（由开发自己实现），然后就是冒烟阶段（冒烟用例通过率必须是100%），测试执行，用例必须全部执行/中高等级用例必须全部执行，低级别用例未执行率不超过10%，rc验收前用例修复率必须达到100%，或者低级别用例不能超过5个、中高级别必须全部修复，且整体bug遗留率不能超过1%；然后就是rc验收必须无问题；灰度用例必须全部通过，线上反馈的bug不能超过总bug数的1%，且不能有中高级别的bug;整个过程主要通过tapd,在线excel文档，禅道来追溯；</span><br><span class="line"></span><br><span class="line">答⑦</span><br><span class="line">测试，rc验收通过；产品/设计验收通过；无bug遗留，或无中高级别bug遗留低级别bug遗留率不超过1%；上线环境、配置完成准备，且审核通过；然后就进行灰度方便；灰度梯度加量，线上无问题，则逐步到全量；</span><br><span class="line">工作占比，体系化思维，流程；我的日常工作在不同的时间段，工作重心不一样；在前面一年左右，主要负责大数据数据相关的测试，涉及的业务主要是版税结算，音乐的效果数据报表，音乐资源去重这些；已经自动化相关的建设，ui自动化、接口自动化、性能、压测；后面主要负责广告业务的测试已经部分音乐服务端业务的测试；在自动化工作中，我一开始的目的是想先把相应的工具搭起来，先解决从未到有的问题，以实现产出，后续主要是优化，建立规范标准，优化工具，来让工具产生实际的价值，解决监控，重复性回归的问题；当时的规划是提升自动化的覆盖率。让效果可量化，建立可视化的仪表（但这一块没机会落地），因为从22年年中开始就一直有大的人员的调整；在业务测试方面，我的工作思路是先用，先体验，在依赖需求，和相应的同事，以及网上相关的资料，和现在存在和遇到的问题来熟悉产品，发现痛点，从而设计测试方案，建立质量衡量的标准；在过程中遇到相关的问题会请教leader，协商解决然后推广；</span><br><span class="line"></span><br><span class="line">答⑧⑨</span><br><span class="line">我们人员共分了四组，一组负责主业务（音乐）客户端的测试，另一组负责音乐服务端的测试，剩下的第三组负责增值（广告）、会员、游戏、活动业务的测试，我这组负责大数据、脚本工具相关、质量体系探索相关的工作；人员分配是这样的；在质量保障方面，除了接口自动化ui自动化的定时巡检外，还有人工巡检、monkey稳定性、客户端/服务端性能、普罗米修斯的监控和服务的监控机制、已经运维相关同事的值班机制。</span><br><span class="line"></span><br><span class="line">答⑩</span><br><span class="line">覆盖率=度量场景/所有场景*100%（由于我们没法了解到所有场景，因此覆盖率是一个主观的概念；）但我们可以以其他明确的对象为锚；如从代码覆盖/产品功能覆盖方面入手；假设我们以代码的语句/判定+条件/分支/路径/组合条件方面来判断覆盖率，假定以代码的所有属性覆盖界定为百分百，那么我们就能得到一个确定的覆盖率值（这是白盒覆盖率）；功能方面，假定所有最小粒度的功能都覆盖到了我们认为是覆盖了50%，然后每个小功能的每个可能的特征（数值/因果相关/状态流/组合）都覆盖了，假定为90%；所有可能错误都覆盖了在假定为100%；当我们发现测后环节出现问题，我们则认为当前覆盖是不足100%；然后分析问题，定位原因，明确覆盖率的不足的地方；我们要明白，覆盖率作为一个相对指标，我们一般是没法得到明确值的，要评估覆盖率的有效性，最好是通过线上质量（问题）和现有的覆盖测试大纲来对比评判；</span><br><span class="line">代码实现接口自动化框架：接口执行、接口断言、接口结果查看、多接口执行、接口构造、接口数据维护、问题收集、监控通知、结果报告、持续集成、度量体系；因此要实现的模块有，执行模块、参数构造模块、参数化模块、问题收集模块、数据存储模块、前后置处理模块、调度的控制器、智能化（可视化操作支持、效果度量/结果仪表盘）；会使用到的开源框架、pytest（用例调度/参数化）+multiprocess(并发)+request+allour</span><br><span class="line"></span><br><span class="line">答①①</span><br><span class="line">性格、协作；要具体来看，如果是工作外的，求同存异吧，我会诚恳的表达自己的观点，但我不把说法他人作为目的；如果是工作中的分歧，我会听他说出他的观点，然后我会表达出我的观点，针对分歧的地方，我一般会从商业价值，对用户的体验和价值，成效方面来表达观点，如果仍难达成一致，我会找相应的决策人员来一起协商决定，如果最后拍板了，在我了解清楚的情况下和我的观点仍不一致，我也会积极的落实。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a><strong>场景设计</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一个视频红包的场景让设计一下测试用例？</span><br><span class="line">接口、性能、压测?</span><br><span class="line">怎么进行弱网测试的？</span><br><span class="line">	Qnet腾讯、fiddler</span><br><span class="line">如果要评估一个接口的性能，首先要考虑哪几个方面？    </span><br><span class="line">测试接口时发现返回和预期不一致，应该怎样分析？</span><br><span class="line">如何根据接口文档测试接口？</span><br><span class="line">登陆界面?</span><br><span class="line">深挖项目？</span><br><span class="line">如果一个网页访问速度很慢 可能是什么原因？</span><br><span class="line">网页按钮文本框文件选择框怎么测试?</span><br><span class="line">抖音评论?</span><br><span class="line">如何测试网络直播（问了大概10分钟）？</span><br><span class="line">力扣46.全排列没做出来？</span><br><span class="line">数组中倒数第2大的数？</span><br><span class="line">百度搜索测试用例?</span><br><span class="line">测抖音注册?</span><br><span class="line">测试网易云音乐搜索窗口；?</span><br><span class="line">网易云窗口搜索关键字到返回结果的过程，经历了哪些阶段；?</span><br><span class="line">jacoco怎么统计接口覆盖率?</span><br><span class="line">设计抖音发布视频的测试用例？</span><br><span class="line">如果不同安卓版本上的抖音，一个能发布视频，一个不能，可能是什么原因？</span><br><span class="line">jmeter压测?</span><br><span class="line">针对一个零售机进行测试用例设计？</span><br><span class="line">针对一个IP地址校验的接口进行测试用例设计；（答的不好，面试官后来说是想让我给出具体的关键数据的测试用例）？</span><br><span class="line">测试一个促销活动页面，两种促销活动2选1，要注意安全性？</span><br><span class="line">有什么性能测试方法？</span><br><span class="line">微信发红包测试用例？</span><br><span class="line">微信抢红包测试用例设计?</span><br><span class="line">电梯问题设计测试用例?</span><br><span class="line">收到请求后，服务端调用了哪些相关的组件？越详细越好？</span><br><span class="line">平台开发技术栈介绍；?</span><br><span class="line">自动化介绍、测试框架介绍；?</span><br><span class="line">接口自动化设计；?</span><br><span class="line">微信朋友圈点赞功能设计测试用例 ?如果A点赞了，B没看到，写出自己排查定位原因的思路?</span><br><span class="line">自己说自己熟练使用Charles，问了下都用过Charles的哪些功能，怎么修改返回的状态码?</span><br><span class="line">U I自动化了解；?</span><br><span class="line">性能测试、健壮性测试、是否了解压测；?</span><br><span class="line">线上质量运营、COE分析。?</span><br><span class="line">接口测试、如何保证接口所有分支覆盖；?</span><br><span class="line">说出自己觉得系统中容易出现的问题；?</span><br><span class="line">测试过程中使用哪些方法或工具来测试；?</span><br><span class="line">自动化所用框架。?</span><br><span class="line">mock的底层原理?</span><br><span class="line">对于微信支付的场景设计测试用例？</span><br><span class="line">支付怎么考虑高并发？</span><br><span class="line">自动化这块，Selenium的原理、PO模式的优点？</span><br><span class="line">视频通话用什么协议？</span><br><span class="line">既然提到视频通话，那么给我说一下视频通话可能会出现什么问题？</span><br><span class="line">你如何测试它？</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：红包的显示；红包的位置；红包的动效；红包的倒计时；放置不同类商品红包的显示效果，未开奖时的点击效果，开奖时的点击效果；多个红包；领取红包时的交互动作；领取红包时的音效/特效，是否支持各类音效和特效；领取各类商品，领取成功的效果；领取各类商品，领取失败的效果，自定义各类失败的效果显示；红包跳转外部的场景、其他app、端内其他视频、端内其他活动页；红包埋点；红包兼容（系统、设备、系统版本）；红包接口的性能；红包安全机制（作弊策略）；红包未开奖时打开，等到开奖效果；红包未开奖时打开，且一直等待到红包有效期结束；红包开奖后一直等待有效期结束后效果；点击关闭按钮关闭红包；点击系统返回按钮关闭红包；打开红包后，切换到后台在切换回前台；打开红包后，切换到其他应用，在切换回来；打开红包后，断网进行领奖；触发领奖按钮后，应用崩溃；每日领取红包达到上限后，继续领取；切换不同系统语言后，领取红包；手机连上代理后领取红包；领取红包后，领取产品同步；领取功能是否稳定，用monkey重复动作；改功能在app不同版本内能否正常使用；或者有没有有效隔离</span><br><span class="line"></span><br><span class="line">答②：职业--传易音乐工作总结；重点体现在架构；维护；标准；覆盖率方面</span><br><span class="line"></span><br><span class="line">答③：两种方式，仿真模拟、另一个是真实网络环境构建；重点是弱网标准（2/3/4），弱网操作；第一种可通过fiddler配置实现，终端在通过fiddler来进行代理连接来实现弱网模拟；弱网的原理是通过延迟发送的方式来实现的即数据包/速度=时间，我可以通过变更延迟发送的时间来实现每秒的网速控制；另一种可通过搭建弱网wifi的方式实现；还有就是腾讯qnet弱网测试；覆盖场景（https://tech.kujiale.com/ku-jia-le-zhuan-xiang-ce-shi-zhi-ruo-wang-shi-zhan/https://zhuanlan.zhihu.com/p/608308463）</span><br><span class="line"></span><br><span class="line">答④：接口性能的好坏；直观的标准就是不出问题；能处理预期内的压力，并且有好的性能体验；具体标准（响应时间（平均/最大/top95响应时间），异常率，吞吐量）；判断接口性能的好坏的方法，可以直接通过触发使用场景观察接口性能，也可以通过对接口调用观察，接口压测观察；</span><br><span class="line"></span><br><span class="line">答⑤：有效性问题：先从请求入手，分析请求特点，在进行验证性的调用，如果有日志辅助的话，也可以看下过程日志定位；然后走读接口逻辑代码，确认问题；</span><br><span class="line"></span><br><span class="line">答⑥：我一般会在读文档前先调用一下接口，看是否能返回；然后我会从接口文档的响应参数，异常响应，响应耗时、超时等入手来构造数据测试；我会基于接口文档+接口应用场景等，来对接口的请求参数进行构造，一般是通过等价类、边界值、正交、场景等方法构造，来进行验证性的测试；同时我会分析接口的处理逻辑，基于处理逻辑的特定，比如涉及到除法运算，我会在分母传0等，来做进一步测试；</span><br><span class="line"></span><br><span class="line">答⑦：登录页面测试点：</span><br></pre></td></tr></table></figure>
<strong>答②: 接口/性能/压测</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接口：</span><br><span class="line"></span><br><span class="line">架构：ant+jmeter+jenkins+shell脚本+git+DashboardReport</span><br><span class="line">集成：驱动集成到了Jenkins，脚本集成到了git</span><br><span class="line">量化：H5报告通过Jenkins工作流维护了。同时也会同步到git</span><br><span class="line">监控：异常场景，邮件通知</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">维护：脚本需要手动编辑、录入、或者用工具录入；不支持自动录制，维护；</span><br><span class="line">问题分析：问题没做自动化分析，只有邮件通知，而且没有异常信息（数据采集），很难定位问题；</span><br><span class="line">实际效果：只能作为一个巡检或者监控，实际这种普罗米修斯也能做，而且能和服务更好的结合，我这个意义不大；</span><br><span class="line"></span><br><span class="line">性能：</span><br><span class="line"></span><br><span class="line">架构：jmeter+Jenkins+服务架构</span><br><span class="line">服务架构：客户端+cdn+nginx负责均衡+入口网关路由服务+业务微服务+db(mysql、Redis、MongoDB、aws s3、mq消息队列)+配置（zookeeper+apollo+dubbo+定时任务平台）+监控（普罗米修斯+skyworlking+zabbix+redis监控+kafka后台）</span><br><span class="line">性能测试流程：前提（线上暴露出了性能问题或者迹象）&#x2F;(评估当前的性能，资源情况进行成本规划)；②根据问题或者线上数据，确定期望的TPS&#x2F;平均响应时间；确定预期的TPS,响应时间（不一定有）；③开发写一个设计文档，讲述实现逻辑，压测注意点，可能要覆盖的场景；④写一个测试方案，压测用例；监控数据；⑤运维那边准备性能环境，dba准备性能数据，环境隔离等；⑥准备性能环境、工具、造数据；⑦压测时关注监控数据，主要一些资源数据，性能数据啊⑧分析数据，猜测可能问题的原因；⑨调整验证，迭代；⑩功能覆盖；①①灰度+线上监控；①②复盘，分析问题，作为后续开发规范或者闭坑点；</span><br><span class="line"></span><br><span class="line">标准制定：</span><br><span class="line">性能分析：</span><br><span class="line">性能提效+集成：</span><br><span class="line">优化策略：</span><br><span class="line">具体：全链路压测+性能基线+常态压测；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><strong>网络协议</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">浏览器输入URL发生了什么？经历了哪些阶段?</span><br><span class="line">tcp工作原理；三次握手，三次挥手？tcp四次握手？为什么要四次?</span><br><span class="line">tcp udp区别，分别应用场景？</span><br><span class="line">tcpip四层?</span><br><span class="line">滑动窗口的原理；拥塞控制和滑动窗口的区别；浏览网站输入url后网络侧的行为；SSL握手的过程？</span><br><span class="line">iso七层协议？</span><br><span class="line">讲下每层中应用的协议？</span><br><span class="line">HTTP请求状态码?</span><br><span class="line">http状态码?</span><br><span class="line">get，post请求的区别?</span><br><span class="line">http和https区别？</span><br><span class="line">三次握手中服务端拒绝连接会发生什么 ？TCP第三次握手失败怎么办，即最后一次握手失败？</span><br><span class="line">http的header有哪些；http特点；cookie和session的区别？</span><br><span class="line">dns解析过程?</span><br><span class="line">如果无法打开某个网页怎么排查问答题 （先确定服务端问题还是客户端问题，最直接的就是抓包，本地网络联通情况=&gt;DNS情况=&gt;目标服务器情况）?</span><br><span class="line">session和cookie区别（深问了好多为什么，为什么session相对安全，面试官说很多没回答到重要的点上。。）?</span><br><span class="line">session可以设计失效时间吗，根据这个设计测试用例？</span><br><span class="line">IPV4和IPV6区别?</span><br><span class="line">TCP怎么保证传输可靠性的（加问了个什么是SYN攻击，不会。。）?</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：整个过程很复杂，分为以下几个阶段如图；①应用层生成数据包并发送（浏览器解析地址，HTTP数据包构造，调用套接字方法，控制操作系统协议栈，生成TCP数据包、封装IP数据包、从而控制网卡驱动程序、生成以太数据包、信号转换发起请求）②数据链路层（子网内，请求广播给网关即路由器）③网络层（光电转换、IP协议+路由表等，数据传输给互联网路由器）④传输层（tcp(三次握手/四次挥手)+tcp ack应答机制，实现数据包传递）⑤应用层（网卡（端口、套接字、电信号转换成数字信号、包组装、缓存数据提供给应用、应用协议读取、客户端解析渲染））见上方：网络全流程图</span><br><span class="line"></span><br><span class="line">答②：见上方：网络全流程图</span><br><span class="line"></span><br><span class="line">答③：udp和tcp最大的区别是；udp是无连接的（不用建立连接），没有应答机制，没有流控制和拥塞控制；不能保障传输的可靠性和顺序；tcp有连接，有断开，有应答，有拥塞和流控制（窗口滑动机制）；能保障传输的可靠，顺序；但正因为tcp协议如此的复杂，因此在传输速度上会比udp慢；一般情况下都会使用tcp(一般都会用)，域名解析（dns域名解析使用udp）</span><br></pre></td></tr></table></figure>
<h4 id="系统-云原生"><a href="#系统-云原生" class="headerlink" title="系统/云原生"></a><strong>系统/云原生</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linus命令：比较两个文件内容的不同命令？</span><br><span class="line">将下linux管道<span class="built_in">kill</span>、grep?</span><br><span class="line">linus将全部文件及子文件中包含aaa的替换成bbb？</span><br><span class="line">Shell命令有哪些？</span><br><span class="line">linux常用指令 chmod?</span><br><span class="line">微服务 单体式的区别 哪个好?</span><br><span class="line">Linux查端口号，Linux查文件最后50行？</span><br><span class="line">linux 查询进程?</span><br><span class="line">ls 和ll区别?</span><br><span class="line">熟悉微服务框架吗；?</span><br><span class="line">进程和线程的区别?</span><br><span class="line">讲下Linux文件命令（is <span class="built_in">cd</span> touch mkdir mv cp ln ）?</span><br><span class="line">在A文件中查字符串“bcd”什么命令（ cat A.txt| grep -<span class="string">&quot;bcd&quot;</span>  ）?</span><br><span class="line">进程之间的通信方式?</span><br><span class="line">Liunx查看磁盘里某个大文件大小（答的 “du”  让具体说一个答的 “du -h -a/dir | grep<span class="string">&quot;[0-9]G\b”）?</span></span><br><span class="line"><span class="string">awk的用法和参数？</span></span><br><span class="line"><span class="string">Linux：查找某目录下所有.log结尾的文件，并筛选出文件中的第三个字段，进行求和？</span></span><br><span class="line"><span class="string">内存溢出和内存泄露的区别？</span></span><br><span class="line"><span class="string">cpu调度算法？</span></span><br><span class="line"><span class="string">线程死锁的原因？</span></span><br><span class="line"><span class="string">解决死锁的方法（不让答八股文，问如何在代码中实现）</span></span><br><span class="line"><span class="string">进程和线程及协程的区别？</span></span><br><span class="line"><span class="string">怎么避免服务器集群里面单点接收太多请求而其他服务器却空闲的问题?</span></span><br><span class="line"><span class="string">rabbit mq怎么设计单侧用例？</span></span><br><span class="line"><span class="string">linux怎么查找一个文件里面的某一行，用哪几个指令?</span></span><br><span class="line"><span class="string">进程、线程通信方式?</span></span><br><span class="line"><span class="string">怎么保证线程修改数据时不会冲突?</span></span><br><span class="line"><span class="string">linux内存占用过高，该怎么看是哪个进程在哪出了问题?</span></span><br><span class="line"><span class="string">讲一下在项目中Docker运用?</span></span><br><span class="line"><span class="string">K8s里node和pod是什么关系?</span></span><br><span class="line"><span class="string">Docker，问了常用命令、主机的文件复制到容器里的命令？</span></span><br><span class="line"><span class="string">讲一下K8s？</span></span><br><span class="line"><span class="string">RPC的理解，了解Dubbo么？</span></span><br><span class="line"><span class="string">负载均衡，服务器配置（实话实说没操作过，讲了下负载均衡是怎样的）？</span></span><br><span class="line"><span class="string">栈溢出的场景？</span></span><br><span class="line"><span class="string">什么时候触发FullGC？</span></span><br><span class="line"><span class="string">docker 部署，包含组件?</span></span><br><span class="line"><span class="string">操作系统原子性；页面置换算法有哪些？</span></span><br><span class="line"><span class="string">查看java相关进程所占内存大小并按升序输出 ?ps auxw --sort=%MEM | grep java</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：diff txt1 text2 -y -W 50		//-y指以并列形式显示两个文件的不同，-W指单列宽度为50</span><br><span class="line"></span><br><span class="line">答②：管道符号|会将前方的输入作为标准输出，输出给后方命令（当一些命令如ls、mkdir不接受标准输出时，还需要对标准输出进行转换，如<span class="built_in">echo</span> hello| xargs ls）；</span><br><span class="line"><span class="built_in">kill</span> 用来关闭进程或线程，可在关闭时传递信号如<span class="built_in">kill</span> -9(强制信号) pid，如此命令是<span class="built_in">kill</span>掉所有相关名称的进程或线程（ps -a | grep github | awk <span class="string">&#x27;NF=1&#x27;</span> | xargs <span class="built_in">kill</span> -9）；</span><br><span class="line">grep：文本过滤函数。可过滤出文本中含关键词的行grep <span class="string">&quot;过滤关键字&quot;</span> txt;</span><br><span class="line"></span><br><span class="line">答③：替换操作使用sed命令。sed -i <span class="string">&#x27;s/替换前参数/替换后/g&#x27;</span> txt;因此整个命令为，<span class="string">&quot;grep -rl &#x27;替换前参数&#x27; 路径|xargs sed -i &#x27;s/替换前参数/替换后/g&#x27;&quot;</span>；</span><br><span class="line"></span><br><span class="line">答④：很多；常见的目录文件操作：ls 、touch、cp、vim、rm、mv；权限用户：chmod、chown、who、su、passwd；文本操作：cat、tail、head、grep、sed、awk；资源监控：du、df、free、vmstat、top、ps、netstat、tcpstat、lsof；系统：env、<span class="built_in">export</span>、dmesg、uname；时间：time、date、sleep；</span><br><span class="line"></span><br><span class="line">答⑤：chmod是授权函数；在linux文件中，权限分为读/写/执行，每个文件的权限角色有所有者/所有组/其他人，chmod能基于此规则，给不同的角色授予不同的权限；如+增加权限 （chomod -R +124/777 ./）,表示给当前文件夹及其子文件夹所有者执行权限，所有组写权限，其他人读文件权限；可通过ls -l查看；</span><br><span class="line"></span><br><span class="line">答⑥：单体式，指将一个程序系统打包成一个独立的程序单元；而微服务指将程序系统按业务分拆成不同的独立服务；单体式的优点是开发、扩展功能、部署方便，缺点是不利于维护、重用、修改；微服务会增加开发、维护的难度，但拆分后服务的复杂度低，灵活性强、可独立部署、容错性强，更方便扩展；</span><br><span class="line"></span><br><span class="line">答⑦：查端口号可以使用以下两个命令（lsof -i|grep pid/netstat -nap|grep pid）</span><br><span class="line"></span><br><span class="line">答⑧：查询进程ps -ef|grep pro/netstat -anp|grep pid/lsof -p pid/lsof -i tcp:80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="sql数据库"><a href="#sql数据库" class="headerlink" title="sql数据库"></a><strong>sql数据库</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql：Like Distinct?</span><br><span class="line">数据库了解吗，关键字有哪些?</span><br><span class="line">100个页面的100个商品；每个商品都有访问次数，需要返回访问总次数top10的页面中的访问次数top10的商品</span><br><span class="line">什么时候不适合用索引？</span><br><span class="line">数据库acid</span><br><span class="line">知道数据索引吗，为什么说索引能提高效率呢？</span><br><span class="line">Mysql怎么创建表，字段；查第十行到第二十行的数据关键字?</span><br><span class="line">mysql统计学生表男生的人数?</span><br><span class="line">mysql分组?</span><br><span class="line">mysql里面索引有哪些；SQL慢查询的原因；主键索引和非主键索引是如何实现的？</span><br><span class="line">mysql内联和外联?</span><br><span class="line">MySql和Redis的区别?</span><br><span class="line">Mysql 出现慢查询的原因（答的是1.先开慢日志开关     2.进行慢日志分析    3.查看硬件问题如网络速度慢，内存不足     4.没有索引或者索引失效    5.数据过多，分库分表      5服务器参数调优my.cnf）?</span><br><span class="line">数据库事务的特性（ACID）?</span><br><span class="line">写SQl，查询A表后10行数据（思路 将表中的数据以id倒序查出所需要的行数，然后将结果保存为临时表，再根据临时表的Id将结果正序排列）?</span><br><span class="line">介绍项目中Redis的使用，二次缓存的一致性保证，数据库持久化是怎么做的等等；？</span><br><span class="line">redis的大key问题怎么解决？</span><br><span class="line">怎么找出redis里面所有的大key？</span><br><span class="line">分redis的数据结构说呢&#123;string、<span class="built_in">set</span> 、<span class="built_in">hash</span>&#125;?</span><br><span class="line">分布式的热key问题?</span><br><span class="line">索引的优缺点,索引的类别?</span><br><span class="line">SQL写出创建唯一索引?</span><br><span class="line">redis的基本类型?</span><br><span class="line">redis的作用，他为什么快?</span><br><span class="line">redis怎么应对很多用户的并发访问?</span><br><span class="line">redis的锁，代码实现？</span><br><span class="line">mysql自增键的使用？</span><br><span class="line">对于<span class="string">&quot;%x%&quot;</span>和性别怎么加索引？</span><br><span class="line">数据库题目里面<span class="built_in">limit</span>的关键字是什么作用?</span><br><span class="line">索引越多越好吗?</span><br><span class="line">什么是数据库事务?</span><br><span class="line">聚簇索引和非聚簇索引?</span><br><span class="line">Redis持久化、如何保证缓存中的数据持续有效命中？</span><br><span class="line">sql，一张表，一条语句，得到成绩&gt;=60和&lt;60的人数，不能使用两条语句分别查询？</span><br><span class="line">慢查询怎么定位具体哪的问题？</span><br><span class="line">ACID?</span><br><span class="line">读锁，写锁的区别?</span><br><span class="line">死锁?</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：like是模糊匹配函数，通常在<span class="built_in">where</span>过滤中使用；通配符有%_[]等；distinct是参数去重函数，通常在select子句中使用，能对结果集中的特定列的值去重显示；</span><br><span class="line"></span><br><span class="line">答②：问题很大，不可能全部覆盖，因此需要考虑全面</span><br><span class="line">数据：增加insert into、delete/drop/update select count/sum/avg from join/right <span class="built_in">where</span> groub by union order by <span class="built_in">limit</span></span><br><span class="line">库：create databases、drop databases、show databases</span><br><span class="line">表：create table、drop table、alter table、desc table、show table(表数据)</span><br><span class="line">其他：视图create view、存储过程、事物处理的方法</span><br><span class="line"></span><br><span class="line">答③：select *,</span><br><span class="line">   row_number() over (partition by 页面，商品</span><br><span class="line">                 order by 商品访问次数 desc) as ranking</span><br><span class="line">   from 班级表 <span class="built_in">limit</span> 10</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">	<span class="keyword">for</span> (select top 10 页面id from 页面 order by 页面pv desc) as page</span><br><span class="line">    select 商品id from 商品 <span class="built_in">where</span> 页面id <span class="keyword">in</span> page.id order by 商品pv desc</span><br></pre></td></tr></table></figure>
<h4 id="大数据-1"><a href="#大数据-1" class="headerlink" title="大数据"></a><strong>大数据</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">项目中用了Elasticsearch，其中的遇到难点是什么呢（答的 es如何跨域 和 es如何通过内网IP进行访问  ）？</span><br><span class="line">如何解决的呢 （答的是通过修改添加config.yml 参数）？</span><br><span class="line">提到过大数据，问了Hive，问了我数据倾斜（表示没听过，就讲了下数据清洗）？</span><br><span class="line">介绍下大数据架构？</span><br><span class="line">介绍下大数据的各组件？</span><br><span class="line">介绍下模型质量评测？</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">先看下</span><br></pre></td></tr></table></figure>
<h4 id="语言-算法"><a href="#语言-算法" class="headerlink" title="语言/算法"></a><strong>语言/算法</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">代码题，列出一个列表中重复的元素?</span><br><span class="line">工作中遇到多进程/多线程的问题？</span><br><span class="line">代码：全排列?</span><br><span class="line">序列号生成的方式？</span><br><span class="line">字典的底层实现方式?</span><br><span class="line">并发和并行的概念，区别?</span><br><span class="line">写代码：字典排序，最长公共前缀?</span><br><span class="line">sort和sorted区别?</span><br><span class="line">了解设计模式吗；?</span><br><span class="line">大概意思：点击一个url，会包含其它url，查找其中包含图片.jpg的所有url?</span><br><span class="line">Python多线程和多进程的性能问题？</span><br><span class="line">最大连续数组的和？</span><br><span class="line">车在停车库丢了，不知道什么时间丢的你要去查监控怎么最快锁定丢车的时间?</span><br><span class="line">python的数据类型有哪些？</span><br><span class="line">1-100个数，无重复 有一个数丢失 高效查找丢失的数？</span><br><span class="line">整型占几个字节、int型数据范围?</span><br><span class="line">分布式环境，1000个子节点全部包含数值型数据 如何查找10个数值最大的？</span><br><span class="line">了解哪些排序算法，哪些是稳定的、哪些是不稳定的?</span><br><span class="line">算法题 两链表相加?</span><br><span class="line">最长不重复子串？</span><br><span class="line">字典、数组、链表、队列、堆栈了解吗?python中数组、队列、堆栈的区别和使用？</span><br><span class="line">coding：最长回文字符串？</span><br><span class="line">数据结构：对称二叉树 ，判断是否是对称二叉树 口述代码，递归的出口，算法的时间复杂度？</span><br><span class="line">科学计数方面的包，介绍用神经网络做的项目，图片分类的算法CNN，介绍CNN，二分类，为什么线性分不了(GBDT)?</span><br><span class="line">动态链接和静态链接?</span><br><span class="line">用什么模型进行分类？</span><br><span class="line">为什么选择CNN而不是SVM等其他的算法分类，选取算法的标准是什么？</span><br><span class="line">选取什么作为机器的输入？</span><br><span class="line">用CNN做了那些调优包括参数的选取方面？</span><br><span class="line">卷积的过程、卷积主要起到了什么作用？卷积的目的是什么？</span><br><span class="line">过拟合和欠拟合的区别？</span><br><span class="line">预防过拟合的方法？</span><br><span class="line">堆和栈的区别？程序运行过程中，什么会存放到栈上，什么会放在堆上？</span><br><span class="line">手撕代码：链表中是否存在环？</span><br><span class="line">python如何倒序输出数组，切片的-1是什么意思</span><br><span class="line">python字典的key能否为数组</span><br><span class="line">python的深拷贝和浅拷贝</span><br><span class="line">python的垃圾回收机制</span><br><span class="line">实现list中的数字组成的数加1，题目是英文的，list形式输出</span><br><span class="line">  举例：</span><br><span class="line">  输入[1,2,3,4] 输出[1,2,3,5]</span><br><span class="line">  输入[9,9,9]  输出[1,0,0,0]</span><br><span class="line">coding：500张牌，每次取走奇数位置的牌，最后剩下一张是多少</span><br><span class="line">测试用例设计 算法题怎么测?</span><br><span class="line">算法 最大连续子数组和？</span><br><span class="line">python 语言特性?</span><br><span class="line">最长无重复子串?</span><br><span class="line">合并两个有序数组?</span><br><span class="line">数组是连续的空间，扩容拷贝是谁做的，具体的原理。扩容的大小？</span><br><span class="line">队列、堆、栈的区别，函数调用另一个函数是用什么数据结构实现的?</span><br><span class="line">python里面有几种锁？</span><br><span class="line">青蛙跳台阶，一次可以跳1或2个台阶，问：N级的台阶总共有多少种跳法？</span><br><span class="line">分析递归方法的时间复杂度（2**n）和空间复杂度（最深路径时为n）？</span><br><span class="line">python单例模式了解嘛（没答出来）、垃圾回收机制?</span><br><span class="line">数据库修改字段语句、sql语句错误或查询慢、牵引出索引?</span><br><span class="line">二叉树知道哪些，完全二叉树、搜索二叉树，平衡二叉树，说一下完全二叉树，说一下搜索二叉树?</span><br><span class="line">手撕代码两道题，一道是判断合理的字符括号，一道是最长的增序子集长度?</span><br><span class="line">python面向对象特性?</span><br><span class="line"> Collections合集介绍下？</span><br><span class="line">你怎么理解多态的?</span><br><span class="line">重载和重写的真实例子?</span><br><span class="line">函数参数传递是怎么传递的?</span><br><span class="line">如果方法中定义了一个基本类型变量和引用变量，他们的生命周期是什么样子的?</span><br><span class="line">静态方法可以访问非静态变量嘛?</span><br><span class="line">非静态方法可以访问静态变量嘛?</span><br><span class="line">静态变量，成员变量储存在哪？</span><br><span class="line">手撕代码：驼峰字符？</span><br><span class="line">力扣第3题无重复字符最长字串？</span><br><span class="line">算法快排?</span><br><span class="line">了解过其他类似Springboot的框架么?</span><br><span class="line">讲下Java和python 对于内存管理的不同?</span><br><span class="line">了解Exception和Error 的区别么?</span><br><span class="line">讲下您遇到的Exeption ?</span><br><span class="line">讲下您遇到的Error?</span><br><span class="line">归并排序？</span><br><span class="line">面向对象七大设计原则；？</span><br><span class="line">不同类型的对象在内存中怎么存储；？</span><br><span class="line">什么是泛型，泛型擦除一定会发生吗？</span><br><span class="line">什么时候服务端会发生大量time_wait和close_wait状态？</span><br><span class="line">手撕算法：实现一个算法，找到两个有序数组所有元素一起的中位数？</span><br><span class="line">知道哪些设计模式，单例模式懒汉式口述一下怎么写，volatile的作用是什么？</span><br><span class="line">手撕代码：KMP字符串匹配算法；？</span><br><span class="line">讲一个定下目标但最终放弃了的经历？</span><br><span class="line">讲一个你最讨厌室友的哪一点？</span><br><span class="line">python的装饰器？</span><br><span class="line">python：列表三个参数，切片和步长？</span><br><span class="line">密集IO型任务应该用多线程还是多进程？</span><br><span class="line">并发怎么控制？</span><br><span class="line">有哪些印象深刻的排序算法？这些算法复杂度是多少？哪些稳定？</span><br><span class="line">对于大数据上百万的数据排序怎么选择排序算法？</span><br><span class="line">堆排序相关？</span><br><span class="line">了解图论的相关知识吗？</span><br><span class="line">讲一讲最短路径、迪杰斯特拉之类的？</span><br><span class="line">hashset、hashmap？应用场景？</span><br><span class="line">两数之和，要求算法复杂度0（N）？</span><br><span class="line">怎么验证是不是o（n）的复杂度？</span><br><span class="line">进程调度算法？</span><br><span class="line">去除一段代码中所有的注释：包括//与/**/?</span><br><span class="line">要考虑//与/**/作为字符串存在的情况?</span><br><span class="line">两数之和=目标值的所有数组下标?</span><br><span class="line">aop的动态代理机制？</span><br><span class="line">n个盘子放m个水果，有多少种可能？</span><br><span class="line">怎么解决幂等的问题？</span><br><span class="line">python的深拷贝、浅拷贝的区别？</span><br><span class="line">python的内存管理机制（垃圾回收+内存池），会追问具体？</span><br><span class="line">GIL锁？</span><br><span class="line">PIL?</span><br><span class="line">可变数据类型，不可变数据类型?</span><br><span class="line">class_method的用途?</span><br><span class="line">Django 请求的过程?</span><br><span class="line">Django,Flask的区别?</span><br><span class="line">  [魔法外卖]</span><br><span class="line">  给定数组nums，长度为n，代表n个外卖的超时时间。外卖员可以花费时间t送一份外卖，一次只能送一份，也可以使用一次魔法不花费时间送一次外卖。</span><br><span class="line">  求要求所有外卖不超时需要的最少使用魔法次数。</span><br><span class="line">  1 &lt;= n &lt;= 1e5, 1 &lt;= t &lt;= 100, 1 &lt;= nums[i] &lt;= 1e7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  输入：</span><br><span class="line">  6 5</span><br><span class="line">  5 6 7 8 9 10</span><br><span class="line">  输出：</span><br><span class="line">  4</span><br><span class="line">  输入：</span><br><span class="line">  6 5</span><br><span class="line">  101 102 103 104 105 106</span><br><span class="line">  输出：</span><br><span class="line">  0</span><br><span class="line">  代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  import java.util.*;</span><br><span class="line"></span><br><span class="line">  public class Main &#123;</span><br><span class="line"></span><br><span class="line">      // 贪心策略</span><br><span class="line">      // 第一个t，优先送[t, 2t - 1]的外卖，其次送[2t, 3t - 1]的外卖，以此类推</span><br><span class="line">      // 第二个t，优先送[2t, 3t - 1]的外卖，其次送[3t, 4t - 1]的外卖，以此类推</span><br><span class="line">      // ...</span><br><span class="line">      public static int minOps(int[] nums, int t) &#123;</span><br><span class="line">          int max = 0;</span><br><span class="line">          int ans = 0;</span><br><span class="line">          // 有序表中存储第key个t，优先处理的外卖个数</span><br><span class="line">          // 如[5,6,7,8,9,10],t=5</span><br><span class="line">          // map里存放&#123;1=5,2=1&#125;</span><br><span class="line">          TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (int num : nums) &#123;</span><br><span class="line">              map.put(num / t, map.getOrDefault(num / t, 0) + 1);</span><br><span class="line">              max = Math.max(max, num);</span><br><span class="line">          &#125;</span><br><span class="line">          int cur = t;</span><br><span class="line">          <span class="keyword">while</span> (cur &lt; max + 1) &#123;</span><br><span class="line">              int num = cur / t;</span><br><span class="line">              Integer next = map.ceilingKey(num); // 找到第num个t优先处理的外卖</span><br><span class="line">              <span class="keyword">if</span> (next != null) &#123;</span><br><span class="line">                  map.put(next, map.get(next) - 1);</span><br><span class="line">                  <span class="keyword">if</span> (map.get(next) == 0) &#123;</span><br><span class="line">                      map.remove(next);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              cur += t;</span><br><span class="line">          &#125;</span><br><span class="line">          // 能处理的外卖已经被处理了，剩下的只能用魔法处理</span><br><span class="line">          <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">              ans += value;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          Scanner sc = new Scanner(System.in);</span><br><span class="line">          int n = sc.nextInt();</span><br><span class="line">          int t = sc.nextInt();</span><br><span class="line">          int[] nums = new int[n];</span><br><span class="line">          <span class="keyword">for</span> (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">              nums[i] = sc.nextInt();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(minOps(nums, t));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  第二题</span><br><span class="line">  [扑克]</span><br><span class="line">  有n张纸牌，点数为1-n，每次将堆顶的牌拿两张放到堆底，然后取出堆顶的牌记录点数，操作完所有的牌后，会记下一个序列，根据这个序列还原最初的序列。</span><br><span class="line">  1 &lt;= n &lt;= 100000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  输入</span><br><span class="line">  4</span><br><span class="line">  1 2 3 4</span><br><span class="line">  输出</span><br><span class="line">  4 2 1 3</span><br><span class="line">  思路：按照题目要求反向模拟即可。</span><br><span class="line"></span><br><span class="line">  代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  import java.util.*;</span><br><span class="line"></span><br><span class="line">  public class Main &#123;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          Scanner sc = new Scanner(System.in);</span><br><span class="line">          int n = sc.nextInt();</span><br><span class="line">          int[] nums = new int[n];</span><br><span class="line">          <span class="keyword">for</span> (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">              nums[i] = sc.nextInt();</span><br><span class="line">          &#125;</span><br><span class="line">          Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">              deque.addFirst(nums[i]);</span><br><span class="line">              int num = deque.pollLast();</span><br><span class="line">              deque.addFirst(num);</span><br><span class="line">              num = deque.pollLast();</span><br><span class="line">              deque.addFirst(num);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">              System.out.print(deque.pollFirst() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">怎么修改元组?</span><br><span class="line">算法题，找到最后一个不重复字符?</span><br><span class="line">Restful 风格,什么是OpenAI?</span><br><span class="line">selenium等待?</span><br><span class="line">pytest,pass,fail,error的区别?</span><br><span class="line">abcde * 4 = edcba，求各个字母代表多少?</span><br><span class="line">深浅copy?</span><br><span class="line">垃圾回收机制（这里深问了，针对每种机制，提出自己的改进措施，回答的有点乱）?</span><br><span class="line">删除有序链表中重复的元素-II?</span><br><span class="line">顺序表和链表有什么区别？</span><br><span class="line">冒泡排序的时间复杂度，为什么是这个时间复杂度？（其实就是考察冒泡的思想）？</span><br><span class="line">算法：IEDA写反转链表、二叉树后序遍历？</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答：【腾讯文档】算法题①https://docs.qq.com/doc/DSVNFRU5BU3pCZ2hh</span><br><span class="line"></span><br><span class="line">答②：多进程/线程：工作中主要是UI自动化，多设备执行的场景；客户端性能，monkey，资源采集多设备的场景会用到多进程；只所以这样是因为Python多线程，有gil（全局解释器锁，这是互斥锁），同时只能有一个线程能拿到锁，只能使用多核设备的一个核进行上下文切换，本质上没有并发（cpython有此机制，jpython没有）；多进程使用的模块multiprocessing模块（进程池/管道/队列/遍历）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管理协作"><a href="#管理协作" class="headerlink" title="管理协作"></a><strong>管理协作</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果让我从头搭建一个团队 我将从哪几个方面开始规划?</span><br><span class="line">我的领导与下属怎么评价我 ?</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：团队是为公司战略服务的，因此需要基于战略来规划团队；从以下方面考虑；</span><br><span class="line">规划：理解公司的战略规划，拆解到具体自己所在的组，明确负责组的短长期的职责和规划；基于规划来分配资源；</span><br><span class="line">成本：提前做好预算和成本把控，和公司财务及管理层，协商；</span><br><span class="line">资源：引入合适的人员（考虑人员风格、专业能力、性格、协作能力、解决复杂问题的能力、价值观是否是公司需要的）；</span><br><span class="line">运营：根据当前的项目、战略和资源情况，制定合适的OKR；用来运营管理人员，坚持价值驱动，一起成长的理念；本着公正、尊重、包容、身体力行的态度，做好先行者工作；</span><br><span class="line">工具：运用好管理/评测/统计类工具，使团队的工作运营能实现数字化、透明、提升团队的效率；</span><br><span class="line">迭代：做好团队的成长规划，和公司战略结合；坚持能者上，不能者下的公平原则；和业务结合，做好引导创新的工作；设计好合理的协作，优化机制。针对问题及时优化处理；</span><br><span class="line"></span><br><span class="line">答②：这个问题比较复杂；考虑从上级管理/成绩/协作/风格，同时这是个匹配度问题；</span><br><span class="line">我想一下，团队之间，关系还比较亲密；除了工作私下也经常联系，会一起玩；对我的评价，我的上级莉姐，有说个几个方面吧（情商不高，太实诚，和外部对接的时候容易承诺别人，主动去抗责任；踏实，但不擅长表现工作的价值吧，不懂上级的需求吧（主要是他觉得我的PPT做的很差，向上级汇报的ppt,我记的最多的他让我改了近二十次）；同事反馈的最多的，除了上面的这两种，有时候他们会觉得我有点话痨吧；）</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对我们公司了解?知道和现在的公司多达区别？为什么选择我们公司？</span><br><span class="line">离职原因？</span><br><span class="line">从技术角度我给现在的公司带来了哪些改变，我为公司提供了什么价值？</span><br><span class="line">自我介绍 英文？</span><br><span class="line">为什么做测试？为什么不做开发？</span><br><span class="line">为什么要做测开，对测开的理解？</span><br><span class="line">对团队有什么价值?在团队中的职责、做了哪些事情?</span><br><span class="line">自我介绍？</span><br><span class="line">项目介绍？</span><br><span class="line">怎么自学的？</span><br><span class="line">项目、扮演什么角色？</span><br><span class="line">对新岗位的期望？</span><br><span class="line">如果你遇到一个bug，研发不承认，你怎么操作?</span><br><span class="line">印象最深的一个Bug?</span><br><span class="line">目前薪资，期望薪资?</span><br><span class="line">职业规划?</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">答①：风格、价值观的问题（以shein举例）；有一定的了解，了解到公司是做海外电商的，主要做快时尚服饰产品，现在在向电商平台迈进；美国是公司最大的市场，去年的营业额超过了300亿美金；很认可公司的价值观，客户至上，全力以赴，快速反映、融合协作、创新；之所以选择公司，是因为公司盛名远播，在快速发展，个人有很好的发展机会；公司和自己比较匹配，因为我也是做海外市场的，很认可公司的企业文化，来之前通过朋友也了解过团队的氛围，这也是我很喜欢的一点；</span><br><span class="line"></span><br><span class="line">答②：离职原因（实话实说，侧重客观）</span><br><span class="line"></span><br><span class="line">答③：业务方面（质量），体系方面（自动化体系），专项方面（专项能力），流程方面（sop）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="面试复盘"><a href="#面试复盘" class="headerlink" title="面试复盘"></a>面试复盘</h3><p><strong>2023/08/04    海外小说公司STARY        测试工程师    结论：通过面试；婉拒</strong></p>
<p><code>公司规模较小，深圳这边可能就一百人左右，研发共四十多人，其中测试七人；需要招一个提升团队技术的测试人员（确定？）；</code></p>
<p><strong>问题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">思路不太清晰；</span><br><span class="line">简历没有吃透，其中的云原生，大数据相关问题说不上来；</span><br><span class="line">针对问题，没有系统的整理；</span><br></pre></td></tr></table></figure>

<p><strong>2023/08/06    客路旅行    高级性能测试        结论：应该未通过面试</strong><br><code>公司规模很大，应该类似于传易集团；业务线很多，其中测试总人数有60人，分各业务线和基础效能部门；</code></p>
<p><strong>问题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">k8s介绍未答出来；</span><br><span class="line">索引有哪些未答出来；</span><br><span class="line">协程介绍未答出来；</span><br><span class="line">装饰器答的不好；</span><br><span class="line">面试过程中，我太急了，没理解问题，和面试官的目的就答了；</span><br><span class="line">思路不清晰，反复问的时候，我有点不记得了（真实/思路）；</span><br><span class="line">Python中的闭包是什么意思？</span><br><span class="line">流量录制工具</span><br></pre></td></tr></table></figure>

<p><strong>答:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">⑦闭包是指将可调用对象和环境闭包在一起，一般是指将但参数的方法或类嵌套到包装方法/类中；常用的闭包操作有，委托机制，工厂函数，装饰器</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>题库</tag>
        <tag>岗位</tag>
        <tag>复盘</tag>
      </tags>
  </entry>
</search>
